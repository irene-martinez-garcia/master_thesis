---
title: "AlberdiLab | Master Thesis"
subtitle: MSc project
author:
  - Irene Martínez, M Thomas P Gilbert, Antton Alberdi^[University of Copenhagen, antton.alberdi@sund.ku.dk]
date: "Last update: `r Sys.Date()`"
site: bookdown::bookdown_site
documentclass: book
bibliography: [book.bib, packages.bib]
url: https://github.com/irene-martinez-garcia/master_thesis 
description: |
  Data analysis code for comparative metagenomics of gut microbiome bacterial species in several vertebrates
link-citations: yes
github-repo: irene-martinez-garcia/master_thesis
---

```{r knitr_opts, echo=FALSE}
knitr::opts_chunk$set(
    class.source = "script-source",
    class.output = "script-output",
    comment = NA)
```

# Introduction

This webbook contains all the code used for data analysis for the comparative metagenomics analysis of gut microbiome bacterial species in several vertebrates.

## Prepare the R environment

### Environment

To reproduce all the analyses locally, clone this repository in your computer using:

```
RStudio > New Project > Version Control > Git
```

And indicating the following git repository:

> https://github.com/irene-martinez-garcia/master_thesis.git

Once the R project has been created, follow the instructions and code chunks shown in this webbook.

### Libraries

The following R packages are required for the data analysis.

```{r load_libraries, warning=FALSE, comments="", message=FALSE}
# Base
library(R.utils)
library(knitr)
library(tidyverse)
#library(devtools)
library(tinytable)
library(rairtable)
library(janitor)
library(broom)

# For tree handling
library(ape)
library(phyloseq)
library(phytools)

# For plotting
library(ggplot2)
library(ggrepel)
library(ggpubr)
library(ggnewscale)
library(gridExtra)
library(ggtreeExtra)
library(ggtree)
library(ggh4x)
library(UpSetR)
library(viridis)
library(RColorBrewer)
library(countrycode)

# For statistics
library(spaa)
library(vegan)
library(Rtsne)
library(geiger)
library(distillR)
library(ANCOMBC)
library(lme4)
library(nlme)
library(pairwiseAdonis)
library(emmeans)
library(pheatmap)
library(rstatix)
library(uwot)
```

<!--chapter:end:index.Rmd-->

# Data preparation


## Searching for the MAGs
1) Choose the MAGs   
For this project, the following bacterial species were selected: _Lactococcus lactis_, _Hafnia paralvei_, _Enterococcus faecalis_, _Bacteroides uniformis_, _Phocaeicola vulgatus_, _Parabacteroides goldsteinii_, _Citrobacter braaki_, _Akkermansia municiphila_, _Enterococcus hirae_ and _Bacteroides fragilis_.

EHI MAGs:
In the EHI database, select the MAGs with > 90% completeness and < 2.5 contamination for each of the species.

GTDB MAGs:
("NCBI Taxonomy" CONTAINS "Lactococcus lactis" AND "CheckM2 Completeness" > "90" AND "CheckM Contamination" < "2.5" AND ("Isolation Source" CONTAINS "feces" OR "Isolation Source" CONTAINS "excrement" OR "Isolation Source" CONTAINS "metagenome" OR "Isolation Source" CONTAINS "microbiome" OR "Isolation Source" CONTAINS "gut" OR "Isolation Source" CONTAINS "faeces" OR "Isolation Source" CONTAINS "fecal") AND "Isolation Source" IS NOT "N/A")

NCBI MAGs:
Refer to 03_downloading_mags.Rmd

## Downloading the MAGs and generating data
2) Download genome indices and metadata    
Download the EHI_MAG index for each species (in /data/mags_metadata folder) and the curl file and search metadata tsv from the GTDB and place in each species directory in Mjolnir.

2.5) Extract genome metadata   
- Use the GTDB search tsv to run this script to obtain more metadata. 

```{bash, eval = FALSE}
snakemake -s /maps/projects/alberdilab/people/pjq449/comparative_metagenomics/snakefiles/gtdb_metadata_pipeline.smk -j 1 --use-conda --rerun-incomplete
```

METADATA FILES:
-The EHI metadata files : data/mags_metadata/lactococcus_lactis_metadata.tsv
-The GTDB metadata files: data/mags_metadata/lactococcus_lactis_gtdb_final_metadata.tsv
-The NCBI metadata files: lactococcus_lactis_ncbi_metadata.rds 

3) Create the master index   
Run the create_index.R script to create an index of all the MAGs and the download paths (needs a list of species as input  and right now it is hardcoded in the script)
```{bash, eval = FALSE}
conda activate r_env
Rscript scripts/create_index.R 
```

4) Run the downloading_mags.smk to download all the genomes
```{bash, eval = FALSE}
module load snakemake
#testing

snakemake -s snakefiles/downloading_and_unzipping.smk \
  --executor slurm \
  --jobs 50 \
  --rerun-incomplete \
  --keep-going \
  --rerun-triggers mtime

```

Download the MAGs from the NCBI
```{bash, eval = FALSE}
### DOWNLOAD THE MAGS - add this to download and unzip mags??
conda activate drakkar_env 

#Run this inside the mags folder
datasets download genome accession --inputfile ../phocaeicola_vulgatus_ncbi_selected_accessions.txt --include genome --filename phocaeicola_vulgatus_ncbi_selected_genomes.zip

#then unzip
zip="phocaeicola_vulgatus_ncbi_selected_genomes.zip"

mkdir -p unzipped

unzip -Z1 "$zip" | grep '\.fna$' | while read -r f; do
    acc=$(basename "$(dirname "$f")")
    echo "Extracting $acc"
    unzip -p "$zip" "$f" > "unzipped/${acc}.fna"
done

```


5) Run drep
```{bash, eval = FALSE}
sbatch scripts/drep_compare.slurm
```

6) Remove the MAGs that are <95% ANI (not the same species)
```{bash, eval = FALSE}
python3 scripts/filter_by_cdb.py data data/clusters_to_drop.tsv 
```

6.2) Re-run drep without removed MAGs
```{bash, eval = FALSE}
sbatch --export=SPECIES="$SPECIES" scripts/rerun_drep_removed.sh
```


6) Make a screen session for each species.
```{bash, eval = FALSE}
screen -S parabacteroides_distasonis
```


7) Run drakkar annotating_function.smk to re-annotate all the MAGs:
```{bash, eval = FALSE}
drakkar annotating -b /maps/projects/alberdilab/people/pjq449/comparative_metagenomics/data/phocaeicola_vulgatus/mags/unzipped -o /maps/projects/alberdilab/people/pjq449/comparative_metagenomics/data/phocaeicola_vulgatus --env_path /projects/alberdilab/data/environments/drakkar --annotation-type function 
```


7.1) Run contig to genome mapping
```{bash, eval = FALSE}
bash /maps/projects/alberdilab/people/pjq449/comparative_metagenomics/scripts/build_contig_to_mag_maps_all.sh  # though in the end i just ran one in terminal directly
```


8) Pangenome analysis with ppanggolin
```{bash, eval = FALSE}
snakemake --snakefile Snakefile.pangolin \
          --configfile snakefiles/pangolin_config.yaml \
          --use-conda \
          -j 40
```


<!--chapter:end:01_data_preparation.Rmd-->

# EHI MAGs exploration

### EHI MAGs
```{r load data preparation}
load("data/data.Rdata")
```


```{r load ehi mags}
library(tidyverse)
ehi_mags <- read_csv("data/ehi_metadata_location.csv")
colnames(ehi_mags)
```
Check contamination and completeness
```{r contamination and completeness}
genome_biplot <- ehi_mags %>%
  dplyr::select(c(phylum,completeness,contamination,size)) %>%
  ggplot(aes(x=completeness,y=contamination,size=size,color=phylum)) +
              geom_point(alpha=0.7) +
                    xlim(c(70,100)) +
                    ylim(c(10,0)) +
                    scale_color_manual(values=phylum_colors) +
                    labs(y= "Contamination", x = "Completeness") +
                    theme_classic() +
                    theme(legend.position = "none")

#Generate contamination boxplot
genome_contamination <- ehi_mags %>%
            ggplot(aes(y=contamination)) +
                    ylim(c(10,0)) +
                    geom_boxplot(colour = "#999999", fill="#cccccc") +
                    theme_classic() +
                    theme(legend.position = "none",
                    axis.line = element_blank(),
                    axis.title = element_blank(),
                    axis.text=element_blank(),
                    axis.ticks=element_blank(),
                        plot.margin = unit(c(0, 0, 0.40, 0),"inches")) #add bottom-margin (top, right, bottom, left)

genome_completeness <- ehi_mags %>%
        ggplot(aes(x=completeness)) +
                xlim(c(70,100)) +
                geom_boxplot(colour = "#999999", fill="#cccccc") +
                theme_classic() +
                theme(legend.position = "none",
                    axis.line = element_blank(),
                    axis.title = element_blank(),
                    axis.text=element_blank(),
                    axis.ticks=element_blank(),
                    plot.margin = unit(c(0, 0, 0, 0.50),"inches")) #add left-margin (top, right, bottom, left)

#Render composite figure
#pdf("figures/completeness_contamination.pdf",width=10, height=5)
grid.arrange(grobs = list(genome_completeness,genome_biplot,genome_contamination),
        layout_matrix = rbind(c(1,1,1,1,1,1,1,1,1,1,1,4),
                              c(2,2,2,2,2,2,2,2,2,2,2,3),
                              c(2,2,2,2,2,2,2,2,2,2,2,3),
                              c(2,2,2,2,2,2,2,2,2,2,2,3),
                              c(2,2,2,2,2,2,2,2,2,2,2,3),
                              c(2,2,2,2,2,2,2,2,2,2,2,3),
                              c(2,2,2,2,2,2,2,2,2,2,2,3),
                              c(2,2,2,2,2,2,2,2,2,2,2,3),
                              c(2,2,2,2,2,2,2,2,2,2,2,3),
                              c(2,2,2,2,2,2,2,2,2,2,2,3),
                              c(2,2,2,2,2,2,2,2,2,2,2,3),
                              c(2,2,2,2,2,2,2,2,2,2,2,3)))
```

Filter by completeness and contamination
```{r filtering}
ehi_mags_filtered <- ehi_mags %>%
  filter(completeness > 90, contamination < 2.5)
```



### Host classes
```{r count number of species in more than 2 host classes}
species_hostclass_counts <- ehi_mags_filtered %>%
  filter(!is.na(species), species != "") %>% 
  filter(!is.na(host_class), host_class != "") %>% 
  group_by(species) %>%
  summarise(
    n_mags = n(),
    n_host_classes = n_distinct(host_class),
    n_host_species = n_distinct(host_species),
    host_classes = paste(sort(unique(host_class)), collapse = ", "),
    host_species = paste(sort(unique(host_species)), collapse = ", "),
    phylum = paste(unique(phylum), collapse = ", ")
  ) %>%
  arrange(desc(n_host_classes))


species_selection_3 <- species_hostclass_counts %>%
  filter(n_host_classes >= 3)

species_selection_2 <- species_hostclass_counts %>%
  filter(n_host_classes >= 2)

species_selection_3 %>% arrange(-n_mags)
species_selection_2 %>% arrange(-n_mags)
```
```{r check the phylums}
species_selection_2 %>% group_by(phylum)%>%
  summarize(n_species = n())

species_selection_3 %>% group_by(phylum)%>%
  summarize(n_species = n())
```
### Host classes- after filtering
```{r count number of species in more than 2 host classes after filtering}
species_selection_f <- species_selection_2 %>%
  dplyr::filter(n_mags > 10) %>%
  arrange(desc(n_mags))

species_selection_f


species_selection_list<- species_selection_f %>% pull(species)
```

```{r phylum after filtering}
species_selection_f %>% group_by(phylum)%>%
  summarize(n_species = n())
```

### Count host classes per species
```{r count host classes per species}
counts_species_per_class<- species_selection_f %>% 
  group_by(n_host_classes)%>%
  summarize(n_species = n())

ggplot(counts_species_per_class, aes(x = n_host_classes, y = n_species)) +
  geom_col() +
  geom_text(
    aes(label = n_species),
    vjust = -0.3,            
    size = 4
  ) +
  labs(
    title = "Number of Species per Number of Host Classes",
    x = "Number of Host Classes",
    y = "Number of Species"
  ) +
  theme_bw()

```
```{r add the count data to the ehi mags}
mags_with_counts <- ehi_mags_filtered %>%
  left_join(species_hostclass_counts, by = "species")


#filter for mags with >1 host class
mags_host2 <- mags_with_counts %>%
  dplyr::filter(n_host_classes >= 2)

n_mags <- mags_host2 %>% 
  group_by(species) %>%
  summarise(n_mags = n(), .groups = "drop")

```





We have several MAGs per species, so here we select the "best MAG" (highest completeness and lowest contamination), to have statistics based on the best of each.
```{r best mags per species}
best_mag_per_species <- mags_host2 %>%
  filter(species %in% species_selection_list) %>%
  group_by(species) %>%
  arrange(desc(completeness), contamination) %>%
  slice_head(n = 1) %>%
  ungroup() %>%
  transmute(
    species,
    best_mag_name = mag_name,
    best_MAG_link = link_to_assembly,
    best_genome_size = size,
    best_completeness = completeness,
    best_contamination = contamination,
    best_N50 = N50,
    best_host_classes = host_class,  
    best_assembly_type = assembly_type, 
    best_phylum =str_remove_all(phylum.x, "p__")) 
  
```


```{r check genome size}
ggplot(best_mag_per_species, aes(x= species, y = best_genome_size, fill = best_phylum))+
  scale_color_manual(values=phylum_colors) +
  scale_fill_manual(values=phylum_colors) +
  geom_col()+
  theme_bw()+
  theme(axis.text.x = element_text(angle = 90))
```



Filtering for Parabacteroides distasonis (make into a loop for all the relevant species later)
```{r pdist, eval = FALSE}
p_dist <- ehi_mags %>%
  filter(completeness >90,
         contamination < 2.5,
         species == "s__Parabacteroides distasonis")

write_tsv(p_dist, "data/mags_metadata/parabacteroides_distasonis_metadata.tsv")

p_dist_index <- p_dist %>%
  dplyr::select(ID, MAG_url)

write_tsv(p_dist_index, "data/mags_metadata/parabacteroides_distasonis_index.tsv")
```




```{r loop for all species, eval = FALSE}
species_selection_f <- c(
  "lactococcus_lactis",
  "hafnia_paralvei",
  "enterococcus_faecalis",
  "enterococcus_hirae",
  "bacteroides_uniformis",
  "phocaeicola_vulgatus",
  "parabacteroides_goldsteinii",
  "akkermansia_muciniphila",
  "bacteroides_fragilis",
  "providencia_rettgeri",
  "citrobacter_braakii"
)


ehi_mags_clean <- ehi_mags %>%
  mutate(
    species_clean = species %>% 
      str_replace("^s__", "") %>% 
      str_to_lower() %>% 
      str_replace_all(" ", "_")
  )


for (current_species in species_selection_f) {

  message("Processing ", current_species)

  species_data <- ehi_mags_clean %>%
    filter(
      completeness > 90,
      contamination < 2.5,
      species_clean == current_species
    )

  species_index <- species_data %>%
    dplyr::select(ID, MAG_url)

  filename <- current_species %>%
    str_replace("s__", "") %>%
    str_replace_all(" ", "_") %>%
    tolower()

  write_tsv(
    species_data,
    paste0("data/mags_metadata/", filename, "_metadata.tsv")
  )

  write_tsv(
    species_index,
    paste0("data/mags_metadata/", filename, "_index.tsv")
  )
}
```

```{r enterococcus hirae, eval = FALSE}
# Fix species name normalization (handles Enterococcus_B properly)
ehi_mags_clean <- ehi_mags %>%
  mutate(
    species_clean = species %>%
      str_remove("^s__") %>%
      str_to_lower() %>%
      str_replace_all("[^a-z0-9]+", "_") # replace spaces, punctuation, underscores
  )

# Show unique species so you can inspect normalization
unique(ehi_mags_clean$species_clean)

# Target species
target <- "enterococcus_b_hirae"

# Filter again using the improved cleaning
species_data <- ehi_mags_clean %>%
  filter(
    completeness > 90,
    contamination < 2.5,
    species_clean == target
  )

# Quick sanity check
print(nrow(species_data))
print(table(species_data$species_clean))

# Write EHI metadata for this species
write_tsv(species_data,
          "data/mags_metadata/enterococcus_hirae_metadata.tsv")


```



<!--chapter:end:02_EHI_MAGs_exploration.Rmd-->

# NCBI MAGs exploration

## NCBI MAGs metadata
```{r Gut microbiome keywords}
gut_keywords <- c("ceaca", "caeca", "excrement", "excrements", "rectal", "feces", 
                  "stool", "stools", "gut", "cloaca", "cloacal", "fecal", "intestines",
                  "intestine", "intestinal", "cecum", "ileum", "jejunum", "colon", "rectum", "rumen",
                  "anal", "anus", "manure", "faeces")

# Wrap each keyword in word boundaries: \bkeyword\b --otherwise artisanal passes the filter 
pattern <- paste0("\\b(", paste(gut_keywords, collapse = "|"), ")\\b")


# Filter the data
#gut_samples <- metadata_wide %>%
#  filter(str_detect(isolation_source, regex(pattern, ignore_case = TRUE)))
```


Download metadata for each taxa
```{bash, eval = FALSE}
# Trying to download ncbi metadata for mags

conda activate drakkar_env
conda install -c conda-forge ncbi-datasets-cli



## CITROBACTER BRAAKII
datasets summary genome taxon 57706 \
  --as-json-lines > genomes.jsonl


#filtering by contamination and completeness
jq -c '
select(
  .checkm_info.completeness >= 90 and
  .checkm_info.contamination <= 2.5
)
' genomes.jsonl > high_quality_genomes.jsonl



#put metadata in tsv
jq -r '
  .accession as $asm
  | .checkm_info.completeness as $comp
  | .checkm_info.contamination as $cont
  | .assembly_stats.total_sequence_length as $genome_size
  | .assembly_stats.gc_percent as $gc
  | .assembly_info.biosample.attributes[]?
  | [$asm, $comp, $cont, $genome_size, $gc, .name, .value]
  | @tsv
' high_quality_genomes.jsonl > citrobacter_biosample_attributes.tsv


```




### Citrobacter braakii
```{r citrobacter braakii, eval = FALSE}
c_braki_metadata <- read_tsv("data/mags_metadata/citrobacter_braakii_biosample_attributes.tsv",
  col_names = c(
    "accession",
    "completeness",
    "contamination",
    "genome_size",
    "gc_percent",
    "name",
    "value"
  )
)

wide <- c_braki_metadata %>%
  pivot_wider(
    id_cols = c(
      accession,
      completeness,
      contamination,
      genome_size,
      gc_percent
    ),
    names_from  = name,
    values_from = value
  )


source_counts <- wide %>%
  filter(!is.na(isolation_source)) %>%
  dplyr::count(isolation_source, sort = TRUE)

source_counts


host_counts <- wide %>%
  filter(!is.na(host)) %>%
  dplyr::count(host, sort = TRUE)

host_counts

wide %>%
  filter(host == "Homo sapiens")

citrobacter_gut <- wide %>%
  filter(str_detect(isolation_source, regex(pattern, ignore_case = TRUE)))

citrobacter_gut %>%tt()

## HUMAN
summary_counts <- citrobacter_gut %>%
  dplyr::summarize(
    total_rows = n(),
    human_samples = sum(
      host == "Homo sapiens" | 
      stringr::str_detect(isolation_source, stringr::regex("human", ignore_case = TRUE)), 
      na.rm = TRUE
    )
  )

print(summary_counts)

## OTHER HOSTS
other_hosts <- citrobacter_gut %>%
  dplyr::filter(host != "Homo sapiens" | is.na(host)) %>%
  dplyr::count(host, sort = TRUE)

print(other_hosts)
```


### Lactococcus lactis
```{bash, eval = FALSE}
## LACTOCOCCUS LACTIS
datasets summary genome taxon 1358 \
  --as-json-lines > lactococcus_genomes.jsonl


#filtering by contamination and completeness
jq -c '
select(
  .checkm_info.completeness >= 90 and
  .checkm_info.contamination <= 2.5
)
' lactococcus_genomes.jsonl > lactococcus_high_quality_genomes.jsonl



#put metadata in tsv
jq -r '
  .accession as $asm
  | .checkm_info.completeness as $comp
  | .checkm_info.contamination as $cont
  | .assembly_stats.total_sequence_length as $genome_size
  | .assembly_stats.gc_percent as $gc
  | .assembly_info.biosample.attributes[]?
  | [$asm, $comp, $cont, $genome_size, $gc, .name, .value]
  | @tsv
' lactococcus_high_quality_genomes.jsonl > lactococcus_biosample_attributes.tsv



```


```{r lactococcus, eval = FALSE}
lactococcus_metadata <- read_tsv("data/mags_metadata/lactococcus_lactis_biosample_attributes.tsv",  col_names = c("assembly", "attribute", "value"))


metadata_wide <- lactococcus_metadata %>%
  filter(attribute != "assembly") %>%  # assembly is in some attribute column, causing issues
  pivot_wider(
    id_cols = assembly,
    names_from = attribute,
    values_from = value,
    values_fn = list(value = ~ paste(.x, collapse = "; "))
  )


lactococcus_gut <- metadata_wide %>%
  filter(str_detect(isolation_source, regex(pattern, ignore_case = TRUE)))

## HUMAN
summary_counts <- lactococcus_gut %>%
  dplyr::summarize(
    total_rows = n(),
    human_samples = sum(
      host == "Homo sapiens" | 
      stringr::str_detect(isolation_source, stringr::regex("human", ignore_case = TRUE)), 
      na.rm = TRUE
    )
  )

print(summary_counts)

## OTHER HOSTS
other_hosts <- lactococcus_gut %>%
  dplyr::filter(host != "Homo sapiens" | is.na(host)) %>%
  dplyr::count(host, sort = TRUE)

print(other_hosts)
```


### Hafnia paralvei
```{bash, eval = FALSE}
## HAFNIA PARALVEI
datasets summary genome taxon 546367 \
  --as-json-lines > hafnia_genomes.jsonl


#filtering by contamination and completeness
jq -c '
select(
  .checkm_info.completeness >= 90 and
  .checkm_info.contamination <= 2.5
)
' hafnia_genomes.jsonl > hafnia_high_quality_genomes.jsonl



#put metadata in tsv
jq -r '
.accession as $asm |
.assembly_info.biosample.attributes[]? |
[$asm, .name, .value] | @tsv
' hafnia_high_quality_genomes.jsonl > hafnia_biosample_attributes.tsv


```


```{r hafnia, eval = FALSE}
hafnia_metadata <- read_tsv("data/ncbi/hafnia_paralvei_biosample_attributes.tsv",  col_names = c("assembly", "attribute", "value"))


metadata_wide <- hafnia_metadata %>%
  pivot_wider(
    id_cols = assembly,
    names_from = attribute,
    values_from = value,
    values_fn = function(x) x[1]
  )

hafnia_gut <- metadata_wide %>%
  filter(str_detect(isolation_source, regex(pattern, ignore_case = TRUE)))

## HUMAN
summary_counts <- hafnia_gut %>%
  dplyr::summarize(
    total_rows = n(),
    human_samples = sum(
      host == "Homo sapiens" | 
      stringr::str_detect(isolation_source, stringr::regex("human", ignore_case = TRUE)), 
      na.rm = TRUE
    )
  )

print(summary_counts)

## OTHER HOSTS
other_hosts <- hafnia_gut %>%
  dplyr::filter(host != "Homo sapiens" | is.na(host)) %>%
  dplyr::count(host, sort = TRUE)

print(other_hosts)
```


### Enterococcus faecalis
```{bash, eval = FALSE}
## ENTEROCOCCUS FAECALIS
datasets summary genome taxon 1351 \
  --as-json-lines > enterococcus_faecalis_genomes.jsonl


#filtering by contamination and completeness
jq -c '
select(
  .checkm_info.completeness >= 90 and
  .checkm_info.contamination <= 2.5
)
' enterococcus_faecalis_genomes.jsonl > enterococcus_faecalis_high_quality_genomes.jsonl



#put metadata in tsv
jq -r '
.accession as $asm |
.assembly_info.biosample.attributes[]? |
[$asm, .name, .value] | @tsv
' enterococcus_faecalis_high_quality_genomes.jsonl > enterococcus_faecalis_biosample_attributes.tsv


```


```{r enterococcus_faecalis, eval = FALSE}
enterococcus_faecalis_metadata <- read_tsv("data/ncbi/enterococcus_faecalis_biosample_attributes.tsv",  col_names = c("assembly", "attribute", "value"))


metadata_wide <- enterococcus_faecalis_metadata %>%
  pivot_wider(
    id_cols = assembly,
    names_from = attribute,
    values_from = value,
    values_fn = function(x) x[1]
  )


enterococcus_faecalis_gut <- metadata_wide %>%
  filter(str_detect(isolation_source, regex(pattern, ignore_case = TRUE)))

## HUMAN
summary_counts <- enterococcus_faecalis_gut %>%
  dplyr::summarize(
    total_rows = n(),
    human_samples = sum(
      host == "Homo sapiens" | 
      stringr::str_detect(isolation_source, stringr::regex("human", ignore_case = TRUE)), 
      na.rm = TRUE
    )
  )

print(summary_counts)

## OTHER HOSTS
other_hosts <- enterococcus_faecalis_gut %>%
  dplyr::filter(host != "Homo sapiens" | is.na(host)) %>%
  dplyr::count(host, sort = TRUE)

print(other_hosts)
```



### Enterococcus hirae
```{bash, eval = FALSE}
## ENTEROCOCCUS HIRAE
datasets summary genome taxon 1354 \
  --as-json-lines > enterococcus_genomes.jsonl


#filtering by contamination and completeness
jq -c '
select(
  .checkm_info.completeness >= 90 and
  .checkm_info.contamination <= 2.5
)
' enterococcus_genomes.jsonl > enterococcus_high_quality_genomes.jsonl



#put metadata in tsv
jq -r '
.accession as $asm |
.assembly_info.biosample.attributes[]? |
[$asm, .name, .value] | @tsv
' enterococcus_high_quality_genomes.jsonl > enterococcus_biosample_attributes.tsv


```


```{r enterococcus_hirae, eval = FALSE}
enterococcus_metadata <- read_tsv("data/ncbi/enterococcus_hirae_biosample_attributes.tsv",  col_names = c("assembly", "attribute", "value"))


metadata_wide <- enterococcus_metadata %>%
  pivot_wider(
    id_cols = assembly,
    names_from = attribute,
    values_from = value,
    values_fn = function(x) x[1]
  )


enterococcus_gut <- metadata_wide %>%
  filter(str_detect(isolation_source, regex(pattern, ignore_case = TRUE)))

## HUMAN
summary_counts <- enterococcus_gut %>%
  dplyr::summarize(
    total_rows = n(),
    human_samples = sum(
      host == "Homo sapiens" | 
      stringr::str_detect(isolation_source, stringr::regex("human", ignore_case = TRUE)), 
      na.rm = TRUE
    )
  )

print(summary_counts)

## OTHER HOSTS
other_hosts <- enterococcus_gut %>%
  dplyr::filter(host != "Homo sapiens" | is.na(host)) %>%
  dplyr::count(host, sort = TRUE)

print(other_hosts)
```


### Bacteroides uniformis
```{bash, eval = FALSE}
## BACTEROIDES UNIFORMIS
datasets summary genome taxon 820 \
  --as-json-lines > b_uniformis_genomes.jsonl


#filtering by contamination and completeness
jq -c '
select(
  .checkm_info.completeness >= 90 and
  .checkm_info.contamination <= 2.5
)
' b_uniformis_genomes.jsonl > b_uniformis_high_quality_genomes.jsonl



#put metadata in tsv
jq -r '
.accession as $asm |
.assembly_info.biosample.attributes[]? |
[$asm, .name, .value] | @tsv
' b_uniformis_high_quality_genomes.jsonl > b_uniformis_biosample_attributes.tsv


```


```{r bacteroides_uniformis, eval = FALSE}
b_uniformis_metadata <- read_tsv("data/ncbi/bacteroides_uniformis_biosample_attributes.tsv",  col_names = c("assembly", "attribute", "value"))


metadata_wide <- b_uniformis_metadata %>%
  filter(attribute != "assembly") %>%
  pivot_wider(
    id_cols = assembly,
    names_from = attribute,
    values_from = value,
    values_fn = function(x) x[1]
  )


b_uniformis_gut <- metadata_wide %>%
  filter(str_detect(isolation_source, regex(pattern, ignore_case = TRUE)))

## HUMAN
summary_counts <- b_uniformis_gut %>%
  dplyr::summarize(
    total_rows = n(),
    human_samples = sum(
      host == "Homo sapiens" | 
      stringr::str_detect(isolation_source, stringr::regex("human", ignore_case = TRUE)), 
      na.rm = TRUE
    )
  )

print(summary_counts)

## OTHER HOSTS
other_hosts <- b_uniformis_gut %>%
  dplyr::filter(host != "Homo sapiens" | is.na(host)) %>%
  dplyr::count(host, sort = TRUE)

print(other_hosts)
```



### Phocaeicola vulgatus
```{bash, eval = FALSE}
## PHOCAEICOLA VULGATUS
datasets summary genome taxon 821 \
  --as-json-lines > p_vulgatus_genomes.jsonl


#filtering by contamination and completeness
jq -c '
select(
  .checkm_info.completeness >= 90 and
  .checkm_info.contamination <= 2.5
)
' p_vulgatus_genomes.jsonl > p_vulgatus_high_quality_genomes.jsonl



#put metadata in tsv
jq -r '
.accession as $asm |
.assembly_info.biosample.attributes[]? |
[$asm, .name, .value] | @tsv
' p_vulgatus_high_quality_genomes.jsonl > p_vulgatus_biosample_attributes.tsv


```


```{r phocaeicola_vulgatus, eval = FALSE}
p_vulgatus_metadata <- read_tsv("data/ncbi/p_vulgatus_biosample_attributes.tsv",  col_names = c("assembly", "attribute", "value"))


metadata_wide <- p_vulgatus_metadata %>%
  filter(attribute != "assembly") %>%
  pivot_wider(
    id_cols = assembly,
    names_from = attribute,
    values_from = value,
    values_fn = function(x) x[1]
  )


p_vulgatus_gut <- metadata_wide %>%
  filter(str_detect(isolation_source, regex(pattern, ignore_case = TRUE)))

## HUMAN
summary_counts <- p_vulgatus_gut %>%
  dplyr::summarize(
    total_rows = n(),
    human_samples = sum(
      host == "Homo sapiens" | 
      stringr::str_detect(isolation_source, stringr::regex("human", ignore_case = TRUE)), 
      na.rm = TRUE
    )
  )

print(summary_counts)

## OTHER HOSTS
other_hosts <- p_vulgatus_gut %>%
  dplyr::filter(host != "Homo sapiens" | is.na(host)) %>%
  dplyr::count(host, sort = TRUE)

print(other_hosts)
```


### Parabacteroides goldsteinii
```{bash, eval = FALSE}
## PARABACTEROIDES GOLDSTEINII
datasets summary genome taxon 328812 \
  --as-json-lines > p_goldsteinii_genomes.jsonl


#filtering by contamination and completeness
jq -c '
select(
  .checkm_info.completeness >= 90 and
  .checkm_info.contamination <= 2.5
)
' p_goldsteinii_genomes.jsonl > p_goldsteinii_high_quality_genomes.jsonl



#put metadata in tsv
jq -r '
.accession as $asm |
.assembly_info.biosample.attributes[]? |
[$asm, .name, .value] | @tsv
' p_goldsteinii_high_quality_genomes.jsonl > p_goldsteinii_biosample_attributes.tsv


```


```{r parabacteroides_goldsteinii, eval = FALSE}
p_goldsteinii_metadata <- read_tsv("data/ncbi/parabacteroides_goldsteinii_biosample_attributes.tsv",  col_names = c("assembly", "attribute", "value"))


metadata_wide <- p_goldsteinii_metadata %>%
  filter(attribute != "assembly") %>%
  pivot_wider(
    id_cols = assembly,
    names_from = attribute,
    values_from = value,
    values_fn = function(x) x[1]
  )


p_goldsteinii_gut <- metadata_wide %>%
  filter(str_detect(isolation_source, regex(pattern, ignore_case = TRUE)))

## HUMAN
summary_counts <- p_goldsteinii_gut %>%
  dplyr::summarize(
    total_rows = n(),
    human_samples = sum(
      host == "Homo sapiens" | 
      stringr::str_detect(isolation_source, stringr::regex("human", ignore_case = TRUE)), 
      na.rm = TRUE
    )
  )

print(summary_counts)

## OTHER HOSTS
other_hosts <- p_goldsteinii_gut %>%
  dplyr::filter(host != "Homo sapiens" | is.na(host)) %>%
  dplyr::count(host, sort = TRUE)

print(other_hosts)
```
### Akkermansia municiphila
```{bash, eval = FALSE}
## AKKERMANSIA MUNICIPHILA
datasets summary genome taxon 239935 \
  --as-json-lines > akkermansia_genomes.jsonl


#filtering by contamination and completeness
jq -c '
select(
  .checkm_info.completeness >= 90 and
  .checkm_info.contamination <= 2.5
)
' akkermansia_genomes.jsonl > akkermansia_high_quality_genomes.jsonl



#put metadata in tsv
jq -r '
.accession as $asm |
.assembly_info.biosample.attributes[]? |
[$asm, .name, .value] | @tsv
' akkermansia_high_quality_genomes.jsonl > akkermansia_biosample_attributes.tsv


```


```{r akkermansia, eval = FALSE}
akkermansia_metadata <- read_tsv("data/ncbi/akkermansia_muciniphila_biosample_attributes.tsv",  col_names = c("assembly", "attribute", "value"))


metadata_wide <- akkermansia_metadata %>%
  filter(attribute != "assembly") %>%
  pivot_wider(
    id_cols = assembly,
    names_from = attribute,
    values_from = value,
    values_fn = function(x) x[1]
  )


akkermansia_gut <- metadata_wide %>%
  filter(str_detect(isolation_source, regex(pattern, ignore_case = TRUE)))

## HUMAN
summary_counts <- akkermansia_gut %>%
  dplyr::summarize(
    total_rows = n(),
    human_samples = sum(
      host == "Homo sapiens" | 
      stringr::str_detect(isolation_source, stringr::regex("human", ignore_case = TRUE)), 
      na.rm = TRUE
    )
  )

print(summary_counts)

## OTHER HOSTS
other_hosts <- akkermansia_gut %>%
  dplyr::filter(host != "Homo sapiens" | is.na(host)) %>%
  dplyr::count(host, sort = TRUE)

print(other_hosts)
```
### Bacteroides fragilis
```{bash, eval = FALSE}
## BACTEROIDES FRAGILIS
datasets summary genome taxon 817 \
  --as-json-lines > b_fragilis_genomes.jsonl


#filtering by contamination and completeness
jq -c '
select(
  .checkm_info.completeness >= 90 and
  .checkm_info.contamination <= 2.5
)
' b_fragilis_genomes.jsonl > b_fragilis_high_quality_genomes.jsonl



#put metadata in tsv
jq -r '
.accession as $asm |
.assembly_info.biosample.attributes[]? |
[$asm, .name, .value] | @tsv
' b_fragilis_high_quality_genomes.jsonl > b_fragilis_biosample_attributes.tsv


```


```{r bacteroides_fragilis, eval = FALSE}
b_fragilis_metadata <- read_tsv("data/ncbi/bacteroides_fragilis_biosample_attributes.tsv",  col_names = c("assembly", "attribute", "value"))


metadata_wide <- b_fragilis_metadata %>%
  filter(attribute != "assembly") %>%
  pivot_wider(
    id_cols = assembly,
    names_from = attribute,
    values_from = value,
    values_fn = function(x) x[1]
  )


b_fragilis_gut <- metadata_wide %>%
  filter(str_detect(isolation_source, regex(pattern, ignore_case = TRUE)))

## HUMAN
summary_counts <- b_fragilis_gut %>%
  dplyr::summarize(
    total_rows = n(),
    human_samples = sum(
      host == "Homo sapiens" | 
      stringr::str_detect(isolation_source, stringr::regex("human", ignore_case = TRUE)), 
      na.rm = TRUE
    )
  )

print(summary_counts)

## OTHER HOSTS
other_hosts <- b_fragilis_gut %>%
  dplyr::filter(host != "Homo sapiens" | is.na(host)) %>%
  dplyr::count(host, sort = TRUE)

print(other_hosts)
```


### Providencia rettgeri
```{bash, eval = FALSE}
## PROVIDENCIA RETTGERI
datasets summary genome taxon 587 \
  --as-json-lines > providencia_genomes.jsonl


#filtering by contamination and completeness
jq -c '
select(
  .checkm_info.completeness >= 90 and
  .checkm_info.contamination <= 2.5
)
' providencia_genomes.jsonl > providencia_high_quality_genomes.jsonl



#put metadata in tsv
jq -r '
.accession as $asm |
.assembly_info.biosample.attributes[]? |
[$asm, .name, .value] | @tsv
' providencia_high_quality_genomes.jsonl > providencia_biosample_attributes.tsv


```


```{r providencia rettgeri, eval = FALSE}
providencia_metadata <- read_tsv("data/ncbi/providencia_rettgeri_biosample_attributes.tsv",  col_names = c("assembly", "attribute", "value"))


metadata_wide <- providencia_metadata %>%
  filter(attribute != "assembly") %>%
  pivot_wider(
    id_cols = assembly,
    names_from = attribute,
    values_from = value,
    values_fn = function(x) x[1]
  )


providencia_gut <- metadata_wide %>%
  filter(str_detect(isolation_source, regex(pattern, ignore_case = TRUE)))

## HUMAN
summary_counts <- providencia_gut %>%
  dplyr::summarize(
    total_rows = n(),
    human_samples = sum(
      host == "Homo sapiens" | 
      stringr::str_detect(isolation_source, stringr::regex("human", ignore_case = TRUE)), 
      na.rm = TRUE
    )
  )

print(summary_counts)

## OTHER HOSTS
other_hosts <- providencia_gut %>%
  dplyr::filter(host != "Homo sapiens" | is.na(host)) %>%
  dplyr::count(host, sort = TRUE)

print(other_hosts)
```



```{r final selection, eval = FALSE}
species <- c(
  "lactococcus_lactis",
  "hafnia_paralvei",
  "enterococcus_faecalis",
  "enterococcus_hirae",
  "bacteroides_uniformis",
  "phocaeicola_vulgatus",
  "parabacteroides_goldsteinii",
  "akkermansia_muciniphila",
  "bacteroides_fragilis",
  "providencia_rettgeri",
  "citrobacter_braakii"
)

for (sp in species) {

  message("Processing ", sp)

  infile <- file.path(
    "data/mags_metadata",
    paste0(sp, "_biosample_attributes.tsv")
  )

  metadata_long <- read_tsv(
    infile,
    col_names = c(
      "accession",
      "completeness",
      "contamination",
      "genome_size",
      "gc_percent",
      "name",
      "value"
    ),
    show_col_types = FALSE
  )

  metadata_wide <- metadata_long %>%
    pivot_wider(
      id_cols = c(
        accession,
        completeness,
        contamination,
        genome_size,
        gc_percent
      ),
      names_from  = name,
      values_from = value,
      values_fn   = ~ dplyr::first(na.omit(.x)),
      names_repair = "unique"
    )

  ## filter gut-associated genomes
  if ("isolation_source" %in% colnames(metadata_wide)) {

    gut_metadata <- metadata_wide %>%
      filter(
        str_detect(
          isolation_source,
          regex(pattern, ignore_case = TRUE)
        )
      )

  } else {
    warning(sp, " has no isolation_source column")
    gut_metadata <- metadata_wide[0, ]
  }

  ## save ONLY the gut-filtered metadata
  saveRDS(
    gut_metadata,
    file.path(
      "data/mags_metadata",
      paste0(sp, "_ncbi_metadata.rds")
    )
  )

  selected_accessions <- gut_metadata %>%
    pull(accession) %>%
    unique()

  selected_accessions <- selected_accessions[!is.na(selected_accessions)]

  writeLines(
    selected_accessions,
    file.path(
      "data/mags_metadata",
      paste0(sp, "_ncbi_selected_accessions.txt")
    )
  )
}

```
## Downloading the MAGs after filtering

Download the MAGs when you finish selecting them
```{bash, eval = FALSE}
### DOWNLOAD THE MAGS

datasets download genome accession --inputfile ../bacteroides_unifmormis_ncbi_selected_accessions.txt --include genome --filename hafnia_paralvei_selected_genomes.zip

```


```{r checking if mags in gtdb are same as ncbi, eval = FALSE}
mags_gtdb <- read_tsv("data/mags_metadata/master_mag_index_lactococcus_lactis.tsv") %>% pull(ID)

intersect(selected, mags_gtdb)


```

```{r in ncbi but not gtdb, eval = FALSE}
# in selected but NOT in mags_gtdb
setdiff(selected, mags_gtdb)

```

```{r in gtdb not in ncbi, eval = FALSE}

# in mags_gtdb but NOT in selected
setdiff(mags_gtdb, selected)
```


<!--chapter:end:03_downloading_mags.Rmd-->


## Data preparation

### EHI MAGs
```{r load ehi mags first_human}
ehi_mags <- read_csv("data/ehi_mags.csv")
```
### Prepare color scheme

[AlberdiLab](www.alberdilab.dk) projects use unified color schemes developed for the [Earth Hologenome Initiative](www.earthhologenome.org), to facilitate figure interpretation.

```{r get_ehi_phylum_colors, warning=FALSE, comments="", message=FALSE, eval=FALSE}
ehi_mags_p <- ehi_mags %>%
  mutate(phylum=str_remove_all(phylum, "p__")) 

phylum_colors <- read_tsv("https://raw.githubusercontent.com/earthhologenome/EHI_taxonomy_colour/main/ehi_phylum_colors.tsv") %>%
    mutate(phylum=str_remove_all(phylum, "p__")) %>%
    right_join(ehi_mags_p, by=join_by(phylum == phylum)) %>%
    dplyr::select(phylum, colors) %>% 
    unique() %>%
    arrange(phylum) %>%
    pull(colors, name=phylum)

```


```{r colors}
source_colors <- c(EHI = "#8BC63F", GTDB = "#2D522D", NCBI= "#20558A")

host_type_colors <- c(human = "#A90D00" , animal = "darkgreen") 

host_order_colors <- c(
  "Accipitriformes" = "#143AC2",  # Aves
  "Carnivora"       = "#633C2C",  # Mammalia
  "Chiroptera"      = "#1B2021",  # Mammalia
  "Primates"        = "#CC0000",  # Mammalia
  "Rodentia"        = "#FDA991",  # Mammalia
  "Diptera"         = "#FFAE2B",  # Insecta
  "Isoptera"        = "#E27500",  # Insecta
  "Lepidoptera"     = "#C8591D",  # Insecta
  "Squamata"        = "#1D921B"   # Reptilia
)
```

### Sample metadata
```{r genome_metadata}
genome_metadata <- read_tsv("data/mags_metadata/lactococcus_lactis_FINAL_metadata.tsv")
```


```{r infer metadata from isolation source}
# Helper across the pipeline
is_blank <- function(x) is.na(x) | x == ""

# 1) Recreate host_text (as you had)
genome_metadata <- genome_metadata %>%
  mutate(
    host_text = str_to_lower(
      str_squish(
        paste(
          coalesce(host_species, ""),
          coalesce(host, ""),
          coalesce(isolation_source, ""),
          coalesce(env_broad, ""),
          coalesce(env_local_context, ""),
          sep = " ; "
        )
      )
    )
  )

# 2) Infer host_species ONLY when missing/empty — now with your new species
genome_metadata <- genome_metadata %>%
  mutate(
    host_species = dplyr::case_when(
      # keep explicit host_species if present
      !is_blank(host_species) ~ host_species,

      # Human
      str_detect(host_text, "homo sapiens|\\bhuman\\b|patient|adult|child|infant") ~ "Homo sapiens",

      # Mouse
      str_detect(host_text, "mus musculus|\\bmouse\\b|\\bmice\\b|murine") ~ "Mus musculus",

      # Rat
      str_detect(host_text, "rattus|\\brat\\b") ~ "Rattus norvegicus",

      # Pig / swine
      str_detect(host_text, "sus scrofa|porcine|\\bpig\\b|swine") ~ "Sus scrofa",

      # Cow / bovine
      str_detect(host_text, "bos taurus|bovine|\\bcow\\b|cattle") ~ "Bos taurus",

      # Dog / canine (normalize variants)
      str_detect(host_text, "canis lupus familiaris|canis familiaris|\\bdog\\b|canine") ~ "Canis lupus familiaris",

      # Chicken / poultry
      str_detect(host_text, "gallus gallus|\\bchicken\\b|poultry") ~ "Gallus gallus",

      # Silkworm
      str_detect(host_text, "bombyx mori|silkworm") ~ "Bombyx mori",

      # Drosophila / fruit fly
      str_detect(host_text, "drosophila|fruit fly") ~ "Drosophila melanogaster",

      # Termite
      str_detect(host_text, "\\btermite\\b") ~ "Termite",

      # Zebrafish
      str_detect(host_text, "danio rerio|zebrafish") ~ "Danio rerio",

      # Generic fish (also catch “fishbut”-style glued tokens)
      str_detect(host_text, "\\bfish\\w*\\b") ~ "Actinopterygii (fish)",

      # Bats and other taxa (from your counts)
      str_detect(host_text, "barbastella barbastellus") ~ "Barbastella barbastellus",
      str_detect(host_text, "glauconycteris\\s*sp\\.?") ~ "Glauconycteris sp",
      str_detect(host_text, "hipposideros ruber") ~ "Hipposideros ruber",
      str_detect(host_text, "rhinolophus capensis") ~ "Rhinolophus capensis",

      # Vulture
      str_detect(host_text, "cathartes aura") ~ "Cathartes aura",

      # Grasshopper
      str_detect(host_text, "\\bgrasshopper\\b") ~ "Grasshopper",

      # New primate + fish species from your list
      str_detect(host_text, "macaca fascicularis") ~ "Macaca fascicularis",
      str_detect(host_text, "oncorhynchus mykiss") ~ "Oncorhynchus mykiss",
      str_detect(host_text, "oreochromis niloticus") ~ "Oreochromis niloticus",

      TRUE ~ host_species
    )
  )

# 3) Normalize existing host_species text so class/order rules match reliably
genome_metadata <- genome_metadata %>%
  mutate(
    hs_lower = str_to_lower(host_species),
    host_species = dplyr::case_when(
      # canonicalize common variants
      str_detect(hs_lower, "^canis(\\s+lupus)?\\s+familiaris$") ~ "Canis lupus familiaris",
      str_detect(hs_lower, "^drosophila melanogaster$") ~ "Drosophila melanogaster",
      str_detect(hs_lower, "^bombyx mori$") ~ "Bombyx mori",
      str_detect(hs_lower, "^danio rerio$") ~ "Danio rerio",
      str_detect(hs_lower, "^homo sapiens$") ~ "Homo sapiens",

      # catch glued fish tokens (e.g., "fishbut", "fishsomething")
      str_detect(hs_lower, "^fish\\w*$") ~ "Actinopterygii (fish)",

      TRUE ~ host_species
    )
  ) %>%
  dplyr::select(-hs_lower)

# 4) Fill host_class / host_order ONLY when missing — extended with your species
genome_metadata <- genome_metadata %>%
  mutate(
    # CLASS
    host_class = dplyr::case_when(
      !is_blank(host_class) ~ host_class,

      str_detect(coalesce(host_species, ""), "Homo sapiens|Mus musculus|Rattus norvegicus|Sus scrofa|Bos taurus|Canis lupus familiaris|Barbastella barbastellus|Glauconycteris sp|Hipposideros ruber|Rhinolophus capensis|Macaca fascicularis") ~ "Mammalia",
      str_detect(coalesce(host_species, ""), "Gallus gallus|Cathartes aura") ~ "Aves",
      str_detect(coalesce(host_species, ""), "Drosophila melanogaster|Bombyx mori|Termite|Grasshopper") ~ "Insecta",
      str_detect(coalesce(host_species, ""), "Danio rerio|Oncorhynchus mykiss|Oreochromis niloticus|Actinopterygii") ~ "Actinopterygii",

      TRUE ~ host_class
    ),

    # ORDER
    host_order = dplyr::case_when(
      !is_blank(host_order) ~ host_order,

      # Mammals
      str_detect(coalesce(host_species, ""), "Homo sapiens|Macaca fascicularis") ~ "Primates",
      str_detect(coalesce(host_species, ""), "Mus musculus|Rattus norvegicus") ~ "Rodentia",
      str_detect(coalesce(host_species, ""), "Sus scrofa|Bos taurus") ~ "Artiodactyla",
      str_detect(coalesce(host_species, ""), "Canis lupus familiaris") ~ "Carnivora",
      str_detect(coalesce(host_species, ""), "Barbastella barbastellus|Glauconycteris sp|Hipposideros ruber|Rhinolophus capensis") ~ "Chiroptera",

      # Birds
      str_detect(coalesce(host_species, ""), "Gallus gallus") ~ "Galliformes",
      # Choose one scheme and be consistent; using Accipitriformes here
      str_detect(coalesce(host_species, ""), "Cathartes aura") ~ "Accipitriformes",

      # Insects
      str_detect(coalesce(host_species, ""), "Drosophila melanogaster") ~ "Diptera",
      str_detect(coalesce(host_species, ""), "Bombyx mori") ~ "Lepidoptera",
      str_detect(coalesce(host_species, ""), "Termite") ~ "Isoptera",
      str_detect(coalesce(host_species, ""), "Grasshopper") ~ "Orthoptera",

      # Fish (species-level)
      str_detect(coalesce(host_species, ""), "Danio rerio") ~ "Cypriniformes",
      str_detect(coalesce(host_species, ""), "Oncorhynchus mykiss") ~ "Salmoniformes",
      str_detect(coalesce(host_species, ""), "Oreochromis niloticus") ~ "Cichliformes",

      # Generic fish remains NA (unknown order)
      str_detect(coalesce(host_species, ""), "Actinopterygii \\(fish\\)") ~ NA_character_,

      TRUE ~ host_order
    )
  ) %>%
  # Drop helper column
  dplyr::select(-host_text)
```

```{r checking genome metadata}

genome_metadata %>%
  filter(is.na(host_class) | is.na(host_order) | host_class == "" | host_order == "") %>%
  dplyr::count(host_species, sort = TRUE)


genome_metadata %>%
  filter(host_species %in% c("Barbastella barbastellus", "Hipposideros ruber", "Glauconycteris sp",
                             "Cathartes aura", "Actinopterygii (fish)", "Grasshopper")) %>%
  dplyr::count(host_species, host_class, host_order, sort = TRUE)

```


```{r country_normalization}
library(countrycode)

# 1) Simplify country strings like "Country: Region"
genome_metadata <- genome_metadata %>%
  mutate(
    country_simple = str_trim(str_split_fixed(coalesce(country, ""), ":", 2)[, 1]),
    country_simple = na_if(country_simple, "")
  )

# 2) Normalization map for common ENA/NCBI variants
.country_map <- c(
  # US variants
  "usa" = "United States",
  "u\\.s\\." = "United States",
  "u\\.s\\.a\\." = "United States",
  "united states of america" = "United States",

  # UK variants
  "uk" = "United Kingdom",
  "u\\.k\\." = "United Kingdom",
  "great britain" = "United Kingdom",
  "england" = "United Kingdom",
  "scotland" = "United Kingdom",
  "wales" = "United Kingdom",
  "northern ireland" = "United Kingdom",

  # Korea variants
  "korea,? republic of" = "South Korea",
  "republic of korea"   = "South Korea",
  "south korea"         = "South Korea",
  "korea,? \\(south\\)" = "South Korea",

  # China variants
  "pr china" = "China",
  "p\\.r\\. china" = "China",

  # Russia variants
  "russian federation" = "Russia",

  # Czech variants
  "czech republic" = "Czechia",

  # Eswatini / Swaziland; Côte d’Ivoire; DRC
  "swaziland" = "Eswatini",
  "cote d['’]ivoire" = "Côte d’Ivoire",
  "democratic republic of the congo" = "DR Congo",

  # Others commonly seen in ENA
  "viet nam" = "Vietnam",
  "myanmar \\(burma\\)" = "Myanmar",
  "bolivia \\(plurinational state of\\)" = "Bolivia",
  "iran,? islamic republic of" = "Iran",
  "syrian arab republic" = "Syria",
  "moldova,? republic of" = "Moldova",
  "lao people'?s democratic republic" = "Laos",
  "macedonia,? the former yugoslav republic of" = "North Macedonia",
  "palestine,? state of" = "Palestine",
  "hong kong" = "Hong Kong",
  "macau|macao" = "Macau"
)

# 3) Apply normalization: lowercase → map → title‑case fallback
normalize_country <- function(x) {
  y <- str_trim(tolower(coalesce(x, "")))
  y[y == ""] <- NA_character_

  # Apply regex replacements from the map (left to right)
  for (pat in names(.country_map)) {
    repl <- .country_map[[pat]]
    y <- ifelse(!is.na(y), str_replace_all(y, paste0("^", pat, "$"), repl), y)
  }

  # General cleanups for accents/spacing variants
  y <- ifelse(!is.na(y), str_replace_all(y, "\\s+", " "), y)
  y <- ifelse(!is.na(y), str_replace_all(y, "^people's republic of china$", "China"), y)

  # If still lowercased plain words (no mapping hit), title‑case them
  # (won’t fix every case, but keeps things readable)
  y <- ifelse(!is.na(y), str_to_title(y), y)

  # Final tidy: replace common leftover patterns
  y <- ifelse(!is.na(y), str_replace_all(y, " And ", " and "), y)  # cosmetic
  y
}


genome_metadata <- genome_metadata %>%
  dplyr::mutate(
    country_normalized = normalize_country(country_simple),
    continent = countrycode::countrycode(
      sourcevar   = country_normalized,
      origin      = "country.name",
      destination = "continent",
      warn        = TRUE
    )
  )


```

```{r human or animal}
genome_metadata <- genome_metadata %>%
  # Normalize casing/whitespace for host_species
  mutate(
    host_species_norm = str_squish(host_species),
    host_species_norm = if_else(
      str_detect(str_to_lower(coalesce(host_species_norm, "")), "^homo\\s+sapiens$"),
      "Homo sapiens",
      # Title-case other species names to keep them tidy (optional)
      str_to_title(host_species_norm)
    )
  ) %>%
  # Human vs animal classification
  mutate(
    host_type = case_when(
      host_species_norm == "Homo sapiens" ~ "human",
      !is.na(host_species_norm) & host_species_norm != "" ~ "animal",
      TRUE ~ NA_character_
    )
  ) %>%
  # Keep your normalized species as the main column (optional)
  mutate(host_species = host_species_norm) %>%
  dplyr::select(-host_species_norm)
```



```{r load master index_human}
# Read master index
master_index <- read_tsv("data/mags_metadata/master_mag_index_lactococcus_lactis.tsv") %>%
  mutate(
    # Extract the actual genome identifier from out_path
    genome_identifier = case_when(
      # For EHI: extract EHA00531_bin.1 from the filename
      str_detect(out_path, "EHA") ~ str_extract(out_path, "EHA[0-9]+_bin\\.[0-9]+"),
      # For NCBI: use the ID as is (GCA/GCF number)
      TRUE ~ ID
    )
  )
```

```{r mapping the ids to the genome identifiers_human}
# Check the mapping
print("Master index mapping:")
master_index %>% 
  dplyr::select(ID, genome_identifier, out_path) %>%
  head(10) %>%
  print()

# Read contig-to-genome mapping
contig_to_genome <- read_tsv("data/mags_metadata/lactococcus_lactis_contig_to_mag.tsv",
                              col_names = c("contig", "genome_filename"))
```


### Genome annotations



```{r load genome annotations}
# Read annotations and add IDs
genome_annotations <- read_tsv("data/mags_metadata/lactococcus_lactis_gene_annotations.tsv.xz") %>%
  mutate(contig = sub("_[^_]*$", "", gene)) %>%
  left_join(contig_to_genome, by = "contig") %>%
  mutate(genome= genome_filename)%>%
   filter(!is.na(genome))
```

#### REMOVE MAGs that do NOT belong to the species!! (specific lactococcus, rest should be fine)
```{r remove_duplicates_and_not_species_mags}
# Cleaner to normalize identifiers
clean_label <- function(x) {
  x <- basename(x)
  sub("\\.(fna|fa|fasta)(\\.gz)?$", "", x, ignore.case = TRUE)
}

# List to remove (MAGs that belong to other species <95% ANI)
mags_to_remove <- c(
  "GCA_018369575.1.fna","GCA_947063445.1.fna","GCA_947101685.1.fna","GCA_948698275.1.fna",
  "GCA_937910935.1.fna","GCA_947072755.1.fna","GCA_948655095.1.fna","GCA_948703095.1.fna",
  "GCA_947041925.1.fna","GCA_947073355.1.fna","GCA_948675165.1.fna","GCA_948718815.1.fna"
)
mags_to_remove_clean <- clean_label(mags_to_remove)

# ---------- genome_metadata: remove + dedup (keep best per ID) ----------
stopifnot("ID" %in% names(genome_metadata))

gm0 <- genome_metadata %>%
  mutate(ID_clean = clean_label(ID))

n_before_meta <- nrow(gm0)
n_to_remove_meta <- sum(gm0$ID_clean %in% mags_to_remove_clean)

genome_metadata_filtered <- gm0 %>%
  filter(!ID_clean %in% mags_to_remove_clean)

has_comp    <- "completeness"   %in% names(genome_metadata_filtered)
has_cont    <- "contamination"  %in% names(genome_metadata_filtered)
has_contigs <- "contigs"        %in% names(genome_metadata_filtered)

if (has_comp || has_cont || has_contigs) {
  genome_metadata_dedup <- genome_metadata_filtered %>%
    mutate(
      completeness  = if (has_comp)    as.numeric(completeness)  else NA_real_,
      contamination = if (has_cont)    as.numeric(contamination) else NA_real_,
      contigs       = if (has_contigs) as.numeric(contigs)       else NA_real_
    ) %>%
    arrange(
      ID_clean,
      desc(if (has_comp) completeness else 0),
      (if (has_cont) contamination else 0),
      (if (has_contigs) contigs else Inf)
    ) %>%
    distinct(ID_clean, .keep_all = TRUE)
} else {
  genome_metadata_dedup <- genome_metadata_filtered %>%
    distinct(ID_clean, .keep_all = TRUE)
}

genome_metadata_dedup <- genome_metadata_dedup %>%
  select(-ID_clean)

# ---------- genome_annotations: ONLY filter (NO dedup) ----------
stopifnot("genome" %in% names(genome_annotations))

ga0 <- genome_annotations %>%
  mutate(genome_clean = clean_label(genome))

n_before_ann <- nrow(ga0)
n_to_remove_ann <- sum(ga0$genome_clean %in% mags_to_remove_clean)

# Remove problematic genomes; keep all remaining genes
genome_annotations_filtered <- ga0 %>%
  filter(!genome_clean %in% mags_to_remove_clean) %>%
  select(-genome_clean)

# ---------- report ----------
cat("genome_metadata:\n")
cat("  - rows before:", n_before_meta, "\n")
cat("  - removed by species list:", n_to_remove_meta, "\n")
cat("  - rows after remove:", nrow(genome_metadata_filtered), "\n")
cat("  - rows after dedup:", nrow(genome_metadata_dedup), "\n\n")

cat("genome_annotations:\n")
cat("  - rows before:", n_before_ann, "\n")
cat("  - removed by species list:", n_to_remove_ann, "\n")
cat("  - rows after remove:", nrow(genome_annotations_filtered), "\n")

# (optional) assign back
genome_metadata   <- genome_metadata_dedup
genome_annotations <- genome_annotations_filtered
```



### Distill annotations into GIFTs

```{r distill_annotations, warning=FALSE, comments="", message=FALSE}
genome_gifts <- distill(genome_annotations,GIFT_db,genomecol= 19, annotcol=c(5,6,7,8), verbosity = F)
```



### Load trees
```{r load trees_human}
genome_metadata$mag_name <- sub("\\.fa$", "", genome_metadata$mag_name)#remove .fa from the mag names so that they match the tree ids
```



# Data Statistics
Total number of MAGs
```{r count n MAGS}
genome_metadata %>%
  dplyr::count(source)

genome_metadata %>% dplyr::count(host_species)

genome_metadata %>% dplyr::count(host_order)

genome_metadata %>% dplyr::count(host_class)
```

### Remove the MAGs with no host metadata
```{r remove_mags}
genome_metadata <- genome_metadata %>%
  filter(!is.na(host_class))
```



### Mean completeness and contamination
```{r mean completeness and contamination}
genome_metadata %>% 
  summarise(
    mean_c = mean(completeness, na.rm = TRUE) %>% round(2),
    sd_c = sd(completeness, na.rm = TRUE) %>% round(2),
    mean_con = mean(contamination, na.rm = TRUE) %>% round(2),
    sd_con = sd(contamination, na.rm = TRUE) %>% round(2)
  ) %>%
  unite("Completeness", mean_c, sd_c, sep = " ± ") %>%
  unite("Contamination", mean_con, sd_con, sep = " ± ") %>%
  tt()
```


```{r genome_quality_plot, message=FALSE, warning=FALSE, fig.height=6, fig.width=10, fig.fullwidth=TRUE}

#Generate quality biplot
genome_biplot <- genome_metadata %>%
  dplyr::select(c(ID,completeness,contamination, host_order)) %>%
  ggplot(aes(x=completeness,y=contamination, color = host_order)) +
  scale_color_manual(values = host_order_colors, name = "Host Order")+
              geom_point(alpha=0.7, size = 4) +
                    xlim(c(90,100)) +
                    ylim(c(2.5,0)) +
                    labs(y= "Contamination", x = "Completeness") +
                    theme_classic() +
                    theme(legend.position = "left",
                          axis.text.y = element_text(size=12),
                          axis.text.x = element_text(size=12),
                          axis.title.x = element_text(size = 16, face = "bold"),
                          axis.title.y = element_text(size = 16, face = "bold"))

#Generate contamination boxplot
genome_contamination <- genome_metadata %>%
            ggplot(aes(y=contamination)) +
                    ylim(c(2.5,0)) +
                    geom_boxplot(colour = "#999999", fill="#cccccc") +
                    theme_classic() +
                    theme(legend.position = "none",
                    axis.line = element_blank(),
                    axis.title = element_blank(),
                    axis.text=element_blank(),
                    axis.ticks=element_blank(),
                        plot.margin = unit(c(0, 0, 0.40, 0),"inches")) #add bottom-margin (top, right, bottom, left)

#Generate completeness boxplot
genome_completeness <- genome_metadata %>%
        ggplot(aes(x=completeness)) +
                xlim(c(90,100)) +
                geom_boxplot(colour = "#999999", fill="#cccccc") +
                theme_classic() +
                theme(legend.position = "none",
                    axis.line = element_blank(),
                    axis.title = element_blank(),
                    axis.text=element_blank(),
                    axis.ticks=element_blank(),
                    plot.margin = unit(c(0, 0, 0, 0.50),"inches")) #add left-margin (top, right, bottom, left)

#Render composite figure
#pdf("figures/completeness_contamination.pdf",width=10, height=5)
grid.arrange(grobs = list(genome_completeness,genome_biplot,genome_contamination),
        layout_matrix = rbind(c(1,1,1,1,1,1,1,1,1,1,1,4),
                              c(2,2,2,2,2,2,2,2,2,2,2,3),
                              c(2,2,2,2,2,2,2,2,2,2,2,3),
                              c(2,2,2,2,2,2,2,2,2,2,2,3),
                              c(2,2,2,2,2,2,2,2,2,2,2,3),
                              c(2,2,2,2,2,2,2,2,2,2,2,3),
                              c(2,2,2,2,2,2,2,2,2,2,2,3),
                              c(2,2,2,2,2,2,2,2,2,2,2,3),
                              c(2,2,2,2,2,2,2,2,2,2,2,3),
                              c(2,2,2,2,2,2,2,2,2,2,2,3),
                              c(2,2,2,2,2,2,2,2,2,2,2,3),
                              c(2,2,2,2,2,2,2,2,2,2,2,3)))
#dev.off()
```



```{r genome size plot}
ggplot(genome_metadata, aes(x= ID, y = genome_size, fill = host_order))+
  scale_fill_manual(values = host_order_colors)+
  geom_col()+ 
  theme_classic()


ggplot(genome_metadata, aes(x= source, y = genome_size, fill = source))+
  scale_fill_manual(values = source_colors)+
  geom_violin()+ 
  geom_point()+
  theme_classic()+
  labs(y = "Genome Size", x = "Source")


genome_metadata %>%
  filter(!is.na(host_class)) %>% 
ggplot(aes(x= host_type, y = genome_size, fill = host_type))+
  scale_fill_manual(values = host_type_colors)+
  geom_violin()+ 
  geom_point()+
  theme_classic()+
  labs(y = "Genome Size", x = "Host Type")
```
```{r lowest_genome_size}
genome_metadata%>%
  filter(genome_size == min(genome_size))
```




```{r contamination and completeness plots}
ggplot(genome_metadata, aes(x= ID, y = contamination, fill = source))+
  scale_fill_manual(values = source_colors)+
  geom_col()+ 
  theme_classic()


ggplot(genome_metadata, aes(x= source, y = contamination, fill = source))+
  scale_fill_manual(values = source_colors)+
  geom_boxplot()+ 
  theme_classic()+
  labs(y = "Contamination", x = "Source")

ggplot(genome_metadata, aes(x= ID, y = completeness, fill = source))+
  scale_fill_manual(values = source_colors)+
  geom_col()+ 
  theme_classic()


ggplot(genome_metadata, aes(x= source, y = completeness, fill = source))+
  scale_fill_manual(values = source_colors)+
  geom_violin()+
 geom_point()+
  theme_classic()+
  labs(y = "Completeness", x = "Source")

ggplot(genome_metadata, aes(x= host_type, y = completeness, fill = host_type))+
  scale_fill_manual(values = host_type_colors)+
  geom_violin()+
 geom_point()+
  theme_classic()+
  labs(y = "Completeness", x = "Host Type")
```
```{r plot togetehr}
genome_metadata_long <- genome_metadata %>%
  filter(!is.na(host_class))%>%
  mutate(genome_size_mb = genome_size/10^6)%>%
  pivot_longer(
    cols = c(genome_size_mb, contamination, completeness),
    names_to = "metric",
    values_to = "value"
  ) %>%
  mutate(
    metric = factor(metric, 
                   levels = c("genome_size_mb","contamination" , "completeness"),
                   labels = c("Genome Size (Mb)", "Contamination (%)" , "Completeness (%)"))
  )

faceted_plot <- ggplot(genome_metadata_long, 
                       aes(x = source, y = value, fill = source)) +
  scale_fill_manual(values = source_colors) +
  geom_violin() +
  geom_point() +
  facet_wrap(~ metric, scales = "free_y", ncol = 2) +
  theme_classic() +
  theme(
    strip.background = element_rect(fill = "white", color = "black"),
    strip.text = element_text(face = "bold", size = 11)
  ) +
  labs(y = "Value", x = "Source", fill = "Source")

print(faceted_plot)
```
```{r plots with animal vs human}
faceted_plot <- ggplot(genome_metadata_long, 
                       aes(x = host_type, y = value, fill = host_type)) +
  scale_fill_manual(values = host_type_colors) +
  geom_violin() +
  geom_point() +
  facet_wrap(~ metric, scales = "free_y", ncol = 2) +
  theme_classic() +
  theme(
    strip.background = element_rect(fill = "white", color = "black"),
    strip.text = element_text(face = "bold", size = 11)
  ) +
  labs(y = "Value", x = "Source", fill = "Host Type")

print(faceted_plot)
```


```{r stats_comparing}
#Comparing animal vs human
wilcox.test(contamination ~ host_type, data=genome_metadata)  %>%
  tidy()

wilcox.test(completeness ~ host_type, data=genome_metadata)  %>%
  tidy()

wilcox.test(genome_size ~ host_type, data=genome_metadata)  %>%
  tidy()

#Comparing sources
kruskal.test(contamination ~ source, data=genome_metadata)  %>%
  tidy()

kruskal.test(completeness ~ source, data=genome_metadata)  %>%
  tidy()

kruskal.test(genome_size ~ source, data=genome_metadata)  %>%
  tidy()

```

```{r stats_mean}
# Combine the summaries
ehi_stats <- genome_metadata %>%
  filter(host_type == "animal") %>%
  mutate(genome_size_mb = genome_size/1000000) %>%
  summarise(
    m_gs = round(mean(genome_size_mb), 2),
    sd_gs = round(sd(genome_size_mb), 2), 
    m_cont = round(mean(contamination), 2),
    sd_cont = round(sd(contamination), 2),
    m_comp = round(mean(completeness), 2),
    sd_comp = round(sd(completeness), 2)
  ) %>%
  unite("Mean genome size",m_gs, sd_gs, sep = " ± ", remove = TRUE) %>%
  unite("Mean completeness",m_comp, sd_comp, sep = " ± ", remove = TRUE) %>%
  unite("Mean contamination",m_cont, sd_cont, sep = " ± ", remove = TRUE) %>%
  mutate(Host_type = "animal") %>%
  dplyr::select(Host_type, everything())

gtdb_stats <- genome_metadata %>%
  filter(host_type == "human") %>%
  filter(!is.na(genome_size)) %>%
  mutate(genome_size_mb = genome_size/1000000) %>%
  summarise(
    m_gs = round(mean(genome_size_mb), 2),
    sd_gs = round(sd(genome_size_mb), 2),
    m_cont = round(mean(contamination), 2),
    sd_cont = round(sd(contamination), 2),
    m_comp = round(mean(completeness), 2),
    sd_comp = round(sd(completeness), 2)
  ) %>%
   unite("Mean genome size",m_gs, sd_gs, sep = " ± ", remove = TRUE) %>%
  unite("Mean completeness",m_comp, sd_comp, sep = " ± ", remove = TRUE) %>%
  unite("Mean contamination",m_cont, sd_cont, sep = " ± ", remove = TRUE) %>%
  mutate(Host_type = "human") %>%
  dplyr::select(Host_type, everything())

# Combine into one table
summary_table <- bind_rows(ehi_stats, gtdb_stats)

summary_table
```


### Country
```{r map}
library(rnaturalearth)
library(rnaturalearthdata)
library(sf) 


world <- ne_countries(scale = "medium", returnclass = "sf")

mag_locations <- genome_metadata %>%
  filter(!is.na(country)) %>%
  left_join(
    world %>%
      dplyr::select(name, geometry) %>%
      st_centroid() %>%
      st_coordinates() %>%
      as_tibble() %>%
      bind_cols(world %>% dplyr::select(name)) ,
    by = c("country" = "name")
  )

mag_locations%>% dplyr::select(ID, host_type, country)

ggplot(world) +
  geom_sf(fill = "gray95", color = "gray80") +
  geom_point(
    data = mag_locations,
    aes(x = X, y = Y, color = host_type),
    size = 2.5,
    alpha = 0.5
  ) +
  scale_color_manual(values = host_type_colors) +
  theme_minimal() +
  labs(color = "Host Type")



```



```{r host class plot,  fig.width = 15, fig.height = 15}
plot_df <- genome_metadata %>%
  dplyr::filter(!is.na(host_species), !is.na(host_class))

species_plot <- ggplot(plot_df, aes(x = host_species, fill = source)) +
  geom_bar(position = "stack") +
  facet_wrap(~ host_class, scales = "free_x") +
  scale_fill_manual(values = source_colors, name = "Source") +
  theme_bw(base_size = 14) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.title.x = element_text(size = 16),
    axis.title.y = element_text(size = 16),
    strip.text = element_text(size = 14, face = "bold")
  ) +
  labs(
    x = "Host species",
    y = "Number of MAGs"
  )

species_plot
#ggsave("./plots/species_plot.png", species_plot, dpi = 300, units = "cm", width = 18, height = 10)

```


```{r country distribution plot, eval = FALSE}
plot_df <- genome_metadata %>%
  dplyr::filter(!is.na(country_normalized))%>%
  dplyr::filter(country_normalized != "none")

library(stringr)

dist_plot <- ggplot(plot_df, aes(x = country_normalized, fill = host_order)) +
  geom_bar(position = "stack") +
  facet_grid(
    ~ continent,
    scales = "free_x",
    space  = "free_x",
    labeller = labeller(
      continent = function(x) str_wrap(x, width = 10)
    )
  ) +
  scale_fill_manual(values = host_order_colors, name = "Host order") +
  theme_bw(base_size = 14) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.title.x = element_text(size = 16),
    axis.title.y = element_text(size = 16),
    strip.text = element_text(size = 12, face = "bold")
  ) +
  labs(
    x = "Country",
    y = "Number of MAGs"
  )

dist_plot
#ggsave("./plots/dist_plot.png", dist_plot, dpi = 300, units = "cm", width = 30, height = 12)


```



# Phylogenetic analysis

## dRep tree


```{r load drep files}
fastani_comparisons <- read_csv("data/mags_metadata/lactococcus_lactis_Ndb.csv")  #Secondary comparison results
```



```{r recreate drep tree}
genomes <- unique(c(fastani_comparisons$reference, fastani_comparisons$querry))

# Create empty matrix
ani_matrix <- matrix(0, nrow = length(genomes), ncol = length(genomes))
rownames(ani_matrix) <- genomes
colnames(ani_matrix) <- genomes

# Fill the matrix
for(i in 1:nrow(fastani_comparisons)) {
  ref <- fastani_comparisons$reference[i]
  qry <- fastani_comparisons$querry[i]
  ani_val <- fastani_comparisons$ani[i]
  
  ani_matrix[ref, qry] <- ani_val
  ani_matrix[qry, ref] <- ani_val  # Make symmetric
}

# Set diagonal to 100
diag(ani_matrix) <- 100

# Convert to distance matrix (for tree building)
dist_matrix <- as.dist(1 - ani_matrix)

# Build tree
hc <- hclust(dist_matrix, method = "average") #drep uses hierarchical clustering
tree <- as.phylo(hc)

ggtree(tree) + 
  geom_tiplab(size = 2) +
  theme_tree2()
```



```{r final drep tree}
fastani_path <- "data/mags_metadata/lactococcus_lactis_Ndb.csv"

metadata <- genome_metadata
id_col   <- "ID"   

# Drop any outliers or specific IDs (use IDs without file suffix)
drop_ids <- character(0)  

# Impute missing ANI pairs 
# "max_distance" (most conservative), "min_ani", or a fixed numeric between 0 and 1
impute_mode <- "max_distance"

# helper: strip file extensions so IDs match metadata
clean_label <- function(x) {
  x <- basename(x)
  sub("\\.(fna|fa|fasta)(\\.gz)?$", "", x, ignore.case = TRUE)
}

# Load & normalize fastani table
fastani_raw <- readr::read_csv(fastani_path, show_col_types = FALSE)

fastani <- fastani_raw %>%
  dplyr::rename(
    reference = dplyr::any_of(c("reference", "ref", "Reference")),
    query     = dplyr::any_of(c("query", "querry", "Qry", "Query")),
    ani       = dplyr::any_of(c("ani", "ANI", "ani_1", "ANI_1"))
  ) %>%
  dplyr::select(reference, query, ani) %>%
  dplyr::filter(!is.na(reference), !is.na(query), reference != query)

# Normalize ANI to [0,1] if needed
ani_max <- max(fastani$ani, na.rm = TRUE)
if (is.finite(ani_max) && ani_max > 1) {
  fastani <- fastani %>% dplyr::mutate(ani = ani / 100)
}

# Clean IDs to remove extensions
fastani <- fastani %>%
  dplyr::mutate(
    reference = clean_label(reference),
    query     = clean_label(query)
  ) %>%
  dplyr::filter(reference != query)

# Remove duplicate pairs (keep the max ANI per pair)
fastani <- fastani %>%
  dplyr::group_by(reference, query) %>%
  dplyr::summarise(ani = max(ani), .groups = "drop")

# Optionally drop genomes (IDs without suffix)
if (length(drop_ids) > 0) {
  fastani <- fastani %>%
    dplyr::filter(!reference %in% drop_ids, !query %in% drop_ids)
}

# Build a symmetric ANI matrix with diag = 1 (dedup-safe)
build_ani_matrix <- function(df) {
  genomes <- sort(unique(c(df$reference, df$query)))

  both <- dplyr::bind_rows(
    df %>% dplyr::transmute(reference, query, ani),
    df %>% dplyr::transmute(reference = query, query = reference, ani)
  ) %>%
    dplyr::distinct(reference, query, .keep_all = TRUE)

  ani_mat <- both %>%
    tidyr::complete(reference = genomes, query = genomes) %>%
    tidyr::pivot_wider(
      names_from  = query,
      values_from = ani,
      values_fn   = max  # <-- ensure no duplicate cells cause errors
    ) %>%
    tibble::column_to_rownames("reference") %>%
    as.matrix()

  diag(ani_mat) <- 1

  # Impute missing if any
  if (anyNA(ani_mat)) {
    if (impute_mode == "max_distance") {
      fill_val <- min(ani_mat, na.rm = TRUE)
    } else if (impute_mode == "min_ani") {
      fill_val <- min(ani_mat, na.rm = TRUE)
    } else if (is.numeric(impute_mode) && impute_mode >= 0 && impute_mode <= 1) {
      fill_val <- impute_mode
    } else {
      fill_val <- min(ani_mat, na.rm = TRUE)
    }
    ani_mat[is.na(ani_mat)] <- fill_val
  }

  ani_mat
}

ani_mat <- build_ani_matrix(fastani)

# Build the tree (UPGMA/average as in dRep)
build_tree_from_ani <- function(ani_mat, method = "average") {
  dist_mat <- 1 - ani_mat
  hc <- hclust(as.dist(dist_mat), method = method)
  ape::as.phylo(hc)
}

tree <- build_tree_from_ani(ani_mat)

# De-duplicate metadata by ID and clean ID if needed
metadata_dedup <- metadata %>%
  dplyr::mutate(!!id_col := clean_label(.data[[id_col]])) %>%  # safe if already clean
  dplyr::distinct(.data[[id_col]], .keep_all = TRUE)

# Add metadata to tips (tree labels are already clean IDs)
make_tip_df <- function(tree, metadata_dedup, id_col) {
  stopifnot(id_col %in% names(metadata_dedup))
  tibble::tibble(label = tree$tip.label) %>%
    dplyr::left_join(metadata_dedup, by = setNames(id_col, "label")) %>%
    dplyr::mutate(label_clean = label)  # keep a consistent column if you use it in labels
}

tip_df <- make_tip_df(tree, metadata_dedup, id_col = id_col)

# Helper for ANI axis labels (unchanged)
ani_axis <- function(p, tree, show_threshold = NULL) {
  df <- ggtree::fortify(tree)
  max_x <- max(df$x[df$isTip])
  p <- p +
    scale_x_continuous(
      labels = function(x) round(100 * (1 - (max_x - x)), 1)
    ) +
    coord_cartesian(xlim = c(0, max_x + 0.005)) +
    labs(x = "Average Nucleotide Identity (ANI, %)") +
    theme_tree2()
  if (!is.null(show_threshold)) {
    thr_delta <- 1 - (show_threshold / 100)
    p <- p + geom_vline(xintercept = max_x - thr_delta,
                        linetype = "dashed", color = "red", size = 0.8)
  }
  p
}

# - BASIC PLOT --
plot_tree_basic <- function(tree, tip_df, color_by = NULL, label_tips = TRUE,
                            point_size = 2.5, show_threshold = NULL) {
  # ensure completeness numeric for continuous gradients
  if ("completeness" %in% names(tip_df)) {
    tip_df <- tip_df %>% dplyr::mutate(completeness = as.numeric(completeness))
  }

  p <- ggtree(tree, size = 0.8)
  p <- p %<+% tip_df

  if (!is.null(color_by) && color_by %in% names(tip_df)) {
    p <- p + geom_tippoint(aes(color = !!rlang::sym(color_by)), size = point_size)

    # Palette/scale logic
    if (identical(color_by, "source") && exists("source_colors")) {
      p <- p + scale_color_manual(values = source_colors, name = "Source", drop = FALSE)
    } else if (identical(color_by, "host_order") && exists("host_order_colors")) {
      p <- p + scale_color_manual(values = host_order_colors, name = "Host order", drop = FALSE)
    } else if (is.numeric(tip_df[[color_by]])) {
      p <- p + scale_color_gradient(low = "white", high = "#08306B",
                                    name = paste0(color_by, " (%)"))
    }
  } else {
    p <- p + geom_tippoint(size = point_size)
  }

  if (label_tips) {
    lab_col <- if ("label_clean" %in% names(tip_df)) "label_clean" else "label"
    p <- p + geom_tiplab(size = 3, hjust = -0.1, aes(label = .data[[lab_col]]))
  }

  ani_axis(p, tree, show_threshold = show_threshold)
}

# - MULTI-AESTHETIC PLOT --
plot_tree_multi <- function(tree, tip_df,
                            color_by = NULL,
                            shape_by = NULL,
                            size_by  = NULL,
                            label_tips = TRUE,
                            show_threshold = NULL) {
  if ("completeness" %in% names(tip_df)) {
    tip_df <- tip_df %>% dplyr::mutate(completeness = as.numeric(completeness))
  }

  p <- ggtree(tree, size = 0.8)
  p <- p %<+% tip_df

  aes_map <- aes()
  if (!is.null(color_by) && color_by %in% names(tip_df)) aes_map <- modifyList(aes_map, aes(color = !!rlang::sym(color_by)))
  if (!is.null(shape_by) && shape_by %in% names(tip_df)) aes_map <- modifyList(aes_map, aes(shape = !!rlang::sym(shape_by)))
  if (!is.null(size_by)  && size_by  %in% names(tip_df)) aes_map <- modifyList(aes_map, aes(size  = !!rlang::sym(size_by)))

  p <- p + geom_tippoint(aes_map, stroke = 0.3)

  if (!is.null(color_by) && color_by %in% names(tip_df)) {
    if (identical(color_by, "source") && exists("source_colors")) {
      p <- p + scale_color_manual(values = source_colors, name = "Source", drop = FALSE)
    } else if (identical(color_by, "host_order") && exists("host_order_colors")) {
      p <- p + scale_color_manual(values = host_order_colors, name = "Host order", drop = FALSE)
    } else if (is.numeric(tip_df[[color_by]])) {
      p <- p + scale_color_gradient(low = "white", high = "#08306B",
                                    name = paste0(color_by, " (%)"))
    }
  }

  if (label_tips) {
    lab_col <- if ("label_clean" %in% names(tip_df)) "label_clean" else "label"
    p <- p + geom_tiplab(size = 3, hjust = -0.1, aes(label = .data[[lab_col]]))
  }

  ani_axis(p, tree, show_threshold = show_threshold)
}
```



```{r tree_plots, fig.height= 12, fig.width = 10}
p_source <- plot_tree_basic(tree, tip_df, color_by = "source", label_tips = TRUE,
                            show_threshold = 99.5)
p_source

p_host <- plot_tree_basic(tree, tip_df, color_by = "host_species",
                          label_tips = TRUE, show_threshold = 99.5)
p_host

p_host_order <- plot_tree_basic(tree, tip_df, color_by = "host_order",
                          label_tips = TRUE, show_threshold = 99.5)
p_host_order

p_continent <- plot_tree_basic(tree, tip_df, color_by = "continent",
                          label_tips = TRUE, show_threshold = 99.5)
p_continent

# Color tips by completeness (0–100; 100 = dark blue, 0 = white)
p_comp <- plot_tree_basic(tree, tip_df, color_by = "completeness",
                          label_tips = TRUE, show_threshold = 99.5)
p_comp


p_multi <- plot_tree_multi(
  tree, tip_df,
  color_by = "host_order",
  size_by  = "completeness",
  label_tips = TRUE,
  show_threshold = 99.5
)
p_multi



```


```{r saving figs, eval = FALSE}
ggsave("plots/tree_by_source.png", p_source, width = 10, height = 8, dpi = 300)
ggsave("plots/tree_by_host.png",   p_host,   width = 10, height = 8, dpi = 300)
ggsave("plots/tree_combo.png",     p_combo,  width = 12, height = 9, dpi = 300)
ggsave("plots/tree_full_heatmap.png", p_full, width = 12, height = 10, dpi = 300)
```


# Functional Analysis
## Functional overview
```{r genomes annotated}
n_genes <- genome_annotations %>%
  group_by(genome) %>%
  summarize(n_genes = n())

head(n_genes)
```


#### Predicted genes
```{r predicted_stats, message=FALSE, warning=FALSE}
pred_genes <- genome_annotations %>%
  nrow()

cat(pred_genes)
```

#### Number of annotated genes and percentages
```{r annotation_stats, message=FALSE, warning=FALSE}
#How many genes have at least 1 annotation
genome_annota <- genome_annotations %>%
  filter(if_any(c(kegg, pfam, cazy), ~ !is.na(.))) %>%
  nrow()

cat(genome_annota)

#Percentage of predicted genes with at least 1 annotation
genome_annota*100/pred_genes
```

#### Number of KEGG annotatated genes and percentages
```{r kegg_stats_gut, message=FALSE, warning=FALSE}
# KEGG annotation
kegg_annota <- genome_annotations %>%
  filter(!is.na(kegg)) %>%
  nrow()
cat(kegg_annota)

# KEGG annotation percentage
kegg_annota*100/genome_annota


# AMR annotation
amr_annota <- genome_annotations %>%
  filter(resistance_type == "AMR") %>%
  nrow()
cat(amr_annota)

# AMR annotation percentage
amr_annota*100/genome_annota


# VF annotation
vf_annota <- genome_annotations %>%
  filter(!is.na(vf)) %>%
  nrow()
cat(vf_annota)

# VF annotation percentage
vf_annota*100/genome_annota
```

```{r n genes per mag}
n_pred_genes <- genome_annotations %>%
  group_by(genome) %>%
  summarize(n_genes = n()) %>%
  left_join(
    genome_metadata %>% dplyr::select(ID, host_type),
    by = c("genome" = "ID")
  )

annotated_genes <- genome_annotations %>%
  filter(if_any(c(kegg, pfam, cazy), ~ !is.na(.))) %>%
  group_by(genome) %>%
  summarize(n_annotated_genes = n()) %>%
  left_join(
    genome_metadata %>% dplyr::select(ID, host_type),
    by = c("genome" = "ID")
  )
```

```{r plotting n genes}
ggplot(n_pred_genes, aes(x= host_type, y = n_genes, fill = host_type))+
  scale_fill_manual(values = host_type_colors)+
  geom_boxplot()+ 
  geom_point()+
  theme_classic()+
  labs(y = "Gene Number", x = "Host Type")

ggplot(annotated_genes, aes(x= host_type, y = n_annotated_genes, fill = host_type))+
  scale_fill_manual(values = host_type_colors)+
  geom_boxplot()+ 
  geom_point()+
  theme_classic()+
  labs(y = "Annotated Gene Number", x = "Host Type")

wilcox.test(n_genes ~ host_type, data=n_pred_genes)  %>%
  tidy()


wilcox.test(n_annotated_genes ~ host_type, data=annotated_genes)  %>%
  tidy()

```


## KEGG
### Nº of MAGs with KOs
```{r mag counts per kegg}
#Proportion of MAGs belonging to each group per KEGG
#I want to know for example 5% of MAGs from anials have this KEGG, but 40 % of MAGs from humans have it

# KEGG presence/absence
kegg_presence <- genome_annotations %>%
  filter(!is.na(kegg)) %>%
  dplyr::select(genome, kegg) %>%
  distinct() 

#Add the host_type info
kegg_with_host_type <- kegg_presence %>%
  left_join(
    genome_metadata %>% dplyr::select(ID, host_type),
    by = c("genome" = "ID")
  )

# Count how many MAGs in each KEGG
kegg_mag_counts <- kegg_with_host_type %>%
  group_by(host_type, kegg) %>%
  summarise(
    n_mags = n(),
    .groups = "drop"
  )

#Count total MAGs per host_type (except the outlier)
total_mags_per_host_type <- genome_metadata %>%
  group_by(host_type) %>%
  summarise(
    total_mags = n_distinct(ID),
    .groups = "drop"
  )

#Calculate proportions of MAGs from each host_type in each KEGG
kegg_mag_proportions <- kegg_mag_counts %>%
  left_join(total_mags_per_host_type, by = "host_type") %>%
  mutate(
    proportion = n_mags / total_mags,
    absent = total_mags - n_mags
  )

```

#### Plotting KEGG MAG proportions
```{r plotting kegg mag proportions}
kegg_mag_proportions %>%
  filter(n_mags >= 20)
```

#### Statistical testing of MAG proportions
```{r statistical testing mag proportions}
fisher_results <- kegg_mag_proportions %>%
  dplyr::select(kegg, host_type, n_mags, absent) %>%
  pivot_wider(
    names_from = host_type,
    values_from = c(n_mags, absent),
    values_fill = 0
  ) %>%
  rowwise() %>%
  mutate(
    p_value = fisher.test(
      matrix(
        c(n_mags_animal,  absent_animal,
          n_mags_human, absent_human),
        nrow = 2,
        byrow = TRUE
      )
    )$p.value
  ) %>%
  ungroup() %>%
  mutate(p_adj = p.adjust(p_value, method = "BH"))

fisher_results <- fisher_results %>%
  mutate(
    prop_animal  = n_mags_animal  / (n_mags_animal  + absent_animal),
    prop_human = n_mags_human / (n_mags_human + absent_human),
    diff_prop = prop_human - prop_animal
  )
```

```{r volcano for fisher results}
volcano_df <- fisher_results %>%
  # Keep rows with non-missing p_adj and diff_prop
  filter(!is.na(p_adj), !is.na(diff_prop)) %>%
  # Avoid Inf y-values if p_adj == 0 by flooring at 1e-300 (or your choice)
  mutate(
    p_adj_capped = pmax(p_adj, 1e-300),
    nl10 = -log10(p_adj_capped),
    sig = p_adj < 0.05
  )


to_label <- volcano_df %>%
  filter(sig) %>%
  arrange(desc(nl10)) %>%
  dplyr::slice(1:10)

ggplot(volcano_df, aes(x = diff_prop, y = nl10)) +
  geom_point(aes(color = sig), alpha = 0.8, size = 2) +
  geom_text_repel(
    data = to_label,
    aes(label = kegg),        # or `Name`
    max.overlaps = 20,
    size = 3,
    segment.color = "grey70"
  ) +
  scale_color_manual(values = c(`TRUE` = "#1f77b4", `FALSE` = "grey70"), name ="p_adj < 0.05") +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "grey50") +
  theme_minimal() +
  labs(
    x = "Effect size (diff_prop)",
    y = expression(-log[10](p[adj])),
    title = "Volcano plot: differential KEGG presence"
  )

```


```{r fisher and volcano}
# Ensure host_type has the intended order
genome_metadata <- genome_metadata %>%
  mutate(host_type = factor(host_type, levels = c("animal", "human")))

# 1) KEGG presence (unique genome–kegg)
kegg_presence <- genome_annotations %>%
  dplyr::select(genome, kegg) %>%
  distinct() %>%
  filter(!is.na(kegg))

# 2) Add host type
kegg_with_host <- kegg_presence %>%
  left_join(
    genome_metadata %>% dplyr::select(ID, host_type),
    by = c("genome" = "ID")
  )

# 3) Count present per (kegg, host_type)
kegg_counts <- kegg_with_host %>%
  group_by(kegg, host_type) %>%
  summarise(n_present = n_distinct(genome), .groups = "drop")

# 4) Totals per host_type
totals <- genome_metadata %>%
  group_by(host_type) %>%
  summarise(total_mags = n_distinct(ID), .groups = "drop")

# 5) Complete grid and compute absent correctly
kegg_counts_complete <- kegg_counts %>%
  tidyr::complete(kegg, host_type, fill = list(n_present = 0)) %>%
  left_join(totals, by = "host_type") %>%
  mutate(n_absent = total_mags - n_present)

# 6) Pivot to 2×2 format
wide <- kegg_counts_complete %>%
  dplyr::select(kegg, host_type, n_present, n_absent) %>%
  pivot_wider(
    id_cols = kegg,
    names_from = host_type,
    values_from = c(n_present, n_absent),
    values_fill = 0
  )

# Sanity: ensure expected columns exist (adjust names if your levels differ)
stopifnot(all(c("n_present_animal","n_absent_animal","n_present_human","n_absent_human") %in% names(wide)))

wide <- wide %>%
  mutate(
    n_animal = n_present_animal,
    a_animal = n_absent_animal,
    n_human  = n_present_human,
    a_human  = n_absent_human
  )

# 7) SAFE P-VALUE: robust computation avoiding FEXACT 40
safe_fisher_p <- function(n_animal, a_animal, n_human, a_human) {
    m <- matrix(c(n_animal, a_animal, n_human, a_human), nrow = 2, byrow = TRUE)

    # If any row or column sums to zero, Fisher is fine (returns 1) or undefined;
    # handle degenerate cases: if all zero or all present, return p=1
    if (any(rowSums(m) == 0) || any(colSums(m) == 0)) {
        return(1.0)
    }

    # 1) Try exact Fisher with large workspace
    p1 <- tryCatch(
        fisher.test(m, workspace = 2e8)$p.value,
        error = function(e) NA_real_
    )
    if (!is.na(p1)) return(p1)

    # 2) Fall back to simulated Fisher
    p2 <- tryCatch(
        fisher.test(m, simulate.p.value = TRUE, B = 1e6)$p.value,
        error = function(e) NA_real_
    )
    if (!is.na(p2)) return(p2)

    # 3) Last resort: chi-square with Yates correction
    p3 <- tryCatch(
        suppressWarnings(chisq.test(m, correct = TRUE)$p.value),
        error = function(e) NA_real_
    )
    if (!is.na(p3)) return(p3)

    # If everything fails, return NA
    return(NA_real_)
}

# 8) Compute stats rowwise with robust p-values
fisher_df <- wide %>%
  rowwise() %>%
  mutate(
    # p-value
    p_value = safe_fisher_p(n_animal, a_animal, n_human, a_human),

    # proportions and difference
    prop_animal = ifelse((n_animal + a_animal) > 0, n_animal / (n_animal + a_animal), NA_real_),
    prop_human  = ifelse((n_human  + a_human)  > 0, n_human  / (n_human  + a_human),  NA_real_),
    diff_prop   = prop_human - prop_animal,

    # Haldane–Anscombe for OR if any zero cell (effect size only)
    needs_ha    = (n_animal == 0L) | (a_animal == 0L) | (n_human == 0L) | (a_human == 0L),
    n_animal_ha = ifelse(needs_ha, n_animal + 0.5, n_animal),
    a_animal_ha = ifelse(needs_ha, a_animal + 0.5, a_animal),
    n_human_ha  = ifelse(needs_ha, n_human  + 0.5, n_human),
    a_human_ha  = ifelse(needs_ha, a_human  + 0.5, a_human),

    or      = (n_human_ha * a_animal_ha) / (a_human_ha * n_animal_ha),
    log2_or = log2(or),

    # Relative risk with light Laplace smoothing (fold-change of proportions)
    rr      = ((n_human + 0.5)  / (n_human + a_human + 1)) /
              ((n_animal + 0.5) / (n_animal + a_animal + 1)),
    log2_rr = log2(rr)
  ) %>%
  ungroup() %>%
  mutate(p_adj = p.adjust(p_value, method = "BH"))

# 9) Optional prevalence filter to stabilize estimates
fisher_df <- fisher_df %>%
  mutate(total_present = n_animal + n_human) %>%
  filter(
    total_present >= 5 |
      prop_animal >= 0.03 | prop_human >= 0.03
  )

# 10) Volcano (log2 OR)
volcano_df <- fisher_df %>%
  filter(!is.na(p_adj), !is.na(log2_or)) %>%
  mutate(
    p_adj_capped = pmax(p_adj, 1e-300),
    nl10 = -log10(p_adj_capped),
    sig = p_adj < 0.05
  )

to_label <- volcano_df %>%
  filter(sig) %>%
  arrange(desc(nl10)) %>%
  dplyr::slice(1:10)

ggplot(volcano_df, aes(x = log2_or, y = nl10)) +
  geom_point(aes(color = sig), alpha = 0.8, size = 2) +
  geom_text_repel(
    data = to_label,
    aes(label = kegg),
    max.overlaps = 20,
    size = 3,
    segment.color = "grey70"
  ) +
  scale_color_manual(values = c(`TRUE` = "#1f77b4", `FALSE` = "grey70"), name = "FDR < 0.05") +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "grey50") +
  geom_vline(xintercept = c(-1, 1), linetype = "dotted", color = "grey60") + # OR ~0.5 and ~2
  theme_minimal() +
  labs(
    x = "Effect size (log2 odds ratio, human vs animal)",
    y = expression(-log[10](FDR)),
    title = "Volcano plot: differential KEGG presence (human vs animal)"
  )

# 11) Top 20 by significance then effect size
top20 <- fisher_df %>%
  arrange(p_adj, desc(abs(log2_or))) %>%
  dplyr::select(
    kegg,
    n_human, a_human, prop_human,
    n_animal, a_animal, prop_animal,
    diff_prop, log2_rr, log2_or, p_value, p_adj
  ) %>%
  dplyr::slice(1:20)

top20
```


```{r function to get info from KEGG}
library(KEGGREST)

# Function to get info from KEGG
get_kegg_info <- function(ko_id) {
  query <- keggGet(ko_id)[[1]]
  
  # Extract Name and Definition
  name <- ifelse(!is.null(query$NAME), query$NAME, "N/A")
  definition <- ifelse(!is.null(query$DEFINITION), query$DEFINITION, "N/A")
  
  # Extract Pathways (often multiple)
  pathways <- if(!is.null(query$PATHWAY)) {
    paste(names(query$PATHWAY), query$PATHWAY, sep = ": ", collapse = "; ")
  } else {
    "No pathway assigned"
  }
  
  return(c(KO = ko_id, Name = name, Definition = definition, Pathways = pathways))
}

```

```{r significant kos}
ko_list <- lapply(top20$kegg, get_kegg_info)
ko_summary <- as.data.frame(do.call(rbind, ko_list))

print(ko_summary)
```


```{r heatmap data}
fish_results_names <- left_join(top20, ko_summary, join_by(kegg== KO))


heatmap_data <- fish_results_names %>%
  dplyr::select(Name, prop_animal, prop_human)%>%
  pivot_longer(!Name, names_to = "host_type", values_to= "proportion" ) %>%
   mutate(
    host_type = case_when(
      host_type == "prop_animal"  ~ "animal",
      host_type == "prop_human" ~ "human",
      TRUE ~ host_type
    )
  )
```


```{r plot the keggs, fig.height = 10, fig.width= 14}
# 1) Reduce to one row per Name × host_type
heatmap_summary <- heatmap_data %>%
  group_by(Name, host_type) %>%
  summarise(
    proportion = mean(proportion, na.rm = TRUE),  # or median(), max(), first()
    .groups = "drop"
  )

# 2) Compute diff = animal - human in wide form
heatmap_wide <- heatmap_summary %>%
  filter(host_type %in% c("animal", "human")) %>%  # just in case there are other types
  tidyr::pivot_wider(
    names_from = host_type,
    values_from = proportion
  ) %>%
  mutate(
    diff = animal - human
  )

# 3) Reorder Name by diff and bring back to long for plotting
heatmap_plot <- heatmap_wide %>%
  mutate(Name = forcats::fct_reorder(Name, diff)) %>%
  tidyr::pivot_longer(
    cols = c(animal, human),
    names_to = "host_type",
    values_to = "proportion"
  )

# 4) Plot — heatmap
ggplot(heatmap_plot,
       aes(x = host_type, y = Name, fill = proportion)) +
  geom_tile() +
  geom_text(aes(label = scales::number(proportion, accuracy = 0.01)),
            size = 6) +
  scale_fill_viridis_c(
    name = "Proportion of MAGs",
    limits = c(0, 1)
  ) +
  theme_minimal() +
  labs(
    x = "host_type",
    y = "KEGG ortholog",
    title = "Differential KEGG presence between animal and human"
  )

```

```{r put it in a table}
table_data <- fish_results_names %>%
  transmute(
    `KEGG ortholog` = Name,
    `Proportion in animal`  = prop_animal,
    `Proportion in human` = prop_human,
    `Δ (human - animal)`  =  prop_human - prop_animal ,
    `Log2(Odds Ratio)`  =  log2_or ,
    `Fisher p-value`  = p_adj
  ) %>%
  arrange(desc(abs(`Δ (human - animal)`)))

table_data
```
```{r testing table format}
library(gt)

table_data %>%
  gt() %>%
  fmt_number(
    columns = c(`Proportion in animal`, `Proportion in human`, `Δ (human - animal)`, `Log2(Odds Ratio)` ),
    decimals = 2
  ) %>%
  fmt_scientific(
    columns = `Fisher p-value`,
    decimals = 2
  ) %>%
  tab_header(
    title = "KEGG orthologs differing between animal and human MAGs"
  ) %>%
  cols_align(
    align = "center",
    everything()
  )%>%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_column_labels(everything())
  )
```


### Functional Ordination

PCA of KEGG annotations:
```{r pca of kegg}
kegg_counts <- genome_annotations %>%
  filter(!is.na(kegg)) %>%          
  dplyr::count(genome, kegg) %>%           
  pivot_wider(
    names_from = kegg,
    values_from = n,
    values_fill = 0
  )

# Normalization
kegg_rel <- kegg_counts %>%
  column_to_rownames("genome")
kegg_rel <- kegg_rel / rowSums(kegg_rel)  # Each row sums to 1

# Remove zero variance
kegg_rel_nz <- kegg_rel[, apply(kegg_rel, 2, sd) > 0]

# PCA with scaling
pca <- prcomp(kegg_rel_nz, scale. = TRUE)

# Check variance explained
summary(pca)$importance[,1:5]
```
```{r country colors}
country_palette <- c(
  # Southern Europe
  "Spain" = "#1B9E77",
  "Italy" = "#33A02C",
  "Greece" = "#66C2A5",
  "Portugal" = "#2CA25F",
  "Malta" = "#99D8C9",

  # Northern/Central Europe
  "Germany" = "#1F78B4",
  "United Kingdom" = "#4A90E2",
  "Ireland" = "#6BAED6",

  # East Asia 
  "Japan" = "#E31A1C",
  "South Korea" = "#FB6A4A",
  "China" = "#CB181D",

  # North America 
  "USA" = "#756BB1",
  "Canada" = "#9E9AC8",

  # Distinct
  "Australia" = "#FFD92F",   
  "Greenland" = "#A6CEE3",

  "none" = "grey70"
)


```


```{r plot pca kegg}
scores <- as.data.frame(pca$x)
scores$ID <- rownames(scores)

scores <- scores %>%
  left_join(genome_metadata, by = "ID")

ggplot(scores, aes(PC1, PC2, color = host_type, label = ID)) +
  geom_point(size = 2) +
   scale_color_manual(values = host_type_colors)+
  theme_minimal() +
  labs(
    title = "PCA of KEGG annotations across MAGs",
    x = paste0("PC1 (", round(summary(pca)$importance[2,1] * 100, 1), "%)"),
    y = paste0("PC2 (", round(summary(pca)$importance[2,2] * 100, 1), "%)")
  ) + geom_text_repel()


##PCA again without outlier
kegg_counts <- genome_annotations %>%
  filter(genome != "EHM071389") %>%
  filter(!is.na(kegg)) %>%          
  dplyr::count(genome, kegg) %>%           
  pivot_wider(
    names_from = kegg,
    values_from = n,
    values_fill = 0
  )

# Normalization
kegg_rel <- kegg_counts %>%
  column_to_rownames("genome")
kegg_rel <- kegg_rel / rowSums(kegg_rel)  # Each row sums to 1

# Remove zero variance
kegg_rel_nz <- kegg_rel[, apply(kegg_rel, 2, sd) > 0]

# PCA with scaling
pca <- prcomp(kegg_rel_nz, scale. = TRUE)

# Check variance explained
summary(pca)$importance[,1:5]

scores_filtered <- scores %>% filter(ID != "EHM071389")

ggplot(scores_filtered, aes(PC1, PC2, color = host_type)) +
  geom_point(size = 2) +
   scale_color_manual(values = host_type_colors)+
  theme_minimal() +
  labs(
    title = "PCA of KEGG annotations across MAGs",
    x = paste0("PC1 (", round(summary(pca)$importance[2,1] * 100, 1), "%)"),
    y = paste0("PC2 (", round(summary(pca)$importance[2,2] * 100, 1), "%)")
  ) 

ggplot(scores_filtered, aes(PC2, PC3, color = host_type)) +
   scale_color_manual(values = host_type_colors)+
  geom_point(size = 2) +
  theme_minimal() +
  labs(
    title = "P2 vs PC3 of KEGG annotations across MAGs",
    x = paste0("PC2 (", round(summary(pca)$importance[2,2] * 100, 1), "%)"),
    y = paste0("PC3 (", round(summary(pca)$importance[2,3] * 100, 1), "%)")
  )

ggplot(scores_filtered, aes(PC3, PC4, color = host_type)) +
   scale_color_manual(values = host_type_colors)+
  geom_point(size = 2) +
  theme_minimal() +
  labs(
    title = "P3 vs PC4 of KEGG annotations across MAGs",
    x = paste0("PC3 (", round(summary(pca)$importance[2,3] * 100, 1), "%)"),
    y = paste0("PC4 (", round(summary(pca)$importance[2,4] * 100, 1), "%)")
  )


ggplot(scores_filtered, aes(PC1, PC2, color = genome_size)) +
  geom_point(size = 2) +
  theme_minimal() +
  labs(
    title = "KEGG PCA colored by genome size",
    x = paste0("PC1 (", round(summary(pca)$importance[2,1] * 100, 1), "%)"),
    y = paste0("PC2 (", round(summary(pca)$importance[2,2] * 100, 1), "%)")
  )

ggplot(scores_filtered, aes(PC1, PC2, color = completeness)) +
  geom_point(size = 2) +
  theme_minimal() +
  labs(
    title = "KEGG PCA colored by completeness",
    x = paste0("PC1 (", round(summary(pca)$importance[2,1] * 100, 1), "%)"),
    y = paste0("PC2 (", round(summary(pca)$importance[2,2] * 100, 1), "%)")
  )

ggplot(scores_filtered, aes(PC1, PC2, color = host_order)) +
  scale_color_manual(values = host_order_colors)+
  geom_point(size = 2) +
  theme_minimal() +
  labs(
    title = "KEGG PCA colored by host order ",
    x = paste0("PC1 (", round(summary(pca)$importance[2,1] * 100, 1), "%)"),
    y = paste0("PC2 (", round(summary(pca)$importance[2,2] * 100, 1), "%)")
  )

ggplot(scores_filtered, aes(PC1, PC2, color = country_normalized)) +
  geom_point(size = 2) +
  theme_minimal() +
  scale_color_manual(values = country_palette, na.value = "grey70")+
  labs(
    title = "KEGG PCA colored by country ",
    x = paste0("PC1 (", round(summary(pca)$importance[2,1] * 100, 1), "%)"),
    y = paste0("PC2 (", round(summary(pca)$importance[2,2] * 100, 1), "%)")
  )

ggplot(scores_filtered, aes(PC1, PC2, color = continent)) +
  geom_point(size = 2) +
  theme_minimal() +
  labs(
    title = "KEGG PCA colored by continent",
    x = paste0("PC1 (", round(summary(pca)$importance[2,1] * 100, 1), "%)"),
    y = paste0("PC2 (", round(summary(pca)$importance[2,2] * 100, 1), "%)")
  )
```
```{r loadings pca total}
loadings <- pca$rotation

abs_loadings <- apply(abs(loadings[, 1:2]), 1, sum)
top_combined <- sort(abs_loadings, decreasing = TRUE)[1:10]
top_combined


```
```{r pca loadings pc1}
library(KEGGREST)

top_loadings <- loadings %>%
  as.data.frame() %>%
  rownames_to_column("KEGG") %>%
  arrange(desc(abs(PC1))) 

head(top_loadings)

top_kos <- head(top_loadings)%>%pull(KEGG)

ko_pathways <- lapply(top_kos, function(k) {
  info <- keggGet(paste0("ko:", k))[[1]]
  pathways <- info$PATHWAY
  if(is.null(pathways)) pathways <- NA
  return(pathways)
})

names(ko_pathways) <- top_kos
ko_pathways
```


### Testing the differences in KEGG presence/absence with PERMANOVA
```{r kegg presence_absence anova}
kegg_counts_mat <- kegg_counts %>%
  column_to_rownames("genome")

kegg_pa <- (kegg_counts_mat > 0) * 1


# remove zero-variance KOs
kegg_pa_nz <- kegg_pa[, colSums(kegg_pa) > 0 & colSums(kegg_pa) < nrow(kegg_pa)]

# Determine the common genomes
common_ids <- base::intersect(rownames(kegg_pa_nz), genome_metadata$ID)

# Report what will be kept/dropped
message("# common: ", length(common_ids))
message("# in KEGG only: ", length(setdiff(rownames(kegg_pa_nz), genome_metadata$ID)))
message("# in metadata only: ", length(setdiff(genome_metadata$ID, rownames(kegg_pa_nz))))

# Subset to the intersection (and keep order identical)
kegg_pa_nz <- kegg_pa_nz[common_ids, , drop = FALSE]

meta <- genome_metadata %>%
  dplyr::filter(ID %in% common_ids) %>%
  dplyr::distinct(ID, .keep_all = TRUE) %>%
  tibble::column_to_rownames("ID") %>%
  .[common_ids, , drop = FALSE]

stopifnot(identical(rownames(meta), rownames(kegg_pa_nz)))

# Prepare variables for PERMANOVA
required_vars <- c("genome_size", "completeness", "host_type")

# Coerce types as needed
meta <- meta %>%
  dplyr::mutate(
    genome_size  = as.numeric(genome_size),
    completeness = as.numeric(completeness),
    host_type    = as.factor(host_type)
  )

# Align on complete cases (adonis2 drops NAs otherwise)
ok <- stats::complete.cases(meta[, required_vars, drop = FALSE])
kegg_pa_nz <- kegg_pa_nz[ok, , drop = FALSE]
meta       <- meta[ok, , drop = FALSE]
stopifnot(identical(rownames(meta), rownames(kegg_pa_nz)))

# Distance, dispersion, PERMANOVA
kegg_dist_pa <- vegan::vegdist(kegg_pa_nz, method = "jaccard", binary = TRUE)

disp_pa <- vegan::betadisper(kegg_dist_pa, meta$host_type)
anova(disp_pa)

vegan::adonis2(
  kegg_dist_pa ~ genome_size + completeness + host_type,
  data = meta,
  permutations = 999,
  by = "margin"
)

```


```{r pcoa on presence absence kegg}
pcoa_pa <- cmdscale(kegg_dist_pa, eig = TRUE, k = 2)

variance_explained <- pcoa_pa$eig / sum(pcoa_pa$eig)

pcoa_df <- data.frame(
  ID = rownames(kegg_pa_nz),
  PC1 = pcoa_pa$points[,1],
  PC2 = pcoa_pa$points[,2],
  host_type = meta$host_type
) %>% left_join(genome_metadata, by = "ID")

pcoa_kegg_pa <- ggplot(pcoa_df, aes(PC1, PC2, color = host_type.x)) +
  geom_point(size = 2) +
  scale_color_manual(values = host_type_colors, name = "Host type")+
  theme_minimal() +
  labs(
    title = "PCoA of KEGG presence/absence matrix across MAGs (colored by host type)",
    x = paste0("PC1 (",round(variance_explained[1] * 100, 1), "%)"),
    y = paste0("PC2 (", round(variance_explained[2] * 100, 1), "%)")
  )

pcoa_kegg_pa

pcoa_kegg_pa <- ggplot(pcoa_df, aes(PC1, PC2, color = host_order)) +
  geom_point(size = 2) +
  scale_color_manual(values = host_order_colors, name = "Host order")+
  theme_minimal() +
  labs(
    title = "PCoA of KEGG presence/absence matrix across MAGs (colored by host order)",
    x = paste0("PC1 (",round(variance_explained[1] * 100, 1), "%)"),
    y = paste0("PC2 (", round(variance_explained[2] * 100, 1), "%)")
  )

pcoa_kegg_pa

ggplot(pcoa_df, aes(PC1, PC2, color = completeness)) +
  geom_point(size = 2) +
  theme_minimal() +
  labs(
    title = "PCoA of KEGG presence/absence matrix across MAGs (colored by completeness)",
    x = paste0("PC1 (",round(variance_explained[1] * 100, 1), "%)"),
    y = paste0("PC2 (", round(variance_explained[2] * 100, 1), "%)")
  )

ggplot(pcoa_df, aes(PC1, PC2, color = continent)) +
  geom_point(size = 2) +
  theme_minimal() +
  labs(
    title = "PCoA of KEGG presence/absence matrix across MAGs (colored by continent)",
    x = paste0("PC1 (",round(variance_explained[1] * 100, 1), "%)"),
    y = paste0("PC2 (", round(variance_explained[2] * 100, 1), "%)")
  )

```




```{r pcoa with completeness}
library(patchwork)
p_main <- ggplot(pcoa_df, aes(PC1, PC2, color = host_type.x)) +
  scale_color_manual(values = host_type_colors) +
  geom_point(size = 2) +
  theme_minimal() +
  labs(
    title = "PCoA of KEGG annotations across MAGs",
    x = paste0("PC1 (", round(variance_explained[1] * 100, 1), "%)"),
    y = paste0("PC2 (", round(variance_explained[2] * 100, 1), "%)")
  ) +
  theme(
    legend.position = "right",
    axis.title.x = element_blank(),  
    axis.text.x = element_blank(),   
    axis.ticks.x = element_blank(),  
    plot.margin = margin(5, 5, 0, 5)
  )

cor_value <- cor(pcoa_df$PC1, pcoa_df$completeness, method = "spearman")
cor_pvalue <- cor.test(pcoa_df$PC1, pcoa_df$completeness, 
                       method = "spearman")$p.value

cor_text <- paste0("Spearman ρ = ", round(cor_value, 3), 
                  "\np < ", format.pval(cor_pvalue, digits = 2))

p_completeness_annotated <- ggplot(pcoa_df, aes(x = PC1, y = completeness, 
                                                 color = host_type.x)) +
  scale_color_manual(values = host_type_colors) +
  geom_point(alpha = 0.6, size = 2) +
  geom_smooth(method = "lm", se = TRUE, color = "black", linewidth = 1) +
  annotate("text", 
           x = min(pcoa_df$PC1) + 0.1 * diff(range(pcoa_df$PC1)), 
           y = max(pcoa_df$completeness) - 5,
           label = cor_text, 
           hjust = 0, 
           size = 3,  # Changed from 4 to 3 (smaller)
           fontface = "plain") +  # Changed from "bold" to "plain"
  theme_minimal() +
  labs(
    y = "Completeness (%)",
    x = paste0("PC1 (", round(variance_explained[1] * 100, 1), "%)")
  ) +
  theme(
    legend.position = "none",
    plot.margin = margin(0, 5, 5, 5),
    panel.border = element_rect(color = "black", fill = NA, linewidth = 0.5)  # Add border
  )


p_main <- p_main + 
  theme(panel.border = element_rect(color = "black", fill = NA, linewidth = 0.5))

combined_annotated <- p_main / p_completeness_annotated + 
  plot_layout(heights = c(3, 1), guides = "collect")

print(combined_annotated)


```



## GIFTs

### PCoA with Euclidean distances:
```{r pcoa_ordination, message=FALSE, fig.height=8, fig.width=10, fig.fullwidth=TRUE}
# Convert the GIFTs into a matrix of functional elements per genome (row)
gift_pcoa <- genome_gifts %>%
    to.elements(., GIFT_db) %>%
    as.data.frame() %>%
    vegdist(method="euclidean") %>%
    pcoa() #principal component analysis

#Extract eigenvalues (variance explained by first 10 axes)
gift_pcoa_rel_eigen <- gift_pcoa$values$Relative_eig[1:10]


# Get genome positions
gift_pcoa_vectors <- gift_pcoa$vectors %>% #extract vectors
  as.data.frame() %>% 
 dplyr::select(Axis.1,Axis.2) # keep the first 2 axes


gift_pcoa_eigenvalues <- gift_pcoa$values$Eigenvalues[c(1,2)]


#For the black arrows: Functional group loadings
# covariance between each functional trait and pcoa axis scores
#scale with the eigenvectors
gift_pcoa_gifts <- cov(genome_gifts, scale(gift_pcoa_vectors)) %*%
  diag((gift_pcoa_eigenvalues/(nrow(genome_gifts)-1))^(-0.5)) %>%
  as.data.frame() %>% 
  dplyr::rename(Axis.1=1,Axis.2=2) %>% 
  rownames_to_column(var="label") %>% 
  #get function summary vectors
  mutate(func=substr(label,1,3)) %>% 
  group_by(func) %>% #grouping by function
  summarise(Axis.1=mean(Axis.1),
            Axis.2=mean(Axis.2)) %>% 
  dplyr::rename(label=func) %>% 
  filter(!label %in% c("S01","S02","S03"))


```


```{r pcoa_ordination_plot, message=FALSE, fig.height=8, fig.width=10, fig.fullwidth=TRUE}
set.seed(101)
scale <- 20 # scale for vector loadings (to make arrows visible)
gift_pcoa_vectors %>% 
  rownames_to_column(var="ID") %>% 
  left_join(genome_metadata, by="ID") %>%
  ggplot() +
      #genome positions
      scale_color_manual(values=host_type_colors)+
      geom_point(aes(x=Axis.1,y=Axis.2, color = host_type), 
                 alpha=0.9, shape=16) +
      scale_size_continuous(range = c(0.1,5)) +
      #loading positions
      geom_segment(data=gift_pcoa_gifts, 
                   aes(x=0, y=0, xend=Axis.1 * scale, yend=Axis.2 * scale),
                    arrow = arrow(length = unit(0.3, "cm"), 
                    type = "open", 
                    angle = 25),
                    linewidth = 0.5, 
                    color = "black") +
     #Primary and secondary scale adjustments
     scale_x_continuous(name = paste0("PCoA1 (",round(gift_pcoa_rel_eigen[1]*100, digits = 2), " %)"),
                      sec.axis = sec_axis(~ . / scale, name = "Loadings on PCoA1")
            ) +
     scale_y_continuous(name = paste0("PCoA2 (",round(gift_pcoa_rel_eigen[2]*100, digits = 2), " %)"),
                      sec.axis = sec_axis(~ . / scale, name = "Loadings on PCoA2")
            ) +
    geom_label_repel(data = gift_pcoa_gifts,
                     aes(label = label, x = Axis.1 * scale, y = Axis.2 * scale),
                     segment.color = 'transparent') +
    xlim(-0.8,1) + 
    ylim(-1,1.5) +
    theme_minimal() + 
  
  labs(
    x = paste0("PCoA1 (", round(gift_pcoa_rel_eigen[1]*100, 2), " %)"),
    y = paste0("PCoA2 (", round(gift_pcoa_rel_eigen[2]*100, 2), " %)")
  )


gift_pcoa_vectors %>% 
  rownames_to_column(var="ID") %>% 
  left_join(genome_metadata, by="ID") %>%
  ggplot() +
      #genome positions
      geom_point(aes(x=Axis.1,y=Axis.2, color = completeness), 
                 alpha=0.9, shape=16) +
      scale_size_continuous(range = c(0.1,5)) +
      #loading positions
      geom_segment(data=gift_pcoa_gifts, 
                   aes(x=0, y=0, xend=Axis.1 * scale, yend=Axis.2 * scale),
                    arrow = arrow(length = unit(0.3, "cm"), 
                    type = "open", 
                    angle = 25),
                    linewidth = 0.5, 
                    color = "black") +
     #Primary and secondary scale adjustments
     scale_x_continuous(name = paste0("PCoA1 (",round(gift_pcoa_rel_eigen[1]*100, digits = 2), " %)"),
                      sec.axis = sec_axis(~ . / scale, name = "Loadings on PCoA1")
            ) +
     scale_y_continuous(name = paste0("PCoA2 (",round(gift_pcoa_rel_eigen[2]*100, digits = 2), " %)"),
                      sec.axis = sec_axis(~ . / scale, name = "Loadings on PCoA2")
            ) +
    geom_label_repel(data = gift_pcoa_gifts,
                     aes(label = label, x = Axis.1 * scale, y = Axis.2 * scale),
                     segment.color = 'transparent') +
    xlim(-0.8,1) + 
    ylim(-1,1.5) +
    theme_minimal() + 
  
  labs(
    x = paste0("PCoA1 (", round(gift_pcoa_rel_eigen[1]*100, 2), " %)"),
    y = paste0("PCoA2 (", round(gift_pcoa_rel_eigen[2]*100, 2), " %)")
  )



gift_pcoa_vectors %>%
  rownames_to_column(var="ID") %>%
  left_join(genome_metadata, by="ID") %>%
  ggplot() +
      #genome positions
      geom_point(aes(x=Axis.1,y=Axis.2, color = continent),
                 alpha=0.9, shape=16) +
      scale_size_continuous(range = c(0.1,5)) +
      #loading positions
      geom_segment(data=gift_pcoa_gifts,
                   aes(x=0, y=0, xend=Axis.1 * scale, yend=Axis.2 * scale),
                    arrow = arrow(length = unit(0.3, "cm"),
                    type = "open",
                    angle = 25),
                    linewidth = 0.5,
                    color = "black") +
     #Primary and secondary scale adjustments
     scale_x_continuous(name = paste0("PCoA1 (",round(gift_pcoa_rel_eigen[1]*100, digits = 2), " %)"),
                      sec.axis = sec_axis(~ . / scale, name = "Loadings on PCoA1")
            ) +
     scale_y_continuous(name = paste0("PCoA2 (",round(gift_pcoa_rel_eigen[2]*100, digits = 2), " %)"),
                      sec.axis = sec_axis(~ . / scale, name = "Loadings on PCoA2")
            ) +
    geom_label_repel(data = gift_pcoa_gifts,
                     aes(label = label, x = Axis.1 * scale, y = Axis.2 * scale),
                     segment.color = 'transparent') +
    xlim(-0.8,1) +
    ylim(-1,1.5) +
    theme_minimal() +

  labs(
    x = paste0("PCoA1 (", round(gift_pcoa_rel_eigen[1]*100, 2), " %)"),
    y = paste0("PCoA2 (", round(gift_pcoa_rel_eigen[2]*100, 2), " %)")
  )


gift_pcoa_vectors %>% 
  rownames_to_column(var="ID") %>% 
  left_join(genome_metadata, by="ID") %>%
  ggplot() +
      #genome positions
      geom_point(aes(x=Axis.1,y=Axis.2, color = host_class), 
                 alpha=0.9, shape=16) +
      scale_size_continuous(range = c(0.1,5)) +
      #loading positions
      geom_segment(data=gift_pcoa_gifts, 
                   aes(x=0, y=0, xend=Axis.1 * scale, yend=Axis.2 * scale),
                    arrow = arrow(length = unit(0.3, "cm"), 
                    type = "open", 
                    angle = 25),
                    linewidth = 0.5, 
                    color = "black") +
     #Primary and secondary scale adjustments
     scale_x_continuous(name = paste0("PCoA1 (",round(gift_pcoa_rel_eigen[1]*100, digits = 2), " %)"),
                      sec.axis = sec_axis(~ . / scale, name = "Loadings on PCoA1")
            ) +
     scale_y_continuous(name = paste0("PCoA2 (",round(gift_pcoa_rel_eigen[2]*100, digits = 2), " %)"),
                      sec.axis = sec_axis(~ . / scale, name = "Loadings on PCoA2")
            ) +
    geom_label_repel(data = gift_pcoa_gifts,
                     aes(label = label, x = Axis.1 * scale, y = Axis.2 * scale),
                     segment.color = 'transparent') +
    xlim(-0.8,1) + 
    ylim(-1,1.5) +
    theme_minimal() + 
  
  labs(
    x = paste0("PCoA1 (", round(gift_pcoa_rel_eigen[1]*100, 2), " %)"),
    y = paste0("PCoA2 (", round(gift_pcoa_rel_eigen[2]*100, 2), " %)")
  )

gift_pcoa_vectors %>% 
  rownames_to_column(var="ID") %>% 
  left_join(genome_metadata, by="ID") %>%
  ggplot() +
      #genome positions
      geom_point(aes(x=Axis.1,y=Axis.2, color = host_order), 
                 alpha=0.9, shape=16) +
      scale_color_manual(values = host_order_colors)+
      scale_size_continuous(range = c(0.1,5)) +
      #loading positions
      geom_segment(data=gift_pcoa_gifts, 
                   aes(x=0, y=0, xend=Axis.1 * scale, yend=Axis.2 * scale),
                    arrow = arrow(length = unit(0.3, "cm"), 
                    type = "open", 
                    angle = 25),
                    linewidth = 0.5, 
                    color = "black") +
     #Primary and secondary scale adjustments
     scale_x_continuous(name = paste0("PCoA1 (",round(gift_pcoa_rel_eigen[1]*100, digits = 2), " %)"),
                      sec.axis = sec_axis(~ . / scale, name = "Loadings on PCoA1")
            ) +
     scale_y_continuous(name = paste0("PCoA2 (",round(gift_pcoa_rel_eigen[2]*100, digits = 2), " %)"),
                      sec.axis = sec_axis(~ . / scale, name = "Loadings on PCoA2")
            ) +
    geom_label_repel(data = gift_pcoa_gifts,
                     aes(label = label, x = Axis.1 * scale, y = Axis.2 * scale),
                     segment.color = 'transparent') +
    xlim(-0.8,1) + 
    ylim(-1,1.5) +
    theme_minimal() + 
  
  labs(
    x = paste0("PCoA1 (", round(gift_pcoa_rel_eigen[1]*100, 2), " %)"),
    y = paste0("PCoA2 (", round(gift_pcoa_rel_eigen[2]*100, 2), " %)")
  )

```



```{r pcoa for report}
centroids <- gift_pcoa_vectors %>%
  rownames_to_column(var = "ID") %>%
  left_join(genome_metadata, by = "ID") %>%
  group_by(host_type) %>%
  summarise(
    Axis.1 = mean(Axis.1, na.rm = TRUE),
    Axis.2 = mean(Axis.2, na.rm = TRUE),
    .groups = "drop"
  )

gift_pcoa_vectors %>% 
  rownames_to_column(var = "ID") %>% 
  left_join(genome_metadata, by = "ID") %>%
  ggplot(aes(x = Axis.1, y = Axis.2, color = host_type)) +
  geom_point(size = 3, alpha = 0.9) +
  scale_color_manual(values = host_type_colors) +

  labs(
    x = paste0("PCoA1 (", round(gift_pcoa_rel_eigen[1] * 100, 2), " %)"),
    y = paste0("PCoA2 (", round(gift_pcoa_rel_eigen[2] * 100, 2), " %)")
  ) +

  coord_cartesian(xlim = c(-0.6, 1), ylim = c(-1, 1)) +

  theme_minimal(base_size = 16) +
  theme(
    axis.title = element_text(size = 14, face = "bold"),
    axis.text  = element_text(size = 14),
    legend.title = element_text(size = 14),
    legend.text  = element_text(size = 14),
    panel.grid.minor = element_blank()
  )

```



Using k-means to cluster the groups and check which MAGs cluster together:
```{r checking the groups}
coords <- gift_pcoa_vectors %>%
  rownames_to_column("MAG") %>%
  as_tibble()

set.seed(123)
km <- kmeans(coords[, c("Axis.1", "Axis.2")], centers = 2, nstart = 25, iter.max = 100)

coords <- coords %>% mutate(cluster = factor(km$cluster))

```


```{r kmeans plot}
# centroids as a tibble for plotting
centroids <- as_tibble(km$centers) %>% mutate(cluster = factor(1:nrow(km$centers)))

ggplot(coords, aes(x = Axis.1, y = Axis.2, color = cluster)) +
  geom_point(size = 2, alpha = 0.8) +
  geom_point(data = centroids, aes(x = Axis.1, y = Axis.2, color = cluster),
             shape = 4, size = 5, stroke = 1.25) +   # X marks centroids
  theme_minimal() +
  labs(title = paste0("PCoA colored by kmeans (k=2)"),
       color = "cluster")

```

```{r cluster mag lists}
mags_by_cluster <- split(coords$MAG, km$cluster)
mags_by_cluster
```

### Checking each cluster at once
```{r clusters}
cluster1_MAGs <- mags_by_cluster[[1]]
genome_metadata %>% filter(ID %in% cluster1_MAGs)

cluster2_MAGs <- mags_by_cluster[[2]]
genome_metadata %>% filter(ID %in% cluster2_MAGs)

```


```{r clean out the RS and GB}
genome_metadata <- genome_metadata %>%
  dplyr::mutate(
    ID_clean = ID %>%
      basename() %>%
      # remove file extensions
      sub("\\.(fna|fa|fasta)(\\.gz)?$", "", ., ignore.case = TRUE) %>%
      # remove GB_ or RS_ at the beginning
      sub("^(GB_|RS_)", "", ., ignore.case = TRUE) %>%
      # extract the real GCA/GCF accession (robust)
      sub(".*\\b(GC[AF]_[0-9]+\\.[0-9]+).*", "\\1", ., perl = TRUE)
  )
```



```{r combined table}
metadata_with_cluster <- genome_metadata %>%
  left_join(coords %>% dplyr::select(MAG, cluster), by = c("ID_clean" = "MAG"))

metadata_with_cluster %>%
  group_by(cluster, host_type) %>%
  summarise(n = n(), .groups = "drop") %>%
  arrange(cluster, desc(n))

# Group summaries
metadata_with_cluster %>%
  group_by(cluster) %>%
  summarise(mean_genome_size = mean(genome_size, na.rm = TRUE),
            median_contamination = median(contamination, na.rm = TRUE),
            .groups = "drop")

```

```{r save the cluster info into rdata}
# save(ehi_mags,
#      phylum_colors,
#      genome_annotations,
#      genome_gifts,
#      contig_to_genome,
#      gtdb_metadata,
#      ehi_metadata,
#      master_index,
#      genome_metadata,
#      host_type_colors,
#      getphylo_tree,
#      metadata_with_cluster,
#      file = "data/data.Rdata")
```




Is the genome size different between clusters?
```{r testing genome size differences}
kruskal.test(genome_size ~ cluster, data = metadata_with_cluster)


pairwise.wilcox.test(
  x = metadata_with_cluster$genome_size,
  g = metadata_with_cluster$cluster,
  p.adjust.method = "BH"   # FDR correction
)
```




Plots
```{r summary plots}
ggplot(metadata_with_cluster, aes(x = genome_size, y = GC, col = cluster))+
  geom_point()+
  theme_bw()

ggplot(metadata_with_cluster, aes(x = cluster, y = genome_size, col = cluster))+
  geom_point()+
  theme_bw()
```


```{r clustering proportion fisher}
count_table <- metadata_with_cluster %>%
  filter(!is.na(cluster))%>%
  dplyr::count(cluster, host_type) %>%
  pivot_wider(
    names_from = host_type,
    values_from = n,
    values_fill = 0
  )

count_table

mat <- metadata_with_cluster %>%
  filter(!is.na(cluster))%>%
  dplyr::count(cluster, host_type) %>%
  pivot_wider(names_from = host_type, values_from = n, values_fill = 0) %>%
  column_to_rownames("cluster") %>%
  as.matrix()

chisq.test(mat)$expected


fisher.test(mat)

```


```{r GIFT aggregations}
#Aggregate bundle-level GIFTs into the compound level
GIFTs_elements <- to.elements(genome_gifts,GIFT_db)

#Aggregate element-level GIFTs into the function level
GIFTs_functions <- to.functions(GIFTs_elements,GIFT_db)

#Aggregate function-level GIFTs into overall Biosynthesis, Degradation and Structural GIFTs
GIFTs_domains <- to.domains(GIFTs_functions,GIFT_db)

```

### GIFT community plots

```{r comumnity_elem_plot_gut, comment="", message=FALSE, warning=FALSE, fig.height=16, fig.width=14, fig.fullwidth=TRUE}
GIFTs_elements %>%
    as.data.frame() %>%
    rownames_to_column(var="MAG")%>%
    pivot_longer(!MAG,names_to="trait",values_to="gift") %>%
    left_join(metadata_with_cluster, by = join_by(MAG == ID)) %>%
    mutate(functionid = substr(trait, 1, 3)) %>%
    mutate(trait = case_when(
      trait %in% GIFT_db$Code_element ~ GIFT_db$Element[match(trait, GIFT_db$Code_element)],
      TRUE ~ trait
    )) %>%
    mutate(functionid = case_when(
      functionid %in% GIFT_db$Code_function ~ GIFT_db$Function[match(functionid, GIFT_db$Code_function)],
      TRUE ~ functionid
    )) %>%
    mutate(trait=factor(trait,levels=unique(GIFT_db$Element))) %>%
    mutate(functionid=factor(functionid,levels=unique(GIFT_db$Function))) %>%
    ggplot(aes(x=MAG,y=trait,fill=gift)) +
        geom_tile(colour="white", linewidth=0.2)+
        scale_fill_gradientn(colours=rev(c("#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#e6f598", "#abdda4", "#ddf1da")))+
        facet_grid(functionid ~ cluster, scales="free",space="free") +
        theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
              axis.text.y = element_text(size=6),
              strip.text.y = element_text(angle = 0)
              ) +
        labs(y="Traits",x="Samples",fill="GIFT")
```




```{r comumnity_elem_plot_host_type, comment="", message=FALSE, warning=FALSE, fig.height=16, fig.width=14, fig.fullwidth=TRUE}
p <- GIFTs_elements %>%
    as.data.frame() %>%
    rownames_to_column(var="MAG")%>%
    pivot_longer(!MAG,names_to="trait",values_to="gift") %>%
    left_join(metadata_with_cluster, by = join_by(MAG == ID)) %>%
    mutate(functionid = substr(trait, 1, 3)) %>%
    mutate(trait = case_when(
      trait %in% GIFT_db$Code_element ~ GIFT_db$Element[match(trait, GIFT_db$Code_element)],
      TRUE ~ trait
    )) %>%
    mutate(functionid = case_when(
      functionid %in% GIFT_db$Code_function ~ GIFT_db$Function[match(functionid, GIFT_db$Code_function)],
      TRUE ~ functionid
    )) %>%
    mutate(trait=factor(trait,levels=unique(GIFT_db$Element))) %>%
    mutate(functionid=factor(functionid,levels=unique(GIFT_db$Function))) %>%
    ggplot(aes(x=MAG,y=trait,fill=gift)) +
        geom_tile(colour="white", linewidth=0.2)+
        scale_fill_gradientn(colours=rev(c("#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#e6f598", "#abdda4", "#ddf1da")))+
        facet_grid(functionid ~ host_type, scales="free",space="free") +
        theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
              axis.text.y = element_text(size=6),
              strip.text.y = element_text(angle = 0)
              ) +
        labs(y="Traits",x="Samples",fill="GIFT")

p
```

```{r save plot, eval = FALSE}
ggplot2::ggsave(
  filename = "plots/GIFT_heatmap_final.png",
  plot = p,
  width = 14,
  height = 16,
  units = "in",
  dpi = 600,
  bg = "white"
)
```



```{r horizontal gift plot with antibiotic resistance genes}
library(RColorBrewer)
library(reshape2)

GIFTs_elements %>%
  melt() %>%
  dplyr::rename(Genome = Var1, Code_element = Var2, GIFT = value) %>%
  inner_join(GIFT_db, by = "Code_element") %>%
  filter(str_starts(Code_element, "D09")) %>%
  left_join(metadata_with_cluster, by = join_by(Genome == ID)) %>%
  mutate(cluster = factor(cluster)) %>%
  droplevels() %>%
  arrange(cluster, Genome) %>%
  mutate(trait = Element) %>%
  # Ensure trait is a factor to maintain order
  mutate(trait = factor(trait, levels = rev(unique(GIFT_db$Element)))) %>%
  ggplot( aes(x = Genome, y = trait)) +
  # Heatmap
  geom_tile(aes(fill = GIFT), color = "white") +
  scale_fill_gradientn(colours = brewer.pal(7, "YlGnBu"), name = "GIFT Score") +
  
  # Start a new fill scale for the host_type bar
  new_scale_fill() +
  
  # Add the host_type bar at the very top or bottom
  geom_tile(aes(y = -0.5, fill = host_type), height = 0.5) +
  scale_fill_manual(values = host_type_colors) +
  
  facet_grid(~ cluster, scales = "free_x", space = "free_x") +
  theme_minimal(base_size = 8) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
```



### Checking difference in GIFTs

#### Cluster-wise
Element GIFTs different between clusters of pcoa
```{r testing gifts between clusters, message = FALSE, warning = FALSE}
# Get only the GIFT columns
gift_cols <- colnames(GIFTs_elements)[!(colnames(GIFTs_elements) %in% c("genome","cluster","host_type"))]

gift_dataframe <- GIFTs_elements %>%
  as.data.frame() %>%            
  rownames_to_column(var = "ID") 

gift_df_meta <- gift_dataframe %>%
  left_join(metadata_with_cluster, by = "ID")


# Kruskal-Wallis for 4 groups
kruskal_results <- sapply(gift_cols, function(g) {
  kruskal.test(as.formula(paste(g, "~ cluster")), data = gift_df_meta)$p.value
})

# Adjust for multiple testing
kruskal_results_adj <- p.adjust(kruskal_results, method = "BH")

# Combine into a table
kruskal_table <- data.frame(
  GIFT = gift_cols,
  p_value = kruskal_results,
  p_adj = kruskal_results_adj
)

kruskal_table %>% filter(p_adj<0.05)
```


```{r testing gifts between clusters pairwise, message = FALSE, warning = FALSE}
pairwise_results <- lapply(gift_cols, function(g) {
  pairwise.wilcox.test(
    x = gift_df_meta[[g]],
    g = gift_df_meta$cluster,
    p.adjust.method = "BH"
  )
})

names(pairwise_results) <- gift_cols

pairwise_sig_table <- lapply(names(pairwise_results), function(g) {
  
  # Extract p-value matrix
  pmat <- pairwise_results[[g]]$p.value
  
  # Convert to long format
  pmat_long <- as.data.frame(as.table(pmat)) %>%
    filter(!is.na(Freq)) %>%       # remove NA (diagonal / upper triangle)
    dplyr::rename(group1 = Var1, group2 = Var2, p_adj = Freq) %>%
    filter(p_adj < 0.05) %>%      
    mutate(GIFT = g)
  
  return(pmat_long)
})



# Combine all GIFTs into one table
pairwise_sig_table <- bind_rows(pairwise_sig_table) %>%
  dplyr::select(GIFT, group1, group2, p_adj)

pairwise_sig_table 

```


```{r gifts different between cluster_1}
GIFTs_elements %>%
  melt() %>%
  dplyr::rename(Genome = Var1, Code_element = Var2, GIFT = value) %>%
  inner_join(GIFT_db, by = "Code_element") %>%
  filter(Code_element %in% pairwise_sig_table$GIFT) %>%
  left_join(metadata_with_cluster, by = join_by(Genome == ID)) %>%
  distinct(Genome, Code_element, .keep_all = TRUE) %>%
  mutate(cluster = factor(cluster)) %>%
  droplevels() %>%
  arrange(cluster, Genome) %>%
  mutate(trait = Element) %>%
  ggplot(aes(x = Genome, y = trait, fill = GIFT)) +
    geom_tile(colour = "white", linewidth = 0.2) +
    scale_y_discrete(guide = guide_axis(check.overlap = TRUE)) +
    scale_x_discrete(guide = guide_axis(check.overlap = TRUE)) +
    scale_fill_gradientn(limits = c(0,1), colours = RColorBrewer::brewer.pal(7, "YlGnBu")) +
  new_scale_fill() +
  
  # Add the host_type bar at the very top or bottom
  geom_tile(aes(y = -0.5, fill = host_type), height = 0.3) +
  scale_fill_manual(values = host_type_colors, name = "host_type") +
    facet_grid(~ cluster, scales = "free_x", space = "free_x") + 
    theme(
      axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, size = 4),
      strip.text.x = element_text(face = "bold")
    ) +
    labs(y = "Trait", x = "Genome", fill = "GIFT")
```

```{r checking code elements}
GIFT_db%>%
  filter(Code_element %in%  pairwise_sig_table$GIFT)
```


```{r pairwise wilcox cluster with effect size}
library(rstatix)
library(dplyr)
library(purrr)

pairwise_sig_table <- map_df(gift_cols, function(g) {
  
  # Check if there is variation in the GIFT values
  # If all values are the same, skip this GIFT
  if(length(unique(gift_df_meta[[g]])) < 2) return(NULL)
  
  # Run the test safely
  tryCatch({
    results <- gift_df_meta %>%
      wilcox_test(as.formula(paste0("`", g, "` ~ cluster")), p.adjust.method = "BH")
    
    eff <- gift_df_meta %>%
      wilcox_effsize(as.formula(paste0("`", g, "` ~ cluster")))
    
    results %>%
      left_join(eff, by = c("group1", "group2", ".y." = ".y.", "n1", "n2")) %>%
      filter(p.adj < 0.05) %>%
      mutate(GIFT = g)
  }, error = function(e) return(NULL)) # If it still fails, just skip it
})

top_gifts <- pairwise_sig_table %>%
  arrange(desc(effsize))


top_gifts
```


```{r gifts different between cluster}
GIFTs_elements %>%
  melt() %>%
  dplyr::rename(Genome = Var1, Code_element = Var2, GIFT = value) %>%
  inner_join(GIFT_db, by = "Code_element") %>%
  filter(Code_element %in% pairwise_sig_table$GIFT) %>%
  left_join(metadata_with_cluster, by = join_by(Genome == ID)) %>%
  distinct(Genome, Code_element, .keep_all = TRUE) %>%
  mutate(cluster = factor(cluster)) %>%
  droplevels() %>%
  arrange(cluster, Genome) %>%
  mutate(trait = Element) %>%
  ggplot(aes(x = Genome, y = trait, fill = GIFT)) +
    geom_tile(colour = "white", linewidth = 0.2) +
    scale_y_discrete(guide = guide_axis(check.overlap = TRUE)) +
    scale_x_discrete(guide = guide_axis(check.overlap = TRUE)) +
    scale_fill_gradientn(limits = c(0,1), colours = RColorBrewer::brewer.pal(7, "YlGnBu")) +
    facet_grid(~ cluster, scales = "free_x", space = "free_x") + 
    theme_grey(base_size = 8) +
    theme(
      axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),
      strip.text.x = element_text(face = "bold")
    ) +
    labs(y = "Trait", x = "Genome", fill = "GIFT")
```



#### host_type-wise
GIFTs that are different between EHI and GTDB
```{r testing gifts between host_types pairwise, message = FALSE, warning = FALSE}
wilcox_results <- sapply(gift_cols, function(g) {
  wilcox.test(as.formula(paste(g, "~ host_type")), data = gift_df_meta)$p.value
})

wilcox_results_adj <- p.adjust(wilcox_results, method = "BH")

data.frame(
  GIFT = gift_cols,
  p_value = wilcox_results,
  p_adj = wilcox_results_adj
)

effect_size <- sapply(gift_cols, function(g) {
  median(gift_df_meta[[g]][gift_df_meta$host_type=="human"]) -
    median(gift_df_meta[[g]][gift_df_meta$host_type=="animal"])
})

wilcox_res_host_type <- data.frame(
  GIFT = gift_cols,
  p_value = wilcox_results,
  p_adj = wilcox_results_adj,
  effect = effect_size
)


wilcox_res_host_type %>% dplyr::select(GIFT, p_adj, effect) %>% filter(p_adj<0.05)

```
```{r checking code element B0215}
GIFT_db%>%
  filter(Code_element %in% c("B0215", "B0701", "D0508") )
```
```{r adding effect size wilcox host_type}

wilcox_res_host_type <- map_df(gift_cols, function(g) {
  
 
  if(length(unique(gift_df_meta[[g]])) < 2) return(NULL)
  
  tryCatch({
    # Calculate p-value
    res <- gift_df_meta %>%
      wilcox_test(as.formula(paste0("`", g, "` ~ host_type")))
    
    # Calculate effect size (Rank-Biserial Correlation)
    eff <- gift_df_meta %>%
      wilcox_effsize(as.formula(paste0("`", g, "` ~ host_type")))
    
    # Combine results
    res %>%
      left_join(eff, by = c("group1", "group2", ".y." = ".y.", "n1", "n2")) %>%
      mutate(GIFT = g)
  }, error = function(e) return(NULL))
})

#  Adjust P-values and filter
wilcox_res_host_type <- wilcox_res_host_type %>%
  mutate(p_adj = p.adjust(p, method = "BH")) %>%
  dplyr::select(GIFT, group1, group2, p_adj, effsize, magnitude) %>%
  filter(p_adj < 0.05) %>%
  arrange(desc(abs(effsize))) # Sort by strongest effect

# View the top results
print(wilcox_res_host_type)
```

```{r gifts different between host_type plot, eval = FALSE}
host_class_colors <- c(
  "Mammalia"  = "#8B1E3F",  
  "Reptilia"  = "#3A7D44", 
  "Aves"      = "#E1B12C"   
)

GIFTs_elements %>%
  melt() %>%
  dplyr::rename(Genome = Var1, Code_element = Var2, GIFT = value) %>%
  inner_join(GIFT_db, by = "Code_element") %>%
  filter(Code_element %in% wilcox_res_host_type$GIFT) %>%
  left_join(metadata_with_cluster, by = join_by(Genome == ID)) %>%
  distinct(Genome, Code_element, .keep_all = TRUE) %>%
  mutate(cluster = factor(cluster)) %>%
  droplevels() %>%
  arrange(cluster, Genome) %>%
  mutate(trait = Element) %>%
  ggplot(aes(x = Genome, y = trait, fill = GIFT)) +
    geom_tile(colour = "white", linewidth = 0.2) +
    scale_y_discrete(guide = guide_axis(check.overlap = TRUE)) +
    scale_x_discrete(guide = guide_axis(check.overlap = TRUE)) +
    scale_fill_gradientn(limits = c(0,1), colours = RColorBrewer::brewer.pal(7, "YlGnBu")) +
  new_scale_fill() +
  
  # Add the host_type bar at the very top or bottom
  geom_tile(aes(y = -0.5, fill = host_class), height = 0.5) +
    facet_grid(~ host_type, scales = "free_x", space = "free_x") + 
  scale_fill_manual(values = host_class_colors, name = "Host class")
    theme(
      axis.text.x = element_blank()
    ) +
    labs(y = "Trait", x = "Genome", fill = "GIFT")
```
# Antibiotic resistance analysis

### Nº of MAGs with AMRs
```{r mag counts per AMR}
# AMR presence/absence
amr_presence <- genome_annotations %>%
  filter(resistance_type == "AMR") %>%
  dplyr::select(genome, resistance_target) %>%
  distinct() 

#Add the host_type info
amr_with_host_type <- amr_presence %>%
  left_join(
    genome_metadata %>% dplyr::select(ID, host_type),
    by = c("genome" = "ID")
  )

# Count how many MAGs in each AMR
amr_mag_counts <- amr_with_host_type %>%
  group_by(host_type, resistance_target) %>%
  summarise(
    n_mags = n(),
    .groups = "drop"
  )

#Count total MAGs per host_type 
total_mags_per_host_type <- genome_metadata %>%
  group_by(host_type) %>%
  summarise(
    total_mags = n_distinct(ID),
    .groups = "drop"
  )

#Calculate proportions of MAGs from each host_type in each AMR
amr_mag_proportions <- amr_mag_counts %>%
  left_join(total_mags_per_host_type, by = "host_type") %>%
  mutate(
    proportion = n_mags / total_mags,
    absent = total_mags - n_mags
  )

```

#### Statistical testing of MAG proportions
```{r statistical testing mag proportions amr}
fisher_results <- amr_mag_proportions %>%
  dplyr::select(resistance_target, host_type, n_mags, absent) %>%
  pivot_wider(
    names_from = host_type,
    values_from = c(n_mags, absent),
    values_fill = 0
  ) %>%
  rowwise() %>%
  mutate(
    p_value = fisher.test(
      matrix(
        c(n_mags_animal,  absent_animal,
          n_mags_human, absent_human),
        nrow = 2,
        byrow = TRUE
      )
    )$p.value
  ) %>%
  ungroup() %>%
  mutate(p_adj = p.adjust(p_value, method = "BH"))

fisher_results <- fisher_results %>%
  mutate(
    prop_animal  = n_mags_animal  / (n_mags_animal  + absent_animal),
    prop_human = n_mags_human / (n_mags_human + absent_human),
    diff_prop = prop_human - prop_animal
  )
```

```{r filtering padj amr}
fisher_results%>% filter(p_adj < 0.05) 
```


## Building an AMR abundance table

```{r amr table}
# select the AMR annotations
amr_abundance <- genome_annotations %>%
  filter(resistance_type == "AMR") %>%
  group_by(genome, resistance_target) %>%
  summarise(count = n(), .groups="drop") %>%
  tidyr::pivot_wider(
    names_from = resistance_target,
    values_from = count,
    values_fill = 0
  )

```

```{r join with metadata}
amr_cluster <- amr_abundance %>%
  dplyr::full_join(metadata_with_cluster, by= join_by(genome == ID))
```

```{r investigation macrolide and beta_lactam}
amr_cluster %>%
  dplyr::select("BETA-LACTAM", "MACROLIDE", genome, cluster) %>%
  group_by( cluster) %>%
  summarise(mean_beta_lactam = mean(`BETA-LACTAM`, na.rm = TRUE),
            mean_macrolide = mean(MACROLIDE, na.rm = TRUE))
```


```{r AMR abundance heatmap,  fig.height=14, fig.width=12, fig.fullwidth=TRUE}
amr_matrix <- amr_abundance %>%
  column_to_rownames("genome") %>%
  as.matrix()

# Abundance heatmap
min_val <- min(amr_matrix, na.rm = TRUE)
max_val <- max(amr_matrix, na.rm = TRUE)

colors <- viridis(100, option = "viridis")

breaks <- seq(min_val, max_val, length.out = 101)   

pheatmap( amr_matrix,
  color = colors,
  cluster_rows = FALSE,
  cluster_cols = TRUE,
  fontsize = 9,
  border_color = NA
)





```



```{r AMR presence heatmap_1,  fig.height=14, fig.width=12, fig.fullwidth=TRUE}
amr_presence <- amr_abundance %>%
  column_to_rownames("genome") %>%   
  mutate(across(everything(), ~ ifelse(. > 0, 1, 0)))%>%
  as.matrix()


pheatmap(
  amr_presence,
  cluster_rows = TRUE,
  cluster_cols = TRUE,
  color = c("white", "darkblue"),     # white = absent, black = present
  legend_breaks = c(0,1),
  legend_labels = c("Absent", "Present"),
  border_color = NA
)

```
```{r heatmap presence absence by ehi vs gtdb,  fig.height=14, fig.width=12, fig.fullwidth=TRUE}
pheatmap(
  amr_presence,
  cluster_rows = FALSE,
  cluster_cols = TRUE,
  color = c("white", "darkblue"),     # white = absent, black = present
  legend_breaks = c(0,1),
  legend_labels = c("Absent", "Present"),
  border_color = NA
)
```

## PERMANOVA presence/absence
```{r amr presence_absence permanova}
# Remove zero-variance AMR features
amr_pa_nz <- amr_presence[, colSums(amr_presence) > 0 & colSums(amr_presence) < nrow(amr_presence), drop = FALSE]

# Determine the common genomes/IDs between AMR matrix and metadata
common_ids <- base::intersect(rownames(amr_pa_nz), genome_metadata$ID)

# Report what will be kept/dropped
message("# common: ", length(common_ids))
message("# in AMR only: ", length(setdiff(rownames(amr_pa_nz), genome_metadata$ID)))
message("# in metadata only: ", length(setdiff(genome_metadata$ID, rownames(amr_pa_nz))))

# Subset AMR to the intersection (and keep the identical order)
amr_pa_nz <- amr_pa_nz[common_ids, , drop = FALSE]

# Build aligned metadata (unique IDs, same order as amr_pa_nz)
meta <- genome_metadata %>%
  dplyr::filter(ID %in% common_ids) %>%
  dplyr::distinct(ID, .keep_all = TRUE) %>%
  tibble::column_to_rownames("ID") %>%
  .[common_ids, , drop = FALSE]

stopifnot(identical(rownames(meta), rownames(amr_pa_nz)))

# Prepare variables for PERMANOVA
required_vars <- c("genome_size", "completeness", "host_type")

# Coerce types as needed
meta <- meta %>%
  dplyr::mutate(
    genome_size  = as.numeric(genome_size),
    completeness = as.numeric(completeness),
    host_type    = as.factor(host_type)
  )

# Align on complete cases for the required variables
ok <- stats::complete.cases(meta[, required_vars, drop = FALSE])
amr_pa_nz <- amr_pa_nz[ok, , drop = FALSE]
meta      <- meta[ok, , drop = FALSE]

stopifnot(identical(rownames(meta), rownames(amr_pa_nz)))

# Distance, dispersion, PERMANOVA
amr_dist_pa <- vegan::vegdist(amr_pa_nz, method = "jaccard", binary = TRUE)

disp_pa <- vegan::betadisper(amr_dist_pa, meta$host_type)
anova(disp_pa)

vegan::adonis2(
  amr_dist_pa ~ genome_size + completeness + host_type,
  data = meta,
  permutations = 999,
  by = "margin"
)


```

## PCoA presence/absence

```{r pcoa on presence absence amr}
pcoa_pa <- cmdscale(amr_dist_pa, eig = TRUE, k = 2)

variance_explained <- pcoa_pa$eig / sum(pcoa_pa$eig)


pcoa_df <- data.frame(
  ID = rownames(amr_pa_nz),
  PC1 = pcoa_pa$points[,1],
  PC2 = pcoa_pa$points[,2],
  host_type = meta$host_type
) %>%
  left_join(metadata_with_cluster, by = "ID")


pcoa_amr_pa <- ggplot(pcoa_df, aes(PC1, PC2, color = host_type.x)) +
  geom_point(size = 2) +
  scale_color_manual(values = host_type_colors, name = "host_type") +
  theme_minimal() +
  labs(
    title = "PCoA of AMR annotations across MAGs",
    x = paste0("PCoA1 (", round(variance_explained[1] * 100, 1), "%)"),
    y = paste0("PCoA2 (", round(variance_explained[2] * 100, 1), "%)")
  )

pcoa_amr_pa

ggplot(pcoa_df, aes(PC1, PC2, color = host_order)) +
  geom_point(size = 2) +
  scale_color_manual(values = host_order_colors, name = "Host Order")+
  theme_minimal() +
  labs(
    title = "PCoA of AMR annotations across MAGs (colored by host order)",
    x = paste0("PCoA1 (", round(variance_explained[1] * 100, 1), "%)"),
    y = paste0("PCoA2 (", round(variance_explained[2] * 100, 1), "%)")
  )

ggplot(pcoa_df, aes(PC1, PC2, color = completeness)) +
  geom_point(size = 2) +

  theme_minimal() +
  labs(
    title = "PCoA of AMR annotations across MAGs (colored by completeness)",
    x = paste0("PCoA1 (", round(variance_explained[1] * 100, 1), "%)"),
    y = paste0("PCoA2 (", round(variance_explained[2] * 100, 1), "%)")
  )

ggplot(pcoa_df, aes(PC1, PC2, color = genome_size)) +
  geom_point(size = 2) +

  theme_minimal() +
  labs(
    title = "PCoA of AMR annotations across MAGs (colored by genome_size)",
    x = paste0("PCoA1 (", round(variance_explained[1] * 100, 1), "%)"),
    y = paste0("PCoA2 (", round(variance_explained[2] * 100, 1), "%)")
  )

ggplot(pcoa_df, aes(PC1, PC2, color = country)) +
  geom_point(size = 2) +
  scale_color_manual(values = country_palette, na.value = "grey70")+
  theme_minimal() +
  labs(
    title = "PCoA of AMR annotations across MAGs (colored by country)",
    x = paste0("PCoA1 (", round(variance_explained[1] * 100, 1), "%)"),
    y = paste0("PCoA2 (", round(variance_explained[2] * 100, 1), "%)")
  )


ggplot(pcoa_df, aes(PC1, PC2, color = continent)) +
  geom_point(size = 2) +
  theme_minimal() +
  labs(
    title = "PCoA of AMR annotations across MAGs (colored by continent)",
    x = paste0("PCoA1 (", round(variance_explained[1] * 100, 1), "%)"),
    y = paste0("PCoA2 (", round(variance_explained[2] * 100, 1), "%)")
  )

ggplot(pcoa_df, aes(PC1, PC2, color = cluster)) +
  geom_point(size = 2) +
  theme_minimal() +
  labs(
    title = "PCoA of AMR annotations across MAGs (colored by functional cluster)",
    x = paste0("PCoA1 (", round(variance_explained[1] * 100, 1), "%)"),
    y = paste0("PCoA2 (", round(variance_explained[2] * 100, 1), "%)")
  )


```




## Testing proportions (Fisher)
```{r testing prevalence with fischer test}
amr_counts <- genome_annotations %>%
  filter(resistance_type == "AMR") %>%
  dplyr::count(genome, resistance_target) %>%            
  pivot_wider(names_from = resistance_target, values_from = n, values_fill = 0) %>%
  filter(rowSums(dplyr::select(., -genome)) > 0) # Removes MAGs with no AMR genes found


amr_binary <- amr_counts %>%
  left_join(genome_metadata %>% dplyr::select(ID, host_type), by = c("genome" = "ID")) %>%
  # Convert all numeric columns to 0 or 1
  mutate(across(where(is.numeric), ~ ifelse(.x > 0, 1, 0)))

#Function to run Fischer test for each gene
run_fisher <- function(gene_name, df) {
  tab <- table(df$host_type, df[[gene_name]])
  
  # Only run if the table is actually 2x2 
  if(ncol(tab) == 2) {
    test <- fisher.test(tab)
    return(tidy(test) %>% mutate(AMR_Target = gene_name))
  } else {
    return(NULL)
  }
}

# Apply the function to all AMR columns
amr_names <- colnames(amr_counts)[-1] # everything except mag_id

fisher_results <- map_df(amr_names, ~ run_fisher(.x, amr_binary))

# Adjust for multiple testing (FDR)
fisher_results <- fisher_results %>%
  mutate(p.adj = p.adjust(p.value, method = "fdr")) %>%
  filter(p.adj < 0.05) %>%
  arrange(p.adj)

print(fisher_results)
```



# Virulence factors analysis
### Nº of MAGs with VFs
```{r mag counts per VF}
# AMR presence/absence
vf_presence <- genome_annotations %>%
  filter(!is.na(vf)) %>%
  dplyr::select(genome, vf) %>%
  distinct() 

#Add the host_type info
vf_with_host_type <- vf_presence %>%
  left_join(
    genome_metadata %>% dplyr::select(ID, host_type),
    by = c("genome" = "ID")
  )

# Count how many MAGs in each vf
vf_mag_counts <- vf_with_host_type %>%
  group_by(host_type, vf) %>%
  summarise(
    n_mags = n(),
    .groups = "drop"
  )

#Count total MAGs per host_type (except the outlier)
total_mags_per_host_type <- genome_metadata %>%
  group_by(host_type) %>%
  summarise(
    total_mags = n_distinct(ID),
    .groups = "drop"
  )

#Calculate proportions of MAGs from each host_type in each vf
vf_mag_proportions <- vf_mag_counts %>%
  left_join(total_mags_per_host_type, by = "host_type") %>%
  mutate(
    proportion = n_mags / total_mags,
    absent = total_mags - n_mags
  )

```

#### Statistical testing of MAG proportions (Fisher)
```{r statistical testing mag proportions vf}
fisher_results <- vf_mag_proportions %>%
  dplyr::select(vf, host_type, n_mags, absent) %>%
  pivot_wider(
    names_from = host_type,
    values_from = c(n_mags, absent),
    values_fill = 0
  ) %>%
  rowwise() %>%
  mutate(
    p_value = fisher.test(
      matrix(
        c(n_mags_animal,  absent_animal,
          n_mags_human, absent_human),
        nrow = 2,
        byrow = TRUE
      )
    )$p.value
  ) %>%
  ungroup() %>%
  mutate(p_adj = p.adjust(p_value, method = "BH"))

fisher_results <- fisher_results %>%
  mutate(
    prop_animal  = n_mags_animal  / (n_mags_animal  + absent_animal),
    prop_human = n_mags_human / (n_mags_human + absent_human),
    diff_prop = prop_human - prop_animal
  )
```

```{r filtering padj vf}
fisher_results%>% filter(p_adj < 0.05) 
```



## Building a virulence factor abundance table

```{r select virulence factor data from gene annotations}
vf_data <- genome_annotations %>%
  dplyr::select(genome, vf, vf_type) 
```


```{r vf table}
vf_abundance <- genome_annotations %>%
  dplyr::select(genome, vf) %>%
  group_by(genome, vf) %>%
  summarise(count = n(), .groups="drop") %>%
  tidyr::pivot_wider(
    names_from = vf,
    values_from = count,
    values_fill = 0
  )

dim(vf_abundance)
```

```{r vf join with metadata}
vf_cluster <- vf_abundance %>%
  dplyr::full_join(genome_metadata, by= join_by(genome == ID))
```



```{r vf heatmaps}
# make into a matrix
vf_matrix <- vf_abundance %>%
  column_to_rownames("genome") %>%
  as.matrix()

# Unscaled abundance heatmap
pheatmap(vf_matrix,
  color = viridis(100, option = "viridis"),
  cluster_rows = FALSE,
  cluster_cols = TRUE,
  fontsize = 9,
  border_color = NA
)

# For scaled heatmap -> remove zero variance columns 
col_vars <- apply(vf_matrix, 2, var, na.rm = TRUE)
vf_matrix_filtered <- vf_matrix[, col_vars > 0 & !is.na(col_vars)]

# Scale the filtered matrix
vf_scaled <- scale(vf_matrix_filtered, center = TRUE, scale = TRUE)

# Check for any remaining Inf/NaN values
if(any(!is.finite(vf_scaled))) {
  vf_scaled[!is.finite(vf_scaled)] <- 0  # Replace Inf/NaN with 0
}

# Scaled heatmap
pheatmap(vf_scaled,
  color = viridis(100, option = "viridis"),
  cluster_rows = FALSE,
  cluster_cols = TRUE,
  fontsize = 5,
  border_color = NA
)
```

## Virulence presence/absence heatmap
```{r VF presence heatmap,  fig.height=14, fig.width=12, fig.fullwidth=TRUE}
vf_presence <- vf_abundance %>%
  column_to_rownames("genome") %>%   
  mutate(across(everything(), ~ ifelse(. > 0, 1, 0)))%>%
  as.matrix()


pheatmap(
  vf_presence,
  cluster_rows = FALSE,
  cluster_cols = TRUE,
  color = c("white", "darkblue"),     
  legend_breaks = c(0,1),
  legend_labels = c("Absent", "Present"),
  border_color = NA
)

```


## Virulence presence/absence PERMANOVA
```{r vf presence_absence anova}
# remove zero-variance KOs
vf_pa_nz <- vf_presence[, colSums(vf_presence) > 0 & colSums(vf_presence) < nrow(vf_presence)]

# Determine the common genomes
common_ids <- base::intersect(rownames(vf_pa_nz), genome_metadata$ID)

# Report what will be kept/dropped
message("# common: ", length(common_ids))
message("# in KEGG only: ", length(setdiff(rownames(amr_pa_nz), genome_metadata$ID)))
message("# in metadata only: ", length(setdiff(genome_metadata$ID, rownames(vf_pa_nz))))

# Subset to the intersection (and keep order identical)
vf_pa_nz <- vf_pa_nz[common_ids, , drop = FALSE]

meta <- genome_metadata %>%
  dplyr::filter(ID %in% common_ids) %>%
  dplyr::distinct(ID, .keep_all = TRUE) %>%
  tibble::column_to_rownames("ID") %>%
  .[common_ids, , drop = FALSE]

stopifnot(identical(rownames(meta), rownames(vf_pa_nz)))

# VERY IMPORTANT: enforce same order
meta <- meta[rownames(vf_pa_nz), ]

stopifnot(identical(rownames(meta), rownames(vf_pa_nz)))


# Prepare variables for PERMANOVA
required_vars <- c("genome_size", "completeness", "host_type")

# Coerce types as needed
meta <- meta %>%
  dplyr::mutate(
    genome_size  = as.numeric(genome_size),
    completeness = as.numeric(completeness),
    host_type    = as.factor(host_type)
  )

# Align on complete cases (adonis2 drops NAs otherwise)
ok <- stats::complete.cases(meta[, required_vars, drop = FALSE])
vf_pa_nz <- vf_pa_nz[ok, , drop = FALSE]
meta       <- meta[ok, , drop = FALSE]
stopifnot(identical(rownames(meta), rownames(vf_pa_nz)))

# Distance, dispersion, PERMANOVA
vf_dist_pa <- vegan::vegdist(vf_pa_nz, method = "jaccard", binary = TRUE)

disp_pa <- vegan::betadisper(vf_dist_pa, meta$host_type)
anova(disp_pa)

vegan::adonis2(
  vf_dist_pa ~ genome_size + completeness + host_type,
  data = meta,
  permutations = 999,
  by = "margin"
)

```


## Virulence presence/absence PCoA
```{r pcoa on presence absence vf}
pcoa_pa <- cmdscale(vf_dist_pa, eig = TRUE, k = 2)

variance_explained <- pcoa_pa$eig / sum(pcoa_pa$eig)


pcoa_df <- data.frame(
  ID = rownames(vf_pa_nz),
  PC1 = pcoa_pa$points[,1],
  PC2 = pcoa_pa$points[,2],
  host_type = meta$host_type
) %>%
  left_join(metadata_with_cluster, by = "ID")


pcoa_vf_pa <- ggplot(pcoa_df, aes(PC1, PC2, color = host_type.x)) +
  geom_point(size = 2) +
  scale_color_manual(values = host_type_colors, name = "host_type") +
  theme_minimal() +
  labs(
    title = "PCoA of VF annotations across MAGs",
    x = paste0("PCoA1 (", round(variance_explained[1] * 100, 1), "%)"),
    y = paste0("PCoA2 (", round(variance_explained[2] * 100, 1), "%)")
  )

pcoa_vf_pa

ggplot(pcoa_df, aes(PC1, PC2, color = host_order)) +
  geom_point(size = 2) +
  scale_color_manual(values = host_order_colors, na.value = "grey70")+
  theme_minimal() +
  labs(
    title = "PCoA of VF annotations across MAGs (colored by host order)",
    x = paste0("PCoA1 (", round(variance_explained[1] * 100, 1), "%)"),
    y = paste0("PCoA2 (", round(variance_explained[2] * 100, 1), "%)")
  )


ggplot(pcoa_df, aes(PC1, PC2, color = completeness)) +
  geom_point(size = 2) +

  theme_minimal() +
  labs(
    title = "PCoA of VF annotations across MAGs (colored by completeness)",
    x = paste0("PCoA1 (", round(variance_explained[1] * 100, 1), "%)"),
    y = paste0("PCoA2 (", round(variance_explained[2] * 100, 1), "%)")
  )

ggplot(pcoa_df, aes(PC1, PC2, color = genome_size)) +
  geom_point(size = 2) +

  theme_minimal() +
  labs(
    title = "PCoA of VF annotations across MAGs (colored by genome_size)",
    x = paste0("PCoA1 (", round(variance_explained[1] * 100, 1), "%)"),
    y = paste0("PCoA2 (", round(variance_explained[2] * 100, 1), "%)")
  )

ggplot(pcoa_df, aes(PC1, PC2, color = country)) +
  geom_point(size = 2) +
  scale_color_manual(values = country_palette, na.value = "grey70")+
  theme_minimal() +
  labs(
    title = "PCoA of VF annotations across MAGs (colored by country)",
    x = paste0("PCoA1 (", round(variance_explained[1] * 100, 1), "%)"),
    y = paste0("PCoA2 (", round(variance_explained[2] * 100, 1), "%)")
  )


ggplot(pcoa_df, aes(PC1, PC2, color = continent)) +
  geom_point(size = 2) +
  theme_minimal() +
  labs(
    title = "PCoA of VF annotations across MAGs (colored by continent)",
    x = paste0("PCoA1 (", round(variance_explained[1] * 100, 1), "%)"),
    y = paste0("PCoA2 (", round(variance_explained[2] * 100, 1), "%)")
  )

pcoa_vf_pa_cluster <- ggplot(pcoa_df, aes(PC1, PC2, color = cluster)) +
  geom_point(size = 2) +
  theme_minimal() +
  labs(
    title = "PCoA of VF annotations across MAGs (colored by functional cluster)",
    x = paste0("PCoA1 (", round(variance_explained[1] * 100, 1), "%)"),
    y = paste0("PCoA2 (", round(variance_explained[2] * 100, 1), "%)")
  )

pcoa_vf_pa_cluster
```

# CAZY
```{r cazy annotations}
cazy_genes <- genome_annotations %>%
  filter(!is.na(cazy)) %>%
  nrow()

cazy_genes
```


```{r cazy abundance heatmap,  fig.height=14, fig.width=12, fig.fullwidth=TRUE}
cazy_abundance <- genome_annotations %>%
  filter(!is.na(cazy)) %>%
  group_by(genome, cazy) %>%
  summarise(count = n(), .groups="drop") %>%
  tidyr::pivot_wider(
    names_from = cazy,
    values_from = count,
    values_fill = 0
  )

cazy_matrix <- cazy_abundance %>%
  column_to_rownames("genome") %>%
  as.matrix()

# Abundance heatmap
min_val <- min(cazy_matrix, na.rm = TRUE)
max_val <- max(cazy_matrix, na.rm = TRUE)

colors <- viridis(100, option = "viridis")

breaks <- seq(min_val, max_val, length.out = 101)   

pheatmap( cazy_matrix,
  color = colors,
  cluster_rows = FALSE,
  cluster_cols = TRUE,
  fontsize = 9,
  border_color = NA
)


#Scaled abundance heatmap
cazy_scaled <- scale(cazy_matrix, center = TRUE, scale = TRUE)

min_val <- min(cazy_scaled, na.rm = TRUE)
max_val <- max(cazy_scaled, na.rm = TRUE)

colors <- viridis(100, option = "viridis")

breaks <- seq(min_val, max_val, length.out = 101)   



```


## Defense
```{r defense}
genome_annotations %>% dplyr::select(genome, defense, defense_type, antidefense, antidefense_type) %>%
  filter(!is.na(defense))
```


## PCoAs KEGG, AMR and VF
```{r pcoas together, fig.height = 6, fig.width = 7}
library(patchwork)

combined_plot <- (pcoa_kegg_pa + ggtitle("PCoA: KEGG")) +
                 (pcoa_amr_pa  + ggtitle("PCoA: AMR")) +
                 (pcoa_vf_pa   + ggtitle("PCoA: VF")) +
                 plot_layout(ncol = 2, guides = "collect") &
                 theme(legend.position = "bottom")

combined_plot

```



















<!--chapter:end:04_lactococcus_lactis.Rmd-->


# Functions and helpers

```{r color schemes}
source_colors <- c(EHI = "#8BC63F", GTDB = "#2D522D", NCBI= "#20558A")

host_type_colors <- c(human = "#A90D00" , animal = "darkgreen") 


host_order_colors <- c(
  # ---- Mammalia ----
  "Rodentia"        = "#FDA991",  # soft peach
  "Primates"        = "#CC0000",  # bright red
  "Lagomorpha"      = "#C87F46",  # warm brown
  "Proboscidea"     = "#8E5B3A",  # elephant brown
  "Artiodactyla"    = "#A86A3E",  # deer/pig/bovine brown
  "Carnivora"       = "#633C2C",  # dark brown
  "Perissodactyla"  = "#7A4B39",  # horse brown
  "Chiroptera"      = "#1B2021",  # black/charcoal
  "Dasyuromorphia"  = "#A34F3E",  # marsupial red-brown
  "Diprotodontia"   = "#B56952",  # koala warm clay
  
  # --- Amphibian ----
  "Urodela"         = "#1C5551",  # amphibian green‑teal

  # ---- Aves (birds) ----
  
  "Accipitriformes" = "#6A1B9A",   # strong royal purple
  "Galliformes"     = "#D9A6FF",   # light purple
  "Sphenisciformes" = "#8E24AA",   # orchid purple
  "Columbiformes"   = "#9C27B0",   # bright purple
  "Strigiformes"    = "#512DA8",   # deep imperial purple
  "Charadriiformes" = "#AB47BC",   # lavender-purple
  "Passeriformes"   = "#BA68C8",   # softer purple
  "Ciconiiformes"   = "#4A148C",   # darkest purple
  "Anseriformes"    = "#6F2DA8",   # plum violet
  "Gruiformes"      = "#9575CD",   # light violet
  "Cathartiformes"  = "#5E35B1",   # grape purple


  # ---- Reptilia ----
  "Squamata"        = "#1D921B",  # bright green
  "Testudines"      = "#0B6E32",  # turtle green

  # ---- Fish (Actinopterygii) ----
  "Salmoniformes"   = "#00BCD4",  # bright ocean blue
  "Cichliformes"    = "#0097A7",  # deep lake blue

  # ---- Insecta ----
  "Diptera"         = "#FFAE2B",  # your original yellow-orange
  "Isoptera"        = "#E27500",  # orange
  "Blattodea"       = "#D68A00",  # warm amber
  "Lepidoptera"     = "#C8591D",  # burnt orange
  "Coleoptera"      = "#FFB547",  # softer yellow-orange
  "Hemiptera"       = "#F19000",  # vivid golden-orange
  "Hymenoptera"     = "#FFC966",  # honey-bee yellow
  "Orthoptera"      = "#FF9A1A",  # locust/grasshopper orange

  # ---- Unclassified / NA ----
  "NA"              = "#BFBFBF"   # neutral grey
)

country_palette <- c(
  # Southern Europe
  "Spain" = "#1B9E77",
  "Italy" = "#33A02C",
  "Greece" = "#66C2A5",
  "Portugal" = "#2CA25F",
  "Malta" = "#99D8C9",

  # Northern/Central Europe
  "Germany" = "#1F78B4",
  "United Kingdom" = "#4A90E2",
  "Ireland" = "#6BAED6",

  # East Asia 
  "Japan" = "#E31A1C",
  "South Korea" = "#FB6A4A",
  "China" = "#CB181D",

  # North America 
  "USA" = "#756BB1",
  "Canada" = "#9E9AC8",

  # Distinct
  "Australia" = "#FFD92F",   
  "Greenland" = "#A6CEE3",

  "none" = "grey70"
)


```

## DATA PREPARATION
### Load all the data
```{r load_species_files}
## Load all the data 
load_species_files <- function(species, base_dir = "data/mags_metadata") {

  paths <- list(
    ehi_metadata       = file.path(base_dir, paste0(species, "_metadata.tsv")),
    gtdb_final         = file.path(base_dir, paste0(species, "_gtdb_final_metadata.tsv")),
    contig_map         = file.path(base_dir, paste0(species, "_contig_to_mag.tsv")),
    gene_annotations   = file.path(base_dir, paste0(species, "_gene_annotations.tsv.xz")),
    ncbi_metadata_rds  = file.path(base_dir, paste0(species, "_ncbi_metadata.rds")),
    ndb                = file.path(base_dir, paste0(species, "_Ndb.csv"))
  )

  # helper that warns when file is missing
  load_if_exists <- function(path, loader) {
    if (file.exists(path)) {
      loader(path)
    } else {
      warning(sprintf("Missing file: %s", path))
      NULL
    }
  }

  result <- list(
    ehi_metadata     = load_if_exists(paths$ehi_metadata,       \(p) readr::read_tsv(p, show_col_types = FALSE)),
    gtdb_final       = load_if_exists(paths$gtdb_final,         \(p) readr::read_tsv(p, show_col_types = FALSE)),
    contig_map       = load_if_exists(paths$contig_map,         \(p) readr::read_tsv(p, show_col_types = FALSE)),
    gene_annotations = load_if_exists(paths$gene_annotations,   \(p) readr::read_tsv(p, show_col_types = FALSE)),
    ndb              = load_if_exists(paths$ndb,                \(p) readr::read_csv(p, show_col_types = FALSE)),
    ncbi_metadata    = load_if_exists(paths$ncbi_metadata_rds,  readRDS)
  )

  return(result)
}

```


```{r helpers to standardize columns}
# Find the most plausible genome size column and rename to genome_size
detect_and_rename_genome_size <- function(df) {
  if (is.null(df)) return(df)

  # If exact already present, nothing to do
  if ("genome_size" %in% names(df)) return(df)

  # Common explicit variants (ordered by preference)
  candidates <- c(
    # EHI 
    "size", "Size", "SIZE",
    # NCBI 
    "genome_size...4", "genome_size...43",
    # other common labels
    "size_bp", "Size_bp", "genome_size_bp",
    "total_length", "assembly_length", "estimated_size"
  )

  hit <- intersect(candidates, names(df))
  if (length(hit) >= 1) {
    # If multiple hits appear, prefer the first listed above
    df <- dplyr::rename(df, genome_size = !!hit[1])
    return(df)
  }

  # Fallback: first column containing "genome_size" or "size" or "length"
  fuzzy <- grep("(genome_)?size|length", names(df), ignore.case = TRUE, value = TRUE)
  if (length(fuzzy) >= 1) {
    df <- dplyr::rename(df, genome_size = !!fuzzy[1])
    return(df)
  }

  df
}

# Normalize 'n50' (lowercase in some NCBI exports) to 'N50'
detect_and_rename_n50 <- function(df) {
  if (is.null(df)) return(df)
  if (!("N50" %in% names(df)) && ("n50" %in% names(df))) {
    df <- dplyr::rename(df, N50 = n50)
  }
  df
}

# Enforce consistent types across sources before bind_rows()
harmonize_schema <- function(df) {
  if (is.null(df)) return(NULL)


  # Column name standardization

  rename_map <- c(
    "isolation_source.x" = "isolation_source",
    "isolation_source.y" = "isolation_source",
    "isolation_source_x" = "isolation_source",
    "isolation_source_y" = "isolation_source",

    "geo_loc_name"       = "country",
    "geographic location (latitude)"  = "latitude",
    "geographic location (longitude)" = "longitude"
  )

  # Rename if present
  for (old in names(rename_map)) {
    if (old %in% names(df)) {
      names(df)[names(df) == old] <- rename_map[[old]]
    }
  }


  #  Define expected schema

  char_cols <- c(
    "ID","source","species","gtdb_taxonomy","gtdb_representative",
    "isolation_source","host","host_status","disease","diagnosis",
    "host_species","host_order","host_class","host_summary",
    "country","locality","collection_date","ncbi_biosample",
    "mag_name","eha_number","common_name","sample_name","external_id","submitter_id",
    "env_broad","env_medium","env_local","env_local_context"
  )

  num_cols <- c(
    "completeness","contamination","genome_size","GC","N50","contigs",
    "latitude","longitude"
  )

  logi_cols <- c("mimag_high_quality","mimag_medium_quality")

  #  Add missing columns

  for (cc in char_cols) if (!cc %in% names(df)) df[[cc]] <- NA_character_
  for (nc in num_cols)  if (!nc %in% names(df)) df[[nc]] <- NA_real_
  for (lc in logi_cols) if (!lc %in% names(df)) df[[lc]] <- NA


  #  Type-coerce consistently

  df <- df %>%
    dplyr::mutate(
      dplyr::across(
        dplyr::all_of(char_cols),
        ~ as.character(.x)
      ),
      dplyr::across(
        dplyr::all_of(num_cols),
        ~ suppressWarnings(as.numeric(.x))
      ),
      dplyr::across(
        dplyr::all_of(logi_cols),
        ~ as.logical(.x)
      )
    )


  #  Return cleaned df

  df
}


# ---- Prepare gene annotations: add the genome with contig_map ----
prep_gene_annotations_with_genome <- function(ann_raw, contig_map_raw) {
  if (is.null(ann_raw)) return(NULL)
  if (is.null(contig_map_raw)) {
    stop("contig_map is required to attach 'genome' to gene_annotations.")
  }

  # --- Standardize contig_map to columns: contig, genome ---
  cm <- contig_map_raw

  contig_col_candidates <- intersect(names(cm), c("contig", "contig_id", "contig_name", "scaffold"))
  if (length(contig_col_candidates) == 0) {
    stop("contig_map must have a contig column (one of: contig, contig_id, contig_name, scaffold).")
  }

  genome_col_candidates <- intersect(
    names(cm),
    c("genome", "genome_filename", "mag", "bin", "genome_id", "assembly")
  )
  if (length(genome_col_candidates) == 0) {
    stop("contig_map must have a genome column (e.g., genome, genome_filename, mag, bin, genome_id, assembly).")
  }

  cm <- cm %>%
    dplyr::rename(
      contig = !!rlang::sym(contig_col_candidates[1]),
      genome = !!rlang::sym(genome_col_candidates[1])
    ) %>%
    dplyr::mutate(
      contig = as.character(contig),
      genome = as.character(genome)
    )

  # --- Ensure annotations have a contig column ---
  an <- ann_raw

  if (!("contig" %in% names(an))) {
    # Try to derive from a gene-like column by stripping the last _segment
    gene_col_candidates <- intersect(names(an), c("gene", "gene_id", "locus_tag", "feature_id"))
    if (length(gene_col_candidates) == 0) {
      stop("gene_annotations must have `contig` or a gene-like column (gene/gene_id/locus_tag/feature_id).")
    }

    an <- an %>%
      dplyr::rename(.gene_tmp = !!rlang::sym(gene_col_candidates[1])) %>%
      dplyr::mutate(contig = sub("_[^_]*$", "", .data$.gene_tmp)) %>%
      dplyr::select(-dplyr::any_of(".gene_tmp"))
  }

  # --- Join to add genome and filter out missing ---
  an <- an %>%
    dplyr::mutate(contig = as.character(contig)) %>%
    dplyr::left_join(cm, by = "contig") %>%
    dplyr::filter(!is.na(.data$genome))

  return(an)
}


clean_biosample_value <- function(v) {
  if (is.na(v)) return(NA_character_)
  v <- str_trim(v)
  m <- str_match(v, '^Attribute\\s+"(.*)"$')
  if (!is.na(m[1,2])) v <- str_trim(m[1,2])
  v_low <- tolower(v)
  if (v_low %in% c("missing","not provided","not applicable","na","n/a","none","unknown",
                   "unspecified","not collected","not determined","not available")) return(NA_character_)
  if (v == "") return(NA_character_)
  v
}

```


### Prepare EHI metadata
```{r prepare EHI metadata}
# Prepare EHI metadata into a standardized schema
prep_ehi_metadata <- function(ehi_raw) {
  if (is.null(ehi_raw)) return(NULL)

  ehi_raw <- detect_and_rename_genome_size(ehi_raw)
  ehi_raw <- detect_and_rename_n50(ehi_raw)

  ehi_clean <- ehi_raw %>%
    mutate(
      GC = suppressWarnings(as.numeric(str_remove(GC, "%")))
    ) %>%
    dplyr::select(
      any_of(c(
        "ID","species","completeness","contamination",
        "genome_size","GC","N50","contigs",
        "host_species","host_order","host_class",
        "sample_type","isolation_source","country","locality",
        "mag_name","eha_number"
      ))
    ) %>%
    mutate(
      isolation_source = coalesce(isolation_source, sample_type),
      source = "EHI"
    ) %>%
    dplyr::select(-sample_type)

  harmonize_schema(ehi_clean)
}
```


### Prepare GTDB metadata
```{r prepare GTDB metadata}
prep_gtdb_final <- function(gtdb_raw) {
  if (is.null(gtdb_raw)) return(NULL)

  # Standardize size & N50 labels
  gtdb_raw <- detect_and_rename_genome_size(gtdb_raw)
  gtdb_raw <- detect_and_rename_n50(gtdb_raw)

  gtdb_clean <- gtdb_raw %>%
    # Pick only columns we may need (robust to presence/absence)
    dplyr::select(dplyr::any_of(c(
      "ID","accession","gtdb_taxonomy","gtdb_representative",
      "checkm2_completeness","checkm2_contamination",
      "genome_size","gc_percentage","N50","n50_contigs",
      "contigs","contig_count",
      "ncbi_biosample","country","geo_loc_name",
      "isolation_source","isolation_source.x","isolation_source_x",
      "isolation_source.y","isolation_source_y",
      "host","host_status","disease","diagnosis","host_summary",
      # latitude/longitude may appear with ENA-style names; keep both
      "latitude","longitude","geographic location (latitude)","geographic location (longitude)",
      # environment / context variants
      "env_broad","env_broad_scale","env_medium","env_local","env_local_scale",
      "env_local_context","local environmental context",
      # names with spaces/case variants from ENA
      "common_name","common name","sample_name","external_id","External Id","submitter_id","Submitter Id",
      "collection_date"
    ))) %>%
    # Normalize N50/contigs if only alt names exist
    { if (!"N50" %in% names(.) && "n50_contigs" %in% names(.)) dplyr::rename(., N50 = n50_contigs) else . } %>%
    { if (!"contigs" %in% names(.) && "contig_count" %in% names(.)) dplyr::rename(., contigs = contig_count) else . } %>%
    # Conditional renames for ENA/GTDB variants (no-op if missing)
    { if ("env_broad_scale" %in% names(.)) dplyr::rename(., env_broad = `env_broad_scale`) else . } %>%
    { if ("env_local_scale" %in% names(.)) dplyr::rename(., env_local = `env_local_scale`) else . } %>%
    { if ("local environmental context" %in% names(.)) dplyr::rename(., env_local_context = `local environmental context`) else . } %>%
    { if ("common name" %in% names(.)) dplyr::rename(., common_name = `common name`) else . } %>%
    { if ("External Id" %in% names(.)) dplyr::rename(., external_id = `External Id`) else . } %>%
    { if ("Submitter Id" %in% names(.)) dplyr::rename(., submitter_id = `Submitter Id`) else . } %>%
    # Add core source + numeric fields
    dplyr::mutate(
      source        = "GTDB",
      completeness  = .data$checkm2_completeness,
      contamination = .data$checkm2_contamination,
      GC            = .data$gc_percentage
    )

  #  Coalesce isolation_source variants safely (handle dot/underscore suffixes)
  iso_candidates <- c("isolation_source","isolation_source.x","isolation_source_x",
                      "isolation_source.y","isolation_source_y")
  present_iso <- intersect(iso_candidates, names(gtdb_clean))
  if (length(present_iso) > 0) {
    # progressive coalesce across present variants
    iso <- gtdb_clean[[present_iso[1]]]
    if (length(present_iso) > 1) {
      for (nm in present_iso[-1]) iso <- dplyr::coalesce(iso, gtdb_clean[[nm]])
    }
    gtdb_clean[["isolation_source"]] <- iso
  }

  # Prefer GTDB 'country', else ENA 'geo_loc_name'
  if ("geo_loc_name" %in% names(gtdb_clean)) {
    gtdb_clean[["country"]] <- dplyr::coalesce(gtdb_clean[["country"]], gtdb_clean[["geo_loc_name"]])
  }

  #  Drop helper/duplicate columns we normalized away
  gtdb_clean <- gtdb_clean %>%
    dplyr::select(-dplyr::any_of(c(
      "checkm2_completeness","checkm2_contamination","gc_percentage",
      "n50_contigs","contig_count","geo_loc_name",
      "isolation_source.x","isolation_source_x","isolation_source.y","isolation_source_y"
    )))

  # Final schema/type harmonization (handles lat/long ENA names, adds missing cols)
  gtdb_clean <- harmonize_schema(gtdb_clean)

  return(gtdb_clean)
}
```


### Prepare NCBI metadata
```{r prepare ncbi metadata}
# Prepare NCBI metadata into standardized schema
prep_ncbi_metadata <- function(ncbi_raw) {
  if (is.null(ncbi_raw)) return(NULL)

  ncbi_raw <- detect_and_rename_genome_size(ncbi_raw)
  ncbi_raw <- detect_and_rename_n50(ncbi_raw)

  ncbi_clean <- ncbi_raw %>%
    dplyr::select(
      dplyr::any_of(c(
        "accession","completeness","contamination",
        "genome_size","gc_percent","isolation_source","host",
        "collection_date","geo_loc_name","N50","contigs","host_disease","host_age"
      ))
    ) %>%
    dplyr::rename(
      ID = accession,
      country = geo_loc_name,
      GC = gc_percent
    ) %>%
    dplyr::mutate(
      source = "NCBI"
    )

  harmonize_schema(ncbi_clean)
}
```



### Combine metadata sources into genome_metadata
```{r merge metadata}
# Combine EHI + GTDB(final) + NCBI into one unified table
combine_metadata_sources <- function(ehi_clean,
                                     gtdb_final_clean,
                                     ncbi_clean) {
  tables <- list(ehi_clean, gtdb_final_clean, ncbi_clean)
  tables <- tables[!vapply(tables, is.null, logical(1))]

  if (length(tables) == 0) {
    # No sources available: return an empty tibble 
    genome_metadata <- harmonize_schema(tibble::tibble())
  } else {
    # Ensure schema per table, then bind
    tables <- lapply(tables, harmonize_schema)
    genome_metadata <- dplyr::bind_rows(tables)
    # One more pass to guarantee presence of all expected columns
    genome_metadata <- harmonize_schema(genome_metadata)
  }

  # Safe numeric coercions in columns that exist
  genome_metadata <- genome_metadata %>%
  dplyr::mutate(
    completeness  = if ("completeness"   %in% names(.)) suppressWarnings(as.numeric(completeness))  else NA_real_,
    contamination = if ("contamination"  %in% names(.)) suppressWarnings(as.numeric(contamination)) else NA_real_,
    GC            = if ("GC"             %in% names(.)) suppressWarnings(as.numeric(GC))            else NA_real_,
    genome_size   = if ("genome_size"    %in% names(.)) suppressWarnings(as.numeric(genome_size))   else NA_real_,
    N50           = if ("N50"            %in% names(.)) suppressWarnings(as.numeric(N50))           else NA_real_,
    contigs       = if ("contigs"        %in% names(.)) suppressWarnings(as.numeric(contigs))       else NA_real_
  )

  # Reorder columns if present
  front_cols <- c(
    "ID","source","species","gtdb_taxonomy",
    "host_species","host_order","host_class",
    "isolation_source","host","host_summary",
    "country","locality",
    "completeness","contamination","genome_size","GC","N50","contigs",
    "collection_date","ncbi_biosample","mag_name","eha_number",
    "gtdb_representative","mimag_high_quality","mimag_medium_quality",
    "common_name","sample_name","external_id","submitter_id",
    "env_broad","env_medium","env_local","env_local_context"
  )
  front_cols <- intersect(front_cols, colnames(genome_metadata))
  genome_metadata <- genome_metadata %>%
    dplyr::relocate(dplyr::all_of(front_cols), .before = 1)

  if (nrow(genome_metadata) > 0 && all(is.na(genome_metadata$genome_size))) {
    warning("All genome_size values are NA after merging. Check size mapping.")
  }

  genome_metadata
}
```


### Infer host metadata 
```{r infer host species}
normalize_species <- function(s) {
  # Vectorized normalization of binomials
  s <- as.character(s)
  s[is.na(s) | s == ""] <- NA_character_

  s_low <- stringr::str_to_lower(s)

  # Canonicalize known synonyms/typos
  out <- dplyr::case_when(
    # Dog
    stringr::str_detect(s_low, "^canis\\s+familiaris$") ~ "Canis lupus familiaris",
    stringr::str_detect(s_low, "^canis\\s+lupus\\s+familiaris$") ~ "Canis lupus familiaris",
    stringr::str_detect(s_low, "^mammuthus\\s+primi") ~ "Mammuthus primigenius",
    TRUE ~ s
  )

  # Title-case genus, lower species where we have at least two tokens
  reformat <- function(x) {
    if (is.na(x) || x == "") return(NA_character_)
    parts <- strsplit(x, "\\s+")[[1]]
    if (length(parts) < 2) return(x)
    paste0(stringr::str_to_title(parts[1]), " ", stringr::str_to_lower(parts[2]))
  }
  # Vectorize reformat over 'out'
  out[] <- vapply(out, reformat, character(1))
  out
}
#----------------------------------------------------------------------------------

# Accept only true-looking Latin binomials and reject common non-species nouns
is_latin_binomial_strict <- function(x) {
  x <- as.character(x)
  ok_shape <- grepl("^[A-Z][a-z]+\\s+[a-z]{3,}$", x)  # Genus species
  if (!any(ok_shape, na.rm = TRUE)) return(rep(FALSE, length(x)))

  bad_terms <- c(
    "human","patient","infant","child","adult",
    "feces","faeces","stool","urine","blood","saliva","swab","swabs",
    "skin","gut","intestinal","rumen","content","contents",
    "sample","metagenome","environment","environmental","tissue",
    "rectal","oral","nasal","throat","vaginal","anal", "dairy", "cabbage", "kimchi", "broiler", "subcultured"
  )

  reject <- rep(FALSE, length(x))
  ix <- which(ok_shape & !is.na(x))
  if (length(ix) > 0) {
    parts <- strsplit(x[ix], "\\s+")
    for (i in seq_along(ix)) {
      w <- tolower(parts[[i]])
      reject[ix[i]] <- any(w %in% bad_terms)
    }
  }
  ok_shape & !reject
}


#----------------------------------------------------------------
infer_host_metadata <- function(genome_metadata) {

  if (is.null(genome_metadata)) return(NULL)

  # Utility
  is_blank <- function(x) is.na(x) | x == ""
  
  tax_map <- tibble::tibble(
  host_species = c(
    # Humans / lab / livestock / pets
    "Homo sapiens",
    "Mus musculus",
    "Rattus norvegicus",
    "Sus scrofa",
    "Bos taurus",
    "Canis lupus familiaris",
    "Equus caballus",
    "Oryctolagus cuniculus",
    "Capra hircus",

    # Birds
    "Gallus gallus",
    "Cathartes aura",
    "Columba livia",
    "Spheniscus magellanicus",

    # Insects
    "Drosophila melanogaster",
    "Bombyx mori",

    # Fish
    "Danio rerio",
    "Oncorhynchus mykiss",
    "Oreochromis niloticus",

    # Marine mammals / pinnipeds
    "Balaenoptera acutorostrata",
    "Arctocephalus australis",

    # Extinct
    "Mammuthus primigenius",
    
    #More
    "Loxodonta africana",
    "Elephas maximus",
    "Felis catus",
    "Canis lupus",
    "Phascolarctos cinereus",
    
    "Grasshopper",
    "Termite",
    "Macaca fascicularis",
    "Rhinolophus capensis",
    "Fish",
    
    #Final (from total_genome_metadata)
    "Zophobas morio",
    "Mustela putorius",
    "Ovis aries",
    "Corallus caninus",
    "Meles meles",
    "Clanga pomarina",
    "Buteo buteo",
    "Accipiter gentilis",
    "Chelonia mydas",
    "Grampus griseus",
    "Sterna trudeaui",
    "Rhodnius prolixus",
    "Turdus merula",
    "Curruca curruca",
    "Columba palumbus",
    "Delichon urbicum",
    "Chloris chloris",
    "Hirundo rustica",
    "Ciconia ciconia",
    "Anas platyrhynchos",
    "Grus grus",
    "Apis mellifera",
    "Coragyps atratus",
    "Pseudoscops clamator",
    "Pandion haliaetus",
    "Sycanus bifidus",
    "Eocanthecona furcellata",
    "Arma custos",
    "Corvus frugilegus",
    "Milvus milvus",
    "Vulpes zerda"


  ),
  tax_host_order = c(
    # Humans / lab / livestock / pets
    "Primates",
    "Rodentia",
    "Rodentia",
    "Artiodactyla",
    "Artiodactyla",
    "Carnivora",
    "Perissodactyla",
    "Lagomorpha",
    "Artiodactyla",

    # Birds
    "Galliformes",
    "Accipitriformes",
    "Columbiformes",
    "Sphenisciformes",

    # Insects
    "Diptera",
    "Lepidoptera",

    # Fish
    "Cypriniformes",
    "Salmoniformes",
    "Cichliformes",

    # Marine mammals / pinnipeds
    "Artiodactyla",      # (Cetartiodactyla)
    "Carnivora",

    # Extinct
    "Proboscidea",
    
    #More
    "Proboscidea",
    "Proboscidea",
    "Carnivora",
    "Carnivora",
    "Diprotodontia",
    
    
    "Orthoptera",     # Grasshopper
    "Blattodea",      # Termite (termites now placed within Blattodea; Isoptera as infraorder)
    "Primates",       # Macaca fascicularis
    "Chiroptera",     # Rhinolophus capensis (horseshoe bat)
    NA_character_,    # Fish (no single order fits all fish)
    
    #Final (from total_genome_metadata)
    "Coleoptera",          # Zophobas morio
    "Carnivora",           # Mustela putorius
    "Artiodactyla",        # Ovis aries
    "Squamata",            # Corallus caninus
    "Carnivora",           # Meles meles
    "Accipitriformes",     # Clanga pomarina
    "Accipitriformes",     # Buteo buteo
    "Accipitriformes",     # Accipiter gentilis
    "Testudines",          # Chelonia mydas
    "Artiodactyla",        # Grampus griseus
    "Charadriiformes",     # Sterna trudeaui
    "Hemiptera",           # Rhodnius prolixus
    "Passeriformes",       # Turdus merula
    "Passeriformes",       # Curruca curruca
    "Columbiformes",       # Columba palumbus
    "Passeriformes",       # Delichon urbicum
    "Passeriformes",       # Chloris chloris
    "Passeriformes",       # Hirundo rustica
    "Ciconiiformes",       # Ciconia ciconia
    "Anseriformes",        # Anas platyrhynchos
    "Gruiformes",          # Grus grus
    "Hymenoptera",         # Apis mellifera
    "Cathartiformes",      # Coragyps atratus
    "Strigiformes",        # Pseudoscops clamator
    "Accipitriformes",     # Pandion haliaetus
    "Hemiptera",           # Sycanus bifidus
    "Hemiptera",           # Eocanthecona furcellata
    "Hemiptera",           # Arma custos
    "Passeriformes",       # Corvus frugilegus
    "Accipitriformes",     # Milvus milvus
    "Carnivora"            # Vulpes zerda


  ),
  tax_host_class = c(
    # Humans / lab / livestock / pets
    "Mammalia",
    "Mammalia",
    "Mammalia",
    "Mammalia",
    "Mammalia",
    "Mammalia",
    "Mammalia",
    "Mammalia",
    "Mammalia",

    # Birds
    "Aves",
    "Aves",
    "Aves",
    "Aves",

    # Insects
    "Insecta",
    "Insecta",

    # Fish
    "Actinopterygii",
    "Actinopterygii",
    "Actinopterygii",

    # Marine mammals / pinnipeds
    "Mammalia",
    "Mammalia",

    # Extinct and more
    "Mammalia",
    "Mammalia",
    "Mammalia",
    "Mammalia",
    "Mammalia",
    "Mammalia",
    
        
    "Insecta",        # Grasshopper
    "Insecta",        # Termite
    "Mammalia",       # Macaca fascicularis
    "Mammalia",       # Rhinolophus capensis
    "Actinopterygii",  # Fish (bony fishes; safe default for generic "fish")

    #Final (from total_genome_metadata)
    "Insecta",        # Zophobas morio
    "Mammalia",       # Mustela putorius
    "Mammalia",       # Ovis aries
    "Reptilia",       # Corallus caninus
    "Mammalia",       # Meles meles
    "Aves",           # Clanga pomarina
    "Aves",           # Buteo buteo
    "Aves",           # Accipiter gentilis
    "Reptilia",       # Chelonia mydas
    "Mammalia",       # Grampus griseus
    "Aves",           # Sterna trudeaui
    "Insecta",        # Rhodnius prolixus
    "Aves",           # Turdus merula
    "Aves",           # Curruca curruca
    "Aves",           # Columba palumbus
    "Aves",           # Delichon urbicum
    "Aves",           # Chloris chloris
    "Aves",           # Hirundo rustica
    "Aves",           # Ciconia ciconia
    "Aves",           # Anas platyrhynchos
    "Aves",           # Grus grus
    "Insecta",        # Apis mellifera
    "Aves",           # Coragyps atratus
    "Aves",           # Pseudoscops clamator
    "Aves",           # Pandion haliaetus
    "Insecta",        # Sycanus bifidus
    "Insecta",        # Eocanthecona furcellata
    "Insecta",        # Arma custos
    "Aves",           # Corvus frugilegus
    "Aves",           # Milvus milvus
    "Mammalia"        # Vulpes zerda

  )
)
  

  # --- 1) Unified host text for pattern matching ---
  genome_metadata <- genome_metadata %>%
    dplyr::mutate(
      host_text = stringr::str_to_lower(
        stringr::str_squish(
          paste(
            dplyr::coalesce(.data$host_species, ""),
            dplyr::coalesce(.data$host, ""),
            dplyr::coalesce(.data$isolation_source, ""),
            dplyr::coalesce(.data$env_broad, ""),
            dplyr::coalesce(.data$env_local_context, ""),
            sep = " ; "
          )
        )
      )
    )

  # --- 2) Common-name / phrase heuristics (vectorized) ---
  guess_from_common <- function(txt) {
    dplyr::case_when(
      # Exact species mentions / synonyms
      stringr::str_detect(txt, "\\barctocephalus australis\\b|\\bfur seal\\b|south american fur seal") ~ "Arctocephalus australis",
      stringr::str_detect(txt, "\\bbalaenoptera acutorostrata\\b|\\bminke whale\\b") ~ "Balaenoptera acutorostrata",
      stringr::str_detect(txt, "\\bspheniscus magellanicus\\b|\\bmagellanic penguin\\b|\\bpenguin\\b") ~ "Spheniscus magellanicus",

      
 #Elephants
    stringr::str_detect(txt, "\\basian elephant\\b") ~ "Elephas maximus",
    stringr::str_detect(txt, "\\bafrican elephant\\b") ~ "Loxodonta africana",
    stringr::str_detect(txt, "\\belephants?\\b") ~ "Loxodonta africana",  # default choice
    #cats
    stringr::str_detect(txt, "\\b(cat|cats|kitten|kittens|feline|house\\s*cat)\\b") ~ "Felis catus",
    stringr::str_detect(txt, "\\bfelis\\s+catus\\b") ~ "Felis catus",

    # dogs 
    stringr::str_detect(txt, "\\b(dog|dogs|puppy|puppies|canine|pet\\s*dog)\\b") ~ "Canis lupus familiaris",
    stringr::str_detect(txt, "\\bcanis\\s+lupus\\s+familiaris\\b|\\bcanis\\s+familiaris\\b") ~ "Canis lupus familiaris",

    # gray wolf (wild Canis lupus) ---
    stringr::str_detect(txt, "\\bcanis\\s+lupus\\b|\\bgray\\s*wolf\\b|\\bgrey\\s*wolf\\b|\\bwolf\\b") ~ "Canis lupus",
 
 #grasshopper
   stringr::str_detect(txt, "\\bgrasshopper\\b|\\blocust\\b|\\blocusts\\b") ~ "Grasshopper",

 
      stringr::str_detect(txt, "\\brabbit\\b|\\bbunny\\b|\\bbunnies\\b|\\blagomorph\\b") ~ "Oryctolagus cuniculus",
      stringr::str_detect(txt, "\\bpigeon\\b|\\bdove\\b") ~ "Columba livia",
      stringr::str_detect(txt, "\\bequine\\b|\\bhorse\\b|\\bfoal\\b") ~ "Equus caballus",
      stringr::str_detect(txt, "\\bcattle\\b|\\bbovine\\b|\\bcow\\b|\\bcows\\b") ~ "Bos taurus",
      stringr::str_detect(txt, "\\bgoat\\b|\\bcaprine\\b|\\bkid\\b") ~ "Capra hircus",
      stringr::str_detect(txt, "\\bpiglet\\b|\\bpiglets\\b|\\bpig\\b|\\bswine\\b|\\bporcine\\b") ~ "Sus scrofa",
      stringr::str_detect(txt, "\\bmammoth\\b|malolyakovskiy\\s+mammoth") ~ "Mammuthus primigenius",

      # Existing helpful ones
      stringr::str_detect(txt, "homo sapiens|\\bhuman\\b|patient|adult|child|infant") ~ "Homo sapiens",
      stringr::str_detect(txt, "mus musculus|\\bmouse\\b|\\bmice\\b|murine") ~ "Mus musculus",
      stringr::str_detect(txt, "\\brattus|\\brat\\b") ~ "Rattus norvegicus",
      stringr::str_detect(txt, "sus scrofa|porcine|\\bpig\\b|swine") ~ "Sus scrofa",
      stringr::str_detect(txt, "bos taurus|bovine|\\bcow\\b|cattle") ~ "Bos taurus",
      stringr::str_detect(txt, "canis lupus familiaris|canis familiaris|\\bdog\\b|canine") ~ "Canis lupus familiaris",
     stringr::str_detect(txt, "gallus gallus|\\bchicken\\b|\\bpoultry\\b|\\bbroiler\\b") ~ "Gallus gallus",
      stringr::str_detect(txt, "bombyx mori|silkworm") ~ "Bombyx mori",
      stringr::str_detect(txt, "drosophila|fruit fly") ~ "Drosophila melanogaster",
      stringr::str_detect(txt, "danio rerio|zebrafish") ~ "Danio rerio",
      stringr::str_detect(txt, "oncorhynchus mykiss") ~ "Oncorhynchus mykiss",
      stringr::str_detect(txt, "oreochromis niloticus") ~ "Oreochromis niloticus",
 
     stringr::str_detect(txt, "\\btermite(s)?\\b") ~ "Termite",
    
        # Macaca fascicularis (Latin or common names) ---
        stringr::str_detect(txt, "\\bmacaca\\s+fascicularis\\b|\\bcynomolgus\\b|\\bcrab[-]eating\\s+macaque\\b|\\bmacaque\\b") ~ "Macaca fascicularis",
    
        # Rhinolophus capensis (Latin or common name) ---
        stringr::str_detect(txt, "\\brhinolophus\\s+capensis\\b|\\brhinolopus\\s+capensis\\b|\\bcape\\s+horseshoe\\s+bat\\b|\\bhorseshoe\\s+bat\\b") ~ "Rhinolophus capensis",
    
        # Generic fish catch-all  ---
        stringr::str_detect(txt, "\\bfish\\b|\\bfishes\\b") ~ "Fish",
 
        # Zophobas morio
        stringr::str_detect(txt, "zophobas|superworm|darkling beetle") ~ "Zophobas morio",
        
        # Mustela putorius
        stringr::str_detect(txt, "mustela putorius|polecat") ~ "Mustela putorius",
        
        # Ovis aries
        stringr::str_detect(txt, "ovis aries|\\bsheep\\b") ~ "Ovis aries",
        
        # Corallus caninus
        stringr::str_detect(txt, "corallus caninus|emerald tree boa") ~ "Corallus caninus",
        
        # Chelonia mydas
        stringr::str_detect(txt, "chelonia mydas|green sea turtle") ~ "Chelonia mydas",
        
        # Grampus griseus
        stringr::str_detect(txt, "grampus griseus|risso") ~ "Grampus griseus",
        
        # Rhodnius prolixus
        stringr::str_detect(txt, "rhodnius prolixus|kissing bug") ~ "Rhodnius prolixus",
        
        # Apis mellifera
        stringr::str_detect(txt, "apis mellifera|honey[- ]?bee") ~ "Apis mellifera",
        
        # Sycanus bifidus
        stringr::str_detect(txt, "sycanus bifidus") ~ "Sycanus bifidus",
        
        # Eocanthecona furcellata
        stringr::str_detect(txt, "eocanthecona") ~ "Eocanthecona furcellata",
        
        # Arma custos
        stringr::str_detect(txt, "arma custos") ~ "Arma custos",
        
        # Bird species
        stringr::str_detect(txt, "clanga pomarina|spotted eagle") ~ "Clanga pomarina",
        stringr::str_detect(txt, "buteo buteo|buzzard") ~ "Buteo buteo",
        stringr::str_detect(txt, "accipiter gentilis|goshawk") ~ "Accipiter gentilis",
        stringr::str_detect(txt, "trudeaui") ~ "Sterna trudeaui",
        stringr::str_detect(txt, "turdus merula|blackbird") ~ "Turdus merula",
        stringr::str_detect(txt, "curruca curruca|whitethroat") ~ "Curruca curruca",
        stringr::str_detect(txt, "columba palumbus|wood pigeon") ~ "Columba palumbus",
        stringr::str_detect(txt, "delichon urbicum|house martin") ~ "Delichon urbicum",
        stringr::str_detect(txt, "chloris chloris|greenfinch") ~ "Chloris chloris",
        stringr::str_detect(txt, "hirundo rustica|barn swallow") ~ "Hirundo rustica",
        stringr::str_detect(txt, "ciconia ciconia|white stork") ~ "Ciconia ciconia",
        stringr::str_detect(txt, "anas platyrhynchos|mallard") ~ "Anas platyrhynchos",
        stringr::str_detect(txt, "grus grus|crane") ~ "Grus grus",
        stringr::str_detect(txt, "coragyps atratus|black vulture") ~ "Coragyps atratus",
        stringr::str_detect(txt, "clamator") ~ "Pseudoscops clamator",
        stringr::str_detect(txt, "corvus frugilegus|rook") ~ "Corvus frugilegus",
        stringr::str_detect(txt, "milvus milvus|red kite") ~ "Milvus milvus",
        stringr::str_detect(txt, "pandion haliaetus|osprey") ~ "Pandion haliaetus",

      TRUE ~ NA_character_
    )
  }

  genome_metadata <- genome_metadata %>%
    dplyr::mutate(.common_guess = guess_from_common(.data$host_text))

  # --- 3) Extract explicit Latin binomial (strict) as a later fallback ---
  extract_latin_binomial_strict <- function(x) {
    x <- x[!is.na(x)]
    if (length(x) == 0) return(NA_character_)
    txt <- paste(x, collapse = " ; ")
    txt <- stringr::str_replace_all(txt, "[^A-Za-z ]+", " ")
    txt <- stringr::str_squish(txt)
    matches <- unlist(stringr::str_extract_all(
      txt, "\\b[A-Z][a-z]+\\s+[a-z]{3,}\\b"
    ))
    if (length(matches) == 0) return(NA_character_)
    valid <- matches[is_latin_binomial_strict(matches)]
    if (length(valid) == 0) return(NA_character_)
    valid[1]
  }

  genome_metadata <- genome_metadata %>%
    dplyr::rowwise() %>%
    dplyr::mutate(
      .binom_guess = extract_latin_binomial_strict(c(
        as.character(.data$host_species),
        as.character(.data$host),
        as.character(.data$isolation_source),
        as.character(.data$env_broad),
        as.character(.data$env_local_context)
      ))
    ) %>%
    dplyr::ungroup()

  # --- 4) Decide host_species (trust valid binomial, then common-name, then binomial guess) ---
  bad_terms <- "(feces|faeces|stool|urine|blood|saliva|swab|swabs|skin|gut|intestinal|rumen|content|contents|sample|metagenome|environment|environmental|patient|infant|adult|child|rectal|oral|nasal|throat|vaginal|anal)"

  genome_metadata <- genome_metadata %>%
    dplyr::mutate(
      host_species = dplyr::if_else(
        is_latin_binomial_strict(.data$host_species) &
          !stringr::str_detect(stringr::str_to_lower(.data$host_species), bad_terms),
        normalize_species(.data$host_species),
        NA_character_
      ),
      host_species = dplyr::case_when(
        !is_blank(.data$host_species) ~ .data$host_species,
        !is_blank(.data$.common_guess) ~ normalize_species(.data$.common_guess),  # PRIORITIZE common-name mapping
        !is_blank(.data$.binom_guess)  ~ normalize_species(.data$.binom_guess),  # then extracted binomial
        TRUE ~ .data$host_species
      )
    )

  # --- 5) Join to fill order/class from dictionary ---
  genome_metadata <- genome_metadata %>%
    dplyr::left_join(tax_map, by = "host_species") %>%
    dplyr::mutate(
      host_order = dplyr::coalesce(.data$host_order, .data$tax_host_order),
      host_class = dplyr::coalesce(.data$host_class, .data$tax_host_class)
    ) %>%
    dplyr::select(-dplyr::any_of(c("tax_host_order","tax_host_class")))

  # --- 6) host_type ---
  genome_metadata <- genome_metadata %>%
    dplyr::mutate(
      host_type = dplyr::case_when(
        .data$host_species == "Homo sapiens" ~ "human",
        !is_blank(.data$host_species) ~ "animal",
        TRUE ~ NA_character_
      )
    )

  # Cleanup helpers
  genome_metadata <- genome_metadata %>%
    dplyr::select(-dplyr::any_of(c(".common_guess",".binom_guess","host_text")))

  return(genome_metadata)
}
```


### Normalize country and infer continent
```{r normalize_country}
# Normalize country names and assign continents
normalize_country_fields <- function(genome_metadata) {
  if (is.null(genome_metadata)) return(NULL)

  # Be explicit about packages used
  # library(dplyr); library(stringr); library(countrycode)

  # 1) Simplify country strings like "Country: region"
  genome_metadata <- genome_metadata %>%
    dplyr::mutate(
      country_simple = stringr::str_trim(
        stringr::str_split_fixed(dplyr::coalesce(.data$country, ""), ":", 2)[, 1]
      ),
      country_simple = dplyr::na_if(.data$country_simple, "")
    )

  # 2) Normalization map for common ENA/NCBI variants (patterns in lower-case)
  country_map <- c(
    "usa" = "United States", "u\\.s\\." = "United States",
    "u\\.s\\.a\\." = "United States", "united states of america" = "United States",
    "uk" = "United Kingdom", "u\\.k\\." = "United Kingdom",
    "great britain" = "United Kingdom", "england" = "United Kingdom",
    "scotland" = "United Kingdom", "wales" = "United Kingdom",
    "northern ireland" = "United Kingdom",
    "korea,? republic of" = "South Korea", "republic of korea" = "South Korea",
    "south korea" = "South Korea", "korea,? \\(south\\)" = "South Korea",
    "pr china" = "China", "p\\.r\\. china" = "China",
    "russian federation" = "Russia", "czech republic" = "Czechia",
    "swaziland" = "Eswatini", "cote d['’]ivoire" = "Côte d’Ivoire",
    "democratic republic of the congo" = "DR Congo",
    "viet nam" = "Vietnam", "myanmar \\(burma\\)" = "Myanmar",
    "bolivia \\(plurinational state of\\)" = "Bolivia",
    "iran,? islamic republic of" = "Iran",
    "syrian arab republic" = "Syria",
    "moldova,? republic of" = "Moldova",
    "lao people'?s democratic republic" = "Laos",
    "macedonia,? the former yugoslav republic of" = "North Macedonia",
    "palestine,? state of" = "Palestine",
    "hong kong" = "Hong Kong",
    "macau|macao" = "Macau"
  )

  normalize_country <- function(x) {
    # Always return character
    y <- stringr::str_trim(tolower(dplyr::coalesce(as.character(x), "")))
    y[y == ""] <- NA_character_

    if (length(y)) {
      for (pat in names(country_map)) {
        repl <- country_map[[pat]]
        # Use ^...$ to only replace whole-string matches after lowercasing
        y <- ifelse(!is.na(y),
                    stringr::str_replace_all(y, paste0("^", pat, "$"), repl),
                    y)
      }
      # Minor tidy-ups
      y <- ifelse(!is.na(y), stringr::str_replace_all(y, "\\s+", " "), y)
      y <- ifelse(y == "people's republic of china", "China", y)

      # Title-case anything still not mapped
      y <- ifelse(!is.na(y), stringr::str_to_title(y), y)
    }
    return(as.character(y))
  }

  # 3) Produce normalized country + continent (force character vector into countrycode)
  genome_metadata <- genome_metadata %>%
    dplyr::mutate(
      country_normalized = normalize_country(.data$country_simple),
      continent = countrycode::countrycode(
        sourcevar    = as.character(.data$country_normalized),
        origin       = "country.name",
        destination  = "continent",
        warn         = FALSE
      )
    )

  return(genome_metadata)
}
```


### Filter species that don't belong and remove duplicate MAGs
```{r filtering_deduplication}
# Remove non-species MAGs and deduplicate genomes by quality,
#  merge GCA/GCF duplicates (keep GCF; merge metadata).

filter_species_MAGs <- function(genome_metadata,
                                genome_annotations,
                                mags_to_remove,
                                match_on_version = TRUE) {
  if (is.null(genome_metadata) || is.null(genome_annotations)) {
    stop("Both genome_metadata and genome_annotations must be provided.")
  }

  # ---------------------------
  # Helpers
  # ---------------------------

  # Remove extensions and directories
  clean_label <- function(x) {
    x <- basename(x)
    sub("\\.(fna|fa|fasta)(\\.gz)?$", "", x, ignore.case = TRUE)
  }
  
  # clean genome IDs so RS_/GB_ prefixes are removed
  clean_accession <- function(x) {
  x <- basename(x)
  x <- sub("\\.(fna|fa|fasta)(\\.gz)?$", "", x, ignore.case = TRUE)
  x <- sub("^(RS_|GB_)", "", x, perl = TRUE)
  x
}

  # Extract (GCA|GCF) and numeric core (e.g., 015667075.1) from an ID
  # Handles optional GB_/RS_ prefixes; returns NA when not matching.
  extract_accession_fields <- function(id_vec, match_on_version = TRUE) {
    id_vec <- clean_label(id_vec)
    core_re <- if (match_on_version) "(\\d+(?:\\.\\d+)?)" else "(\\d+)"
    pat <- paste0("^(?:GB_|RS_)?(GC[AF])_", core_re, "$")

    matched <- grepl(pat, id_vec, perl = TRUE)
    acc_type <- ifelse(matched, sub(pat, "\\1", id_vec, perl = TRUE), NA_character_)
    acc_core <- ifelse(matched, sub(pat, "\\2", id_vec, perl = TRUE), NA_character_)

    data.frame(acc_type = acc_type, acc_core = acc_core, stringsAsFactors = FALSE)
  }

  # First non-NA helper (after we normalize empty "" to NA for characters)
  first_non_na <- function(x) {
    idx <- which(!is.na(x))
    if (length(idx)) x[idx[1]] else NA
  }

  # Normalize empty strings to NA for character columns
  na_if_empty_chars <- function(df) {
    df %>%
      mutate(across(where(is.character), ~ na_if(., "")))
  }

  # ---------------------------
  # Standardize removal list
  # ---------------------------
  mags_to_remove_clean <- clean_label(mags_to_remove)

  # ---------------------------
  # 1) Preprocess genome_metadata
  # ---------------------------
  has_comp    <- "completeness"  %in% names(genome_metadata)
  has_cont    <- "contamination" %in% names(genome_metadata)
  has_contigs <- "contigs"       %in% names(genome_metadata)

  gm0 <- genome_metadata %>%
    mutate(ID_clean = clean_accession(ID)) %>%
    # Make factors safe to merge
    mutate(across(where(is.factor), as.character)) %>%
    na_if_empty_chars()

  # Remove wrong-species MAGs
  gm0 <- gm0 %>%
    filter(!ID_clean %in% mags_to_remove_clean)

  # Add accession parse fields
  acc <- extract_accession_fields(gm0$ID_clean, match_on_version = match_on_version)
  gm1 <- gm0 %>%
    mutate(acc_type = acc$acc_type,
           acc_core = acc$acc_core)

  # Split into accessioned (GCA/GCF) and other IDs
  gm_acc  <- gm1 %>% filter(!is.na(acc_core))
  gm_other <- gm1 %>% filter(is.na(acc_core))

  # For ordering by quality
  gm_acc <- gm_acc %>%
    mutate(
      completeness  = if (has_comp)    suppressWarnings(as.numeric(completeness))  else NA_real_,
      contamination = if (has_cont)    suppressWarnings(as.numeric(contamination)) else NA_real_,
      contigs       = if (has_contigs) suppressWarnings(as.numeric(contigs))       else NA_real_
    )

  # Collapse GCA/GCF duplicates by acc_core:
  # - Prefer GCF over GCA if present
  # - Within type, prefer higher completeness, lower contamination, fewer contigs
  # - Per column, take first non-NA after ordering (merges metadata)
  gm_acc_collapsed <- gm_acc %>%
    group_by(acc_core) %>%
    group_modify(function(df, key) {
      # Prefer GCF if present
      prefer_gcf <- any(df$acc_type == "GCF")
      pref_rank <- if (prefer_gcf) ifelse(df$acc_type == "GCF", 0L, 1L) else 0L

      # Order rows by (preference, quality)
      ord <- order(
        pref_rank,
        -ifelse(is.na(df$completeness), -Inf, df$completeness),
        ifelse(is.na(df$contamination), Inf, df$contamination),
        ifelse(is.na(df$contigs), Inf, df$contigs),
        na.last = TRUE
      )
      dfo <- df[ord, , drop = FALSE]

      # Summarize to one row by taking first non-NA per column
      # (ID will become the preferred row's ID; metadata merged)
      out <- dfo %>%
        summarise(across(everything(), first_non_na), .groups = "drop")

      out
    }) %>%
    ungroup()

  # For non-accessioned rows: fall back to your quality-based dedup by ID_clean
  if (nrow(gm_other) > 0) {
    gm_other <- gm_other %>%
      mutate(
        completeness  = if (has_comp)    suppressWarnings(as.numeric(completeness))  else NA_real_,
        contamination = if (has_cont)    suppressWarnings(as.numeric(contamination)) else NA_real_,
        contigs       = if (has_contigs) suppressWarnings(as.numeric(contigs))       else NA_real_
      ) %>%
      arrange(
        ID_clean,
        desc(if (has_comp) completeness else 0),
        (if (has_cont) contamination else 0),
        (if (has_contigs) contigs else Inf)
      ) %>%
      distinct(ID_clean, .keep_all = TRUE)
  }

  # Combine collapsed accessioned rows and deduped others
  genome_metadata_dedup <- bind_rows(gm_acc_collapsed, gm_other) %>%
    # Drop temp fields
    dplyr::select(-acc_type, -acc_core)

  # ---------------------------
  # 2) Filter genome_annotations to match remaining genomes
  # ---------------------------

  ga0 <- genome_annotations %>%
    mutate(genome_clean = clean_accession(genome))

  # Remove wrong-species MAGs
  genome_annotations_filtered <- ga0 %>%
    filter(!genome_clean %in% mags_to_remove_clean)

  # Keep only genomes still present in metadata (after GCF/GCA merge)
  valid_genomes <- genome_metadata_dedup$ID_clean

  genome_annotations_filtered <- genome_annotations_filtered %>%
    filter(genome_clean %in% valid_genomes) %>%
    dplyr::select(-genome_clean)

  # ---------------------------
  # 3) Return cleaned objects
  # ---------------------------
  list(
    metadata    = genome_metadata_dedup,
    annotations = genome_annotations_filtered
  )
}
```


### Process one species
```{r process_one_species}
process_one_species <- function(species, mags_to_remove = character(0)) {
  files <- load_species_files(species)

  ehi  <- prep_ehi_metadata(files$ehi_metadata)
  gtdb <- prep_gtdb_final(files$gtdb_final)
  ncbi <- prep_ncbi_metadata(files$ncbi_metadata)

  meta <- combine_metadata_sources(ehi, gtdb, ncbi) %>%
    infer_host_metadata() %>%
    normalize_country_fields()   

  if (is.null(files$contig_map) || is.null(files$gene_annotations)) {
    warning(sprintf(
      "[%s] Missing %s; returning metadata only.",
      species,
      if (is.null(files$contig_map) && is.null(files$gene_annotations)) "contig_map and gene_annotations"
      else if (is.null(files$contig_map)) "contig_map"
      else "gene_annotations"
    ))
    return(list(metadata = meta, annotations = NULL))
  }

  ann <- prep_gene_annotations_with_genome(
    ann_raw        = files$gene_annotations,
    contig_map_raw = files$contig_map
  )

  cleaned <- filter_species_MAGs(
    genome_metadata    = meta,
    genome_annotations = ann,
    mags_to_remove     = mags_to_remove
  )

  cleaned
}
  
```

```{r COME BACK}
# sp <- "lactococcus_lactis"
# res <- process_one_species(sp)
# 
# genome_metadata <- res$metadata
# 
# write_tsv(genome_metadata, "data/mags_metadata/lactococcus_lactis_FINAL_metadata.tsv")
```



## DREP ANALYSIS

### Recreating the drep tree
Checking for outliers 

```{r recreate_drep_tree}
## Function to recreate the drep tree from the secondary alignment (FASTANI)

recreate_drep_tree <- function(ndb){
  genomes <- unique(c(ndb$reference, ndb$querry))

# Create empty matrix
ani_matrix <- matrix(0, nrow = length(genomes), ncol = length(genomes))
rownames(ani_matrix) <- genomes
colnames(ani_matrix) <- genomes

# Fill the matrix
for(i in 1:nrow(ndb)) {
  ref <- ndb$reference[i]
  qry <- ndb$querry[i]
  ani_val <- ndb$ani[i]
  
  ani_matrix[ref, qry] <- ani_val
  ani_matrix[qry, ref] <- ani_val  # Make symmetric
}

# Set diagonal to 100
diag(ani_matrix) <- 100

# Convert to distance matrix (for tree building)
dist_matrix <- as.dist(1 - ani_matrix)

# Build tree
hc <- hclust(dist_matrix, method = "average") #drep uses hierarchical clustering
tree <- as.phylo(hc)

ggtree(tree) + 
  geom_tiplab(size = 2) +
  theme_tree2()
  
}
  
  

```


```{r drep_tree_test, fig.height = 10, fig.width = 12}
ndb <- read_csv("data/mags_metadata/phocaeicola_vulgatus_Ndb.csv") 
recreate_drep_tree(ndb)
```


### Drep final tree, matrix and plots
```{r drep_tree_metadata}
# --- Helpers ------------------------------------------------------------------

# Strip file extensions so IDs match metadata
clean_label <- function(x) {
  x <- basename(x)
  sub("\\.(fna|fa|fasta)(\\.gz)?$", "", x, ignore.case = TRUE)
}

# Parse accessions allowing optional external prefixes like RS_ or GB_ (possibly multiple),
# followed by GCA|GCF, digits (with leading zeros), and optional .version
# Returns: ext_prefix (may be ""), base_prefix (GCA/GCF), digits (with zeros),
#          core (numeric, no zeros), version (integer or NA)
parse_accession <- function(x) {
  x_clean <- clean_label(x)
 
  re <- "^((?:[A-Za-z0-9]+_)*)(GCA|GCF)_([0-9]+)(?:\\.([0-9]+))?$"
  m <- regexec(re, x_clean, ignore.case = FALSE)
  parts <- regmatches(x_clean, m)

  out <- lapply(parts, function(p) {
    if (length(p) == 0) {
      return(list(
        ext_prefix  = NA_character_,
        base_prefix = NA_character_,
        digits      = NA_character_,
        core        = NA_integer_,
        version     = NA_integer_
      ))
    }
    ext_prefix  <- p[2]
    base_prefix <- p[3]
    digits      <- p[4]
    version     <- if (!is.na(p[5])) as.integer(p[5]) else NA_integer_
    core        <- suppressWarnings(as.integer(sub("^0+", "", digits)))
    if (is.na(core)) core <- 0L  # for a string of zeros (rare), keep a numeric
    list(
      ext_prefix  = ext_prefix,
      base_prefix = base_prefix,
      digits      = digits,
      core        = core,
      version     = version
    )
  })

  tibble::tibble(
    ext_prefix  = vapply(out, `[[`, character(1), "ext_prefix"),
    base_prefix = vapply(out, `[[`, character(1), "base_prefix"),
    digits      = vapply(out, `[[`, character(1), "digits"),
    core        = vapply(out, `[[`, integer(1),   "core"),
    version     = vapply(out, `[[`, integer(1),   "version")
  )
}

# Canonical grouping key:
# If accession-like, group by numeric core (ignores external prefixes and leading zeros).
# Else, group by the cleaned label itself.
canonical_key <- function(x) {
  x_clean <- clean_label(x)
  acc <- parse_accession(x_clean)
  ifelse(!is.na(acc$core), paste0("ACC_CORE_", acc$core), x_clean)
}

# Build a normalized label with *no* external prefix by default.
# You can flip `keep_external_prefix = TRUE` if you want to preserve RS_/GB_/... in outputs.
build_normalized_label <- function(base_prefix, digits, version, ext_prefix = "", keep_external_prefix = FALSE) {
  core_part <- paste0(base_prefix, "_", digits)
  if (!is.na(version) && version > 0) {
    core_part <- paste0(core_part, ".", version)
  }
  if (keep_external_prefix && nzchar(ext_prefix)) {
    paste0(ext_prefix, core_part)
  } else {
    core_part
  }
}

# Within a set of labels sharing the same canonical key, choose the representative:
# Priority:
#   1) Prefer base_prefix == "GCF"
#   2) Higher version number
#   3) Longer digits (padding tends to follow RefSeq style); then lexicographic for stability
# Output: normalized label (no external prefix by default).
choose_preferred_label <- function(labels, keep_external_prefix = FALSE) {
  labs <- clean_label(labels)
  acc  <- parse_accession(labs)
  is_acc <- !is.na(acc$base_prefix)

  if (any(is_acc)) {
    df <- tibble::tibble(
      lab          = labs,
      ext_prefix   = acc$ext_prefix,
      base_prefix  = acc$base_prefix,
      digits       = acc$digits,
      core         = acc$core,
      version      = acc$version
    )
    df$version[is.na(df$version)] <- 0L

    ord <- order(
      !(df$base_prefix == "GCF"),         # GCF first
      -df$version,                        # higher version
      -nchar(df$digits),                  # longer digits (keeps zero padding if present)
      df$lab                              # stable tie-breaker
    )
    df <- df[ord, , drop = FALSE]

    # Build normalized label for the top candidate; drop external prefix by default
    return(build_normalized_label(
      base_prefix = df$base_prefix[1],
      digits      = df$digits[1],
      version     = df$version[1],
      ext_prefix  = df$ext_prefix[1],
      keep_external_prefix = keep_external_prefix
    ))
  } else {
    # No accession-like labels; just pick a stable representative
    return(sort(unique(labs))[1])
  }
}

# Build a label rewrite map so that all labels in the same canonical group map to one preferred label
build_label_map <- function(labels, keep_external_prefix = FALSE) {
  labs <- unique(clean_label(labels))
  keys <- canonical_key(labs)
  grp  <- split(labs, keys)
  pref <- vapply(grp, choose_preferred_label, character(1), keep_external_prefix = keep_external_prefix)
  from <- unlist(grp, use.names = FALSE)
  to   <- rep(pref[names(grp)], lengths(grp))
  tibble::tibble(from = from, to = to)
}

# --- Main ---------------------------------------------------------------------

drep_tree_metadata <- function(genome_metadata = genome_metadata,
                               ndb = ndb,
                               drop_ids = character(0),
                               keep_external_prefix = FALSE) {
  metadata <- genome_metadata
  id_col   <- "ID"

  # Start from ndb edges
  fastani <- ndb %>%
    dplyr::select(reference, querry, ani) %>%  # fully-qualified per your preference
    dplyr::filter(!is.na(reference), !is.na(querry), reference != querry) %>%
    dplyr::mutate(
      reference = clean_label(reference),
      querry    = clean_label(querry)
    ) %>%
    dplyr::filter(reference != querry)

  # Collect all labels we may see anywhere (pairs + metadata IDs)
  all_labels <- unique(c(
    fastani$reference,
    fastani$querry,
    clean_label(metadata[[id_col]])
  ))

  # Build rewrite map: GCA/GCF with the same core collapse to one preferred label (GCF > GCA; higher version wins).
  # External prefixes (RS_/GB_/...) are dropped by default in outputs.
  lab_map <- build_label_map(all_labels, keep_external_prefix = keep_external_prefix)

  # Helper to rewrite vectors using a named map
  rewrite_labels <- function(x) {
    x_clean <- clean_label(x)
    map_vec <- stats::setNames(lab_map$to, lab_map$from)
    m <- map_vec[x_clean]
    x_clean[!is.na(m)] <- m[!is.na(m)]
    x_clean
  }

  # Rewrite reference/querry and collapse pair duplicates by taking max ANI
  fastani <- fastani %>%
    dplyr::mutate(
      reference = rewrite_labels(reference),
      querry    = rewrite_labels(querry)
    ) %>%
    dplyr::filter(reference != querry) %>%
    dplyr::group_by(reference, querry) %>%
    dplyr::summarise(ani = max(ani), .groups = "drop")

  # Optionally drop genomes (use rewritten IDs so the drop matches what will appear in the tree)
  if (length(drop_ids) > 0) {
    drop_ids2 <- rewrite_labels(drop_ids)
    fastani <- fastani %>%
      dplyr::filter(!reference %in% drop_ids2, !querry %in% drop_ids2)
  }

  # Build a symmetric ANI matrix with diag = 1
  genomes <- sort(unique(c(fastani$reference, fastani$querry)))

  both <- dplyr::bind_rows(
    fastani %>% dplyr::transmute(reference, querry, ani),
    fastani %>% dplyr::transmute(reference = querry, querry = reference, ani)
  ) %>%
    dplyr::distinct(reference, querry, .keep_all = TRUE)

  ani_mat <- both %>%
    tidyr::complete(reference = genomes, querry = genomes) %>%
    tidyr::pivot_wider(
      names_from  = querry,
      values_from = ani,
      values_fn   = max
    ) %>%
    tibble::column_to_rownames("reference") %>%
    as.matrix()

  diag(ani_mat) <- 1

  # Build the tree (UPGMA/average as in dRep)
  dist_mat <- 1 - ani_mat
  hc <- hclust(as.dist(dist_mat), method = "average")
  tree <- ape::as.phylo(hc)

  # Deduplicate & rewrite metadata IDs with the same map so labels match the tree tips
  metadata_dedup <- metadata %>%
    dplyr::mutate(!!id_col := rewrite_labels(.data[[id_col]])) %>%
    dplyr::distinct(.data[[id_col]], .keep_all = TRUE)

  stopifnot(id_col %in% names(metadata_dedup))

  tip_df <- tibble::tibble(label = tree$tip.label) %>%
    dplyr::left_join(metadata_dedup, by = setNames(id_col, "label")) %>%
    dplyr::mutate(label_clean = label)

  return(list(
    tree = tree,
    tip_df = tip_df,
    ani_matrix = ani_mat
  ))
}

  

####-----------------------------------------------------------------------------------------

# Helper for ANI axis labels (unchanged)
ani_axis <- function(p, tree, show_threshold = NULL) {
  df <- ggtree::fortify(tree)
  max_x <- max(df$x[df$isTip])
  p <- p +
    scale_x_continuous(
      labels = function(x) round(100 * (1 - (max_x - x)), 1)
    ) +
    coord_cartesian(xlim = c(0, max_x + 0.005)) +
    labs(x = "Average Nucleotide Identity (ANI, %)") +
    theme_tree2()
  if (!is.null(show_threshold)) {
    thr_delta <- 1 - (show_threshold / 100)
    p <- p + geom_vline(xintercept = max_x - thr_delta,
                        linetype = "dashed", color = "red", size = 0.8)
  }
  p
}


### --------------PLOTS ----------------------------------------
# - BASIC PLOT --
plot_tree_basic <- function(tree, tip_df, color_by = NULL, label_tips = TRUE,
                            point_size = 2.5, show_threshold = NULL) {
  # ensure completeness numeric for continuous gradients
  if ("completeness" %in% names(tip_df)) {
    tip_df <- tip_df %>% dplyr::mutate(completeness = as.numeric(completeness))
  }

  p <- ggtree(tree, size = 0.8)
  p <- p %<+% tip_df

  if (!is.null(color_by) && color_by %in% names(tip_df)) {
    p <- p + geom_tippoint(aes(color = !!rlang::sym(color_by)), size = point_size)

    # Palette/scale logic
    if (identical(color_by, "source") && exists("source_colors")) {
      p <- p + scale_color_manual(values = source_colors, name = "Source", drop = FALSE)
    } else if (identical(color_by, "host_order") && exists("host_order_colors")) {
      p <- p + scale_color_manual(values = host_order_colors, name = "Host order", drop = FALSE)
    } else if (is.numeric(tip_df[[color_by]])) {
      p <- p + scale_color_gradient(low = "white", high = "#08306B",
                                    name = paste0(color_by, " (%)"))
    }
  } else {
    p <- p + geom_tippoint(size = point_size)
  }

  if (label_tips) {
    lab_col <- if ("label_clean" %in% names(tip_df)) "label_clean" else "label"
    p <- p + geom_tiplab(size = 3, hjust = -0.1, aes(label = .data[[lab_col]]))
  }

  ani_axis(p, tree, show_threshold = show_threshold)
}

```


```{r checking tree}
sp <- "phocaeicola_vulgatus"
res <- process_one_species(sp)

genome_metadata <- res$metadata
```
```{r testing phocaeicola, fig.height= 14, fig.width = 10}
phocaeicola_results <- drep_tree_metadata(genome_metadata, ndb, drop_ids = c("GCA_040912025.1", "GCF_048453085.1", "GCA_048453085.1"))

tree <- phocaeicola_results$tree
tip_df <- phocaeicola_results$tip_df
ani_matrix <- phocaeicola_results$ani_matrix


p_host_order <- plot_tree_basic(tree, tip_df, color_by = "host_order",
                          label_tips = TRUE, show_threshold = 99.5)
p_host_order

```

### PERMANOVA, PcoA

```{r functions for drep analysis}
#-------------1) Filter out unkown host type ------------------
filter_metadata <- function(tip_df) {
  tip_df %>%
    dplyr::filter(!is.na(host_type) & host_type != "")
}

#-------------2) Subset and align (same order) ------------------
subset_and_align_ani <- function(ani_matrix, meta_df) {
  keep_ids <- intersect(rownames(ani_matrix), meta_df$label)
  
  ani_mat_f <- ani_matrix[keep_ids, keep_ids, drop = FALSE]
  
  meta_f <- meta_df %>%
    dplyr::filter(label %in% keep_ids) %>%
    dplyr::arrange(match(label, rownames(ani_mat_f)))
  
  stopifnot(identical(meta_f$label, rownames(ani_mat_f)))
  
  list(ani = ani_mat_f, meta = meta_f)
}

#-------------3) Run PERMANOVA ------------------
run_permanova <- function(dist_mat, meta_f) {
  set.seed(1)
  ad <- vegan::adonis2(dist_mat ~ host_type, data = meta_f, permutations = 999)
  bd <- vegan::betadisper(dist_mat, meta_f$host_type)
  list(adonis = ad, dispersion = anova(bd))
}

#-------------4) Run PCOA ------------------
run_pcoa <- function(dist_mat, meta_f) {
  pcoa_res <- ape::pcoa(dist_mat)
  data.frame(
    PC1 = pcoa_res$vectors[, 1],
    PC2 = pcoa_res$vectors[, 2],
    host_type = meta_f$host_type,
    host_order = meta_f$host_order
  )
}

#-------------5) Plots PCOA ------------------
plot_pcoa_host_type <- function(pcoa_df, host_type_colors) {
  ggplot2::ggplot(pcoa_df, ggplot2::aes(PC1, PC2, color = host_type)) +
    ggplot2::geom_point(size = 2, alpha = 0.9) +
    ggplot2::scale_color_manual(values = host_type_colors, name = "Host type") +
    ggplot2::theme_minimal(base_size = 12) +
    ggplot2::labs(title = "PCoA of ANI distances (filtered to known host_type)")
}

plot_pcoa_host_order <- function(pcoa_df, host_order_colors) {
  ggplot2::ggplot(pcoa_df, ggplot2::aes(PC1, PC2, color = host_order)) +
    ggplot2::geom_point(size = 2, alpha = 0.9) +
    ggplot2::scale_color_manual(values = host_order_colors, name = "Host order") +
    ggplot2::theme_minimal(base_size = 12) +
    ggplot2::labs(title = "PCoA of ANI distances")
}

#-------------5) Pairwise ANI ------------------
pairwise_ani <- function(ani_mat_f, meta_f) {
  ani_mat_f %>%
    as.data.frame() %>%
    tibble::rownames_to_column("ref") %>%
    tidyr::pivot_longer(-ref, names_to = "qry", values_to = "ani") %>%
    dplyr::filter(ref < qry) %>%  # unique pairs
    dplyr::mutate(
      ref_host = meta_f$host_type[match(ref, meta_f$label)],
      qry_host = meta_f$host_type[match(qry, meta_f$label)],
      pair_type = dplyr::case_when(
        ref_host == "human"  & qry_host == "human"  ~ "human–human",
        ref_host == "animal" & qry_host == "animal" ~ "animal–animal",
        TRUE ~ "animal–human"
      )
    )
}


#-------------6) Plot pairwise ANI boxplot ------------------
plot_pairwise_boxplot <- function(ani_long_f) {
  ggplot2::ggplot(ani_long_f, ggplot2::aes(pair_type, ani, fill = pair_type)) +
    ggplot2::geom_boxplot(outlier_size = 0.5, width = 0.7) +
    ggplot2::scale_fill_viridis_d(guide = "none") +
    ggplot2::theme_minimal(base_size = 12) +
    ggplot2::labs(x = NULL, y = "ANI", title = "Within- and between-group ANI (known host_type only)")
}


#-------------7) Wilcoxon tests ------------------
wilcox_within <- function(ani_long_f) {
  subset_within <- ani_long_f %>%
    dplyr::filter(pair_type %in% c("animal–animal", "human–human"))

  wt <- stats::wilcox.test(ani ~ pair_type, data = subset_within, exact = FALSE)

  summary_df <- subset_within %>%
    dplyr::group_by(pair_type) %>%
    dplyr::summarise(n = dplyr::n(), median_ani = stats::median(ani), .groups = "drop")

  list(test = wt, summary = summary_df)
}

wilcox_cross_vs_within <- function(ani_long_f) {
  # Compare cross-host to pooled within (animal–animal + human–human)
  df <- ani_long_f %>%
    dplyr::mutate(is_cross = ifelse(pair_type == "animal–human", "cross", "within"))

  wt <- stats::wilcox.test(ani ~ is_cross, data = df, exact = FALSE, alternative = "less")
  # 'less' tests if cross < within (lower ANI between hosts)

  summary_df <- df %>%
    dplyr::group_by(is_cross) %>%
    dplyr::summarise(n = dplyr::n(), median_ani = stats::median(ani), .groups = "drop")

  list(test = wt, summary = summary_df)
}



#----------------------------------------------------#

#-------------- DREP STATS ANALYSIS ------------------
# combines the functions above into a big one


drep_stat_analysis <- function(tip_df, ani_matrix, host_type_colors, host_order_colors) {
  tip_df_f <- tip_df %>%
    dplyr::filter(!is.na(host_type) & host_type != "")

  aligned <- subset_and_align_ani(ani_matrix, tip_df_f)
  ani_mat_f <- aligned$ani
  meta_f <- aligned$meta

  if (is.factor(meta_f$host_type)) meta_f$host_type <- droplevels(meta_f$host_type)

  dist_mat_f <- stats::as.dist(1 - ani_mat_f)

  permanova_results <- run_permanova(dist_mat_f, meta_f)

  pcoa_df <- run_pcoa(dist_mat_f, meta_f)
  pcoa_host_type_plot <- plot_pcoa_host_type(pcoa_df, host_type_colors)
  pcoa_host_order_plot <- plot_pcoa_host_order(pcoa_df, host_order_colors)

  ani_long_f <- pairwise_ani(ani_mat_f, meta_f)
  boxplot_pairs <- plot_pairwise_boxplot(ani_long_f)

  w_within <- wilcox_within(ani_long_f)
  w_cross  <- wilcox_cross_vs_within(ani_long_f)

  list(
    filtered_metadata = meta_f,
    ani = ani_mat_f,
    dist = dist_mat_f,
    permanova = permanova_results,
    pcoa = list(data = pcoa_df,
                by_host_type = pcoa_host_type_plot,
                by_host_order = pcoa_host_order_plot),
    pairwise = list(data = ani_long_f,
                    boxplot = boxplot_pairs,
                    wilcox_within = w_within,
                    wilcox_cross_vs_within = w_cross)
  )
}
```


```{r testing drep_stat_analysis function}
res <- drep_stat_analysis(
  tip_df = tip_df,
  ani_matrix = ani_matrix,
  host_type_colors = host_type_colors,
  host_order_colors = host_order_colors
)

# Print stats
res$permanova$adonis
res$permanova$dispersion
res$pairwise$wilcox_within$test
res$pairwise$wilcox_cross_vs_within$test

# Plot
print(res$pcoa$by_host_type)
print(res$pcoa$by_host_order)
print(res$pairwise$boxplot)

# Save plots:
# ggplot2::ggsave("pcoa_host_type.png", res$pcoa$by_host_type, width = 6, height = 5, dpi = 300)


```

## FUNCTIONAL ANALYSIS: KEGG, AMR, VF, CAZY, DEFENSE, GIFTS
### Create annotation matrices
```{r make_annotation_matrices}
#testing with hafnia
sp <- "citrobacter_braakii"
res <- process_one_species(sp)

hp <- res$metadata
genome_annotations <- res$annotations
genome_metadata <- hp



make_annotation_matrix <- function(genome_annotations, column) {
  genome_annotations %>%
    filter(!is.na(.data[[column]])) %>%
    count(genome, annotation = .data[[column]]) %>%
    tidyr::pivot_wider(
      names_from = annotation,
      values_from = n,
      values_fill = 0
    )
}


#testing
kegg_mat <- make_annotation_matrix(genome_annotations, "kegg")
amr_mat  <- make_annotation_matrix(genome_annotations, "resistance_target")
vf_mat   <- make_annotation_matrix(genome_annotations, "vf")
```

### Run Fisher tests on proportions
```{r fisher}
run_fisher_tests <- function(mat, metadata, annotation_name = "feature") {
  # mat: wide matrix with columns: genome, <annotation columns...>
  # metadata: data frame with columns ID, host_type
  # annotation_name: name for the long column (e.g., "kegg", "amr")

  # checks
  if (!"genome" %in% names(mat)) {
    stop("Input 'mat' must contain a 'genome' column.")
  }
  if (!all(c("ID_clean", "host_type") %in% names(metadata))) {
    stop("Input 'metadata' must contain columns 'ID_clean' and 'host_type'.")
  }

  # Presence/absence conversion (keep genome as-is; non-NA and non-zero -> 1 else 0)
  pa <- mat %>%
    dplyr::mutate(
      dplyr::across(
        -genome,
        ~ as.integer(!is.na(.) & . != 0)
      )
    )

  # Wide -> long
  pa_long <- pa %>%
    tidyr::pivot_longer(
      cols = -genome,
      names_to = annotation_name,   # creates a column with this exact name
      values_to = "present"
    ) %>%
    dplyr::filter(present == 1L) %>%
    dplyr::select(genome, dplyr::all_of(annotation_name)) %>%  # keep genome + annotation
    dplyr::distinct()

  # Attach host_type
  pa_with_host <- pa_long %>%
    dplyr::left_join(
      metadata %>% dplyr::select(ID_clean, host_type),
      by = c("genome" = "ID_clean")
    )

  # Count how many MAGs present in each annotation by host_type
  pa_mag_counts <- pa_with_host %>%
    dplyr::group_by(host_type, .data[[annotation_name]]) %>%
    dplyr::summarise(n_mags = dplyr::n(), .groups = "drop")

  # Totals per host_type (denominator)
  total_mags_per_host_type <- metadata %>%
    dplyr::group_by(host_type) %>%
    dplyr::summarise(total_mags = dplyr::n_distinct(ID_clean), .groups = "drop")

  # Proportions + absences
  pa_mag_proportions <- pa_mag_counts %>%
    dplyr::left_join(total_mags_per_host_type, by = "host_type") %>%
    dplyr::mutate(
      proportion = n_mags / total_mags,
      absent     = total_mags - n_mags
    )

  # Build the wide counts matrix (animal vs human)
  pa_matrix <- pa_mag_proportions %>%
    dplyr::select(dplyr::all_of(annotation_name), host_type, n_mags, absent) %>%
    tidyr::pivot_wider(
      names_from  = host_type,
      values_from = c(n_mags, absent),
      values_fill = 0
    )

  # Sanity check for expected host groups (animal/human)
  required_cols <- c(
    annotation_name,
    "n_mags_animal", "absent_animal",
    "n_mags_human",  "absent_human"
  )
  if (!all(required_cols %in% names(pa_matrix))) {
    stop(
      "Expected columns missing in pa_matrix: ",
      paste(setdiff(required_cols, names(pa_matrix)), collapse = ", "),
      "\nCheck that metadata$host_type contains 'animal' and 'human' and that both have genomes."
    )
  }

  # Fisher exact test per row (2x2)
  results <- pa_matrix %>%
    dplyr::rowwise() %>%
    dplyr::mutate(
      ft = list(stats::fisher.test(
        matrix(
          c(n_mags_animal, absent_animal,
            n_mags_human,  absent_human),
          nrow = 2, byrow = TRUE
        )
      )),
      p_value    = ft$p.value,
      odds_ratio = unname(ft$estimate),
      log2_or = log2(odds_ratio),
      conf_low   = ft$conf.int[1],
      conf_high  = ft$conf.int[2]
    ) %>%
    dplyr::ungroup() %>%
    dplyr::select(-ft) %>%
    dplyr::mutate(
      p_adj       = stats::p.adjust(p_value, method = "BH"),
      prop_animal = n_mags_animal / (n_mags_animal + absent_animal),
      prop_human  = n_mags_human  / (n_mags_human  + absent_human),
      diff_prop   = prop_human - prop_animal
    )

  return(results)
}
```


```{r testing running fisher tests}
kegg_fisher <- run_fisher_tests(kegg_mat, genome_metadata, annotation_name="kegg")
amr_fisher <- run_fisher_tests(amr_mat, genome_metadata, annotation_name="amr")
```

### Volcano plot
```{r plotting volcano plot}
plot_volcano <- function(df, feature_col) {
  df %>%
    mutate(
      p_adj_capped = pmax(p_adj, 1e-300),
      nl10 = -log10(p_adj_capped),
      sig = p_adj < 0.05
    ) %>%
    ggplot(aes(x = log2_or, y = nl10)) +
    geom_point(aes(color = sig), size = 2) +
    scale_color_manual(values = c("grey70", "blue")) +
    geom_hline(yintercept = -log10(0.05), linetype = "dashed") +
    ggrepel::geom_text_repel(
      data = . %>% filter(sig) %>% slice_max(nl10, n = 10),
      aes(label = .data[[feature_col]])
    ) +
    theme_minimal()
}

plot_volcano(kegg_fisher, "kegg")
plot_volcano(amr_fisher, "amr")

```
```{r pca_test}

run_pca <- function(mat) {
  m <- mat %>% column_to_rownames("genome")
  m <- m / rowSums(m)
  m <- m[, apply(m, 2, sd) > 0]
  
  prcomp(m, scale. = TRUE)
}

pca_kegg <- run_pca(kegg_mat)
pca_amr  <- run_pca(amr_mat)

```

### PERMANOVA on presence/absence matrix´
To check if the groups (animal vs human-sourced MAGs) have differences overall.

```{r permanova functional matrix}
pa_permanova <- function(mat, metadata) {
  mat <- mat %>%
  column_to_rownames("genome")

  pa <- (mat > 0) * 1

  
  # remove zero-variance KOs
  pa_nz <- pa[, colSums(pa) > 0 & colSums(pa) < nrow(pa)]
  
  # Determine the common genomes
  common_ids <- base::intersect(rownames(pa_nz), metadata$ID)
  
  # Report what will be kept/dropped
  message("# common: ", length(common_ids))
  message("# in KEGG only: ", length(setdiff(rownames(pa_nz), metadata$ID)))
  message("# in metadata only: ", length(setdiff(metadata$ID, rownames(pa_nz))))
  
  # Subset to the intersection (and keep order identical)
  pa_nz <- pa_nz[common_ids, , drop = FALSE]
  
  meta <- metadata %>%
    dplyr::filter(ID %in% common_ids) %>%
    dplyr::distinct(ID, .keep_all = TRUE) %>%
    tibble::column_to_rownames("ID") %>%
    .[common_ids, , drop = FALSE]
  
  stopifnot(identical(rownames(meta), rownames(pa_nz)))
  
  # Prepare variables for PERMANOVA
  required_vars <- c("genome_size", "completeness", "host_type")
  
  # Coerce types as needed
  meta <- meta %>%
    dplyr::mutate(
      genome_size  = as.numeric(genome_size),
      completeness = as.numeric(completeness),
      host_type    = as.factor(host_type)
    )
  
  # Align on complete cases (adonis2 drops NAs otherwise)
  ok <- stats::complete.cases(meta[, required_vars, drop = FALSE])
  pa_nz <- pa_nz[ok, , drop = FALSE]
  meta       <- meta[ok, , drop = FALSE]
  stopifnot(identical(rownames(meta), rownames(pa_nz)))
  
  # Remove genomes with no presence after filtering
  empty <- rowSums(pa_nz) == 0
  if (any(empty)) {
  message("Removing ", sum(empty), " empty genomes (all zeros).")
  pa_nz <- pa_nz[!empty, , drop = FALSE]
  meta  <- meta[!empty, , drop = FALSE]
}
  message("Remaining genomes: ", nrow(pa_nz))
  # Distance, dispersion, PERMANOVA
  dist_pa <- suppressWarnings(
  suppressMessages(
    vegan::vegdist(pa_nz, method = "jaccard", binary = TRUE)
  )
)

  betadisp_results <- suppressWarnings(
    suppressMessages(
      vegan::betadisper(dist_pa, meta$host_type)
    )
  )

  
  
 permanova_results <- vegan::adonis2(
    dist_pa ~ genome_size + completeness + host_type,
    data = meta,
    permutations = 999,
    by = "margin"
  )
 
 results <- list(
    dist           = dist_pa,
    betadisper     = betadisp_results,
    permanova      = permanova_results,
    pa_nz = pa_nz)
 
  return(results)
}

results <-pa_permanova(kegg_mat, genome_metadata)
results$permanova

```





<!--chapter:end:05_functions.Rmd-->



```{r tax_map}
 
  tax_map <- tibble::tibble(
  host_species = c(
    # Humans / lab / livestock / pets
    "Homo sapiens",
    "Mus musculus",
    "Rattus norvegicus",
    "Sus scrofa",
    "Bos taurus",
    "Canis lupus familiaris",
    "Equus caballus",
    "Oryctolagus cuniculus",
    "Capra hircus",

    # Birds
    "Gallus gallus",
    "Cathartes aura",
    "Columba livia",
    "Spheniscus magellanicus",

    # Insects
    "Drosophila melanogaster",
    "Bombyx mori",

    # Fish
    "Danio rerio",
    "Oncorhynchus mykiss",
    "Oreochromis niloticus",

    # Marine mammals / pinnipeds
    "Balaenoptera acutorostrata",
    "Arctocephalus australis",

    # Extinct
    "Mammuthus primigenius",
    
    #More
    "Loxodonta africana",
    "Elephas maximus",
    "Felis catus",
    "Canis lupus",
    "Phascolarctos cinereus",
    
    "Grasshopper",
    "Termite",
    "Macaca fascicularis",
    "Rhinolophus capensis",
    "Fish",
    
    #Final (from total_genome_metadata)
    "Zophobas morio",
    "Mustela putorius",
    "Ovis aries",
    "Corallus caninus",
    "Meles meles",
    "Clanga pomarina",
    "Buteo buteo",
    "Accipiter gentilis",
    "Chelonia mydas",
    "Grampus griseus",
    "Sterna trudeaui",
    "Rhodnius prolixus",
    "Turdus merula",
    "Curruca curruca",
    "Columba palumbus",
    "Delichon urbicum",
    "Chloris chloris",
    "Hirundo rustica",
    "Ciconia ciconia",
    "Anas platyrhynchos",
    "Grus grus",
    "Apis mellifera",
    "Coragyps atratus",
    "Pseudoscops clamator",
    "Pandion haliaetus",
    "Sycanus bifidus",
    "Eocanthecona furcellata",
    "Arma custos",
    "Corvus frugilegus",
    "Milvus milvus",
    "Vulpes zerda"


  ),
  tax_host_order = c(
    # Humans / lab / livestock / pets
    "Primates",
    "Rodentia",
    "Rodentia",
    "Artiodactyla",
    "Artiodactyla",
    "Carnivora",
    "Perissodactyla",
    "Lagomorpha",
    "Artiodactyla",

    # Birds
    "Galliformes",
    "Accipitriformes",
    "Columbiformes",
    "Sphenisciformes",

    # Insects
    "Diptera",
    "Lepidoptera",

    # Fish
    "Cypriniformes",
    "Salmoniformes",
    "Cichliformes",

    # Marine mammals / pinnipeds
    "Artiodactyla",      # (Cetartiodactyla)
    "Carnivora",

    # Extinct
    "Proboscidea",
    
    #More
    "Proboscidea",
    "Proboscidea",
    "Carnivora",
    "Carnivora",
    "Diprotodontia",
    
    
    "Orthoptera",     # Grasshopper
    "Blattodea",      # Termite (termites now placed within Blattodea; Isoptera as infraorder)
    "Primates",       # Macaca fascicularis
    "Chiroptera",     # Rhinolophus capensis (horseshoe bat)
    NA_character_,    # Fish (no single order fits all fish)
    
    #Final (from total_genome_metadata)
    "Coleoptera",          # Zophobas morio
    "Carnivora",           # Mustela putorius
    "Artiodactyla",        # Ovis aries
    "Squamata",            # Corallus caninus
    "Carnivora",           # Meles meles
    "Accipitriformes",     # Clanga pomarina
    "Accipitriformes",     # Buteo buteo
    "Accipitriformes",     # Accipiter gentilis
    "Testudines",          # Chelonia mydas
    "Artiodactyla",        # Grampus griseus
    "Charadriiformes",     # Sterna trudeaui
    "Hemiptera",           # Rhodnius prolixus
    "Passeriformes",       # Turdus merula
    "Passeriformes",       # Curruca curruca
    "Columbiformes",       # Columba palumbus
    "Passeriformes",       # Delichon urbicum
    "Passeriformes",       # Chloris chloris
    "Passeriformes",       # Hirundo rustica
    "Ciconiiformes",       # Ciconia ciconia
    "Anseriformes",        # Anas platyrhynchos
    "Gruiformes",          # Grus grus
    "Hymenoptera",         # Apis mellifera
    "Cathartiformes",      # Coragyps atratus
    "Strigiformes",        # Pseudoscops clamator
    "Accipitriformes",     # Pandion haliaetus
    "Hemiptera",           # Sycanus bifidus
    "Hemiptera",           # Eocanthecona furcellata
    "Hemiptera",           # Arma custos
    "Passeriformes",       # Corvus frugilegus
    "Accipitriformes",     # Milvus milvus
    "Carnivora"            # Vulpes zerda


  ),
  tax_host_class = c(
    # Humans / lab / livestock / pets
    "Mammalia",
    "Mammalia",
    "Mammalia",
    "Mammalia",
    "Mammalia",
    "Mammalia",
    "Mammalia",
    "Mammalia",
    "Mammalia",

    # Birds
    "Aves",
    "Aves",
    "Aves",
    "Aves",

    # Insects
    "Insecta",
    "Insecta",

    # Fish
    "Actinopterygii",
    "Actinopterygii",
    "Actinopterygii",

    # Marine mammals / pinnipeds
    "Mammalia",
    "Mammalia",

    # Extinct and more
    "Mammalia",
    "Mammalia",
    "Mammalia",
    "Mammalia",
    "Mammalia",
    "Mammalia",
    
        
    "Insecta",        # Grasshopper
    "Insecta",        # Termite
    "Mammalia",       # Macaca fascicularis
    "Mammalia",       # Rhinolophus capensis
    "Actinopterygii",  # Fish (bony fishes; safe default for generic "fish")

    #Final (from total_genome_metadata)
    "Insecta",        # Zophobas morio
    "Mammalia",       # Mustela putorius
    "Mammalia",       # Ovis aries
    "Reptilia",       # Corallus caninus
    "Mammalia",       # Meles meles
    "Aves",           # Clanga pomarina
    "Aves",           # Buteo buteo
    "Aves",           # Accipiter gentilis
    "Reptilia",       # Chelonia mydas
    "Mammalia",       # Grampus griseus
    "Aves",           # Sterna trudeaui
    "Insecta",        # Rhodnius prolixus
    "Aves",           # Turdus merula
    "Aves",           # Curruca curruca
    "Aves",           # Columba palumbus
    "Aves",           # Delichon urbicum
    "Aves",           # Chloris chloris
    "Aves",           # Hirundo rustica
    "Aves",           # Ciconia ciconia
    "Aves",           # Anas platyrhynchos
    "Aves",           # Grus grus
    "Insecta",        # Apis mellifera
    "Aves",           # Coragyps atratus
    "Aves",           # Pseudoscops clamator
    "Aves",           # Pandion haliaetus
    "Insecta",        # Sycanus bifidus
    "Insecta",        # Eocanthecona furcellata
    "Insecta",        # Arma custos
    "Aves",           # Corvus frugilegus
    "Aves",           # Milvus milvus
    "Mammalia"        # Vulpes zerda

  )
)

order_to_class <- tax_map %>%
  dplyr::select(host_order = tax_host_order,
                host_class = tax_host_class) %>%
  distinct()

legend_order <- order_to_class %>%
  dplyr::mutate(
    host_class = factor(host_class,
      levels = c("Mammalia", "Aves", "Reptilia",
                 "Actinopterygii", "Insecta", "Amphibia", NA)
    )
  ) %>%
  dplyr::arrange(host_class) %>%
  dplyr::pull(host_order)

total_genome_metadata$host_order <- factor(
  total_genome_metadata$host_order,
  levels = legend_order
)
```



## Define species list
```{r Define species and mags to remove list, eval = FALSE}
# ALL SPECIES
species_list <- c(
  "lactococcus_lactis",
  "parabacteroides_goldsteinii",
  "enterococcus_faecalis",
  "bacteroides_uniformis",
  "phocaeicola_vulgatus",
  "hafnia_paralvei",
  "citrobacter_braakii",
  "enterococcus_hirae",
  "akkermansia_muciniphila",
  "bacteroides_fragilis"
)


mags_to_remove_list <- list(
  lactococcus_lactis = c(
    "GCA_018369575.1.fna","GCA_947063445.1.fna","GCA_947101685.1.fna",
    "GCA_948698275.1.fna","GCA_937910935.1.fna","GCA_947072755.1.fna",
    "GCA_948655095.1.fna","GCA_948703095.1.fna","GCA_947041925.1.fna",
    "GCA_947073355.1.fna","GCA_948675165.1.fna","GCA_948718815.1.fna"
  ),
  parabacteroides_goldsteinii = character(0), # none to remove
  enterococcus_faecalis = character(0),
  hafnia_paralvei = character(0),
  bacteroides_uniformis = character(0),
  phocaeicola_vulgatus = c("GCA_040912025.1", "GCF_048453085.1", "GCA_048453085.1"),
  citrobacter_braakii = character(0),
  enterococcus_hirae = character(0),
  akkermansia_muciniphila = character(0),
  bacteroides_fragilis = character(0)
)


for (sp in species_list) {
  results[[sp]] <- process_one_species(
    species        = sp,
    mags_to_remove = mags_to_remove_list[[sp]]
  )
}

pg <- results[["parabacteroides_goldsteinii"]]$metadata
eh <- results[["enterococcus_hirae"]]$metadata
ef <- results[["enterococcus_faecalis"]]$metadata
pv <- results[["phocaeicola_vulgatus"]]$metadata
am <- results[["akkermansia_muciniphila"]]$metadata
bf <- results[["bacteroides_fragilis"]]$metadata
bu <- results[["bacteroides_uniformis"]]$metadata
ll <- results[["lactococcus_lactis"]]$metadata
hp <- results[["hafnia_paralvei"]]$metadata
cb <- results[["citrobacter_braakii"]]$metadata


named_list <- list(
  parabacteroides_goldsteinii = pg,
  enterococcus_hirae          = eh,
  enterococcus_faecalis       = ef,
  phocaeicola_vulgatus        = pv,
  akkermansia_muciniphila     = am,
  bacteroides_fragilis        = bf,
  bacteroides_uniformis       = bu,
  lactococcus_lactis          = ll,
  hafnia_paralvei             = hp,
  citrobacter_braakii         = cb
)

total_genome_metadata <- dplyr::bind_rows(named_list, .id = "bacterial_species")

```
## Data statistics
```{r counting species order and class}
total_genome_metadata %>% dplyr::count(host_species)

total_genome_metadata %>% dplyr::count(host_order)

total_genome_metadata %>% dplyr::count(host_class)
```
```{r plotting host order}
df_host_species <- total_genome_metadata %>%
  filter(!is.na(bacterial_species), !is.na(host_species)) %>%
  distinct(bacterial_species, host_species) %>%
  count(bacterial_species, name = "n_host_species") %>%
  mutate(bacterial_species = fct_reorder(bacterial_species, n_host_species))

ggplot(df_host_species,
       aes(x = bacterial_species, y = n_host_species)) +
  geom_col(fill = "#355C7D") +
  geom_text(aes(label = n_host_species), vjust = -0.3, size = 3) +
  labs(
    title = "Number of Host Species per Bacterial Species",
    x = "Bacterial species",
    y = "Distinct host species"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 40, hjust = 1))



df_order_counts <- total_genome_metadata %>%
  filter(!is.na(host_order)) %>%
  count(host_order, name = "n_mags") %>%
  mutate(host_order = fct_reorder(host_order, n_mags))

ggplot(df_order_counts,
       aes(x = host_order, y = n_mags)) +
  geom_col() +
  scale_fill_manual(values = host_order_colors)+
  geom_text(aes(label = n_mags), vjust = -0.3, size = 3) +
  labs(
    title = "Number of MAGs per Host Order",
    x = "Host order",
    y = "MAG count"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 40, hjust = 1))

```



### Mean completeness and contamination
```{r mean completeness and contamination final}
total_genome_metadata %>% 
  summarise(
    mean_c = mean(completeness, na.rm = TRUE) %>% round(2),
    sd_c = sd(completeness, na.rm = TRUE) %>% round(2),
    mean_con = mean(contamination, na.rm = TRUE) %>% round(2),
    sd_con = sd(contamination, na.rm = TRUE) %>% round(2)
  ) %>%
  unite("Completeness", mean_c, sd_c, sep = " ± ") %>%
  unite("Contamination", mean_con, sd_con, sep = " ± ") %>%
  tt()
```

```{r genome_quality_plot_2, message=FALSE, warning=FALSE, fig.height=6, fig.width=10, fig.fullwidth=TRUE}
#Generate quality biplot
genome_biplot <- total_genome_metadata %>%
  dplyr::select(c(ID,completeness,contamination, host_order)) %>%
  ggplot(aes(x=completeness, y=contamination, color = host_order)) +
  scale_color_manual(values = host_order_colors, name = "Host Order") +
  geom_point(alpha=0.7, size = 4) +
  xlim(c(90,100)) +
  ylim(c(2.5,0)) +
  labs(y= "Contamination", x = "Completeness") +
  theme_classic() +
  theme(
    legend.position = "left",
    axis.text.y = element_text(size=12),
    axis.text.x = element_text(size=12),
    axis.title.x = element_text(size = 16, face = "bold"),
    axis.title.y = element_text(size = 16, face = "bold")
  )

#Generate contamination boxplot
genome_contamination <- total_genome_metadata %>%
            ggplot(aes(y=contamination)) +
                    ylim(c(2.5,0)) +
                    geom_boxplot(colour = "#999999", fill="#cccccc") +
                    theme_classic() +
                    theme(legend.position = "none",
                    axis.line = element_blank(),
                    axis.title = element_blank(),
                    axis.text=element_blank(),
                    axis.ticks=element_blank(),
                        plot.margin = unit(c(0, 0, 0.40, 0),"inches")) #add bottom-margin (top, right, bottom, left)

#Generate completeness boxplot
genome_completeness <- total_genome_metadata %>%
        ggplot(aes(x=completeness)) +
                xlim(c(90,100)) +
                geom_boxplot(colour = "#999999", fill="#cccccc") +
                theme_classic() +
                theme(legend.position = "none",
                    axis.line = element_blank(),
                    axis.title = element_blank(),
                    axis.text=element_blank(),
                    axis.ticks=element_blank(),
                    plot.margin = unit(c(0, 0, 0, 0.50),"inches")) #add left-margin (top, right, bottom, left)

#Render composite figure
#pdf("figures/completeness_contamination.pdf",width=10, height=5)
grid.arrange(grobs = list(genome_completeness,genome_biplot,genome_contamination),
        layout_matrix = rbind(c(1,1,1,1,1,1,1,1,1,1,1,4),
                              c(2,2,2,2,2,2,2,2,2,2,2,3),
                              c(2,2,2,2,2,2,2,2,2,2,2,3),
                              c(2,2,2,2,2,2,2,2,2,2,2,3),
                              c(2,2,2,2,2,2,2,2,2,2,2,3),
                              c(2,2,2,2,2,2,2,2,2,2,2,3),
                              c(2,2,2,2,2,2,2,2,2,2,2,3),
                              c(2,2,2,2,2,2,2,2,2,2,2,3),
                              c(2,2,2,2,2,2,2,2,2,2,2,3),
                              c(2,2,2,2,2,2,2,2,2,2,2,3),
                              c(2,2,2,2,2,2,2,2,2,2,2,3),
                              c(2,2,2,2,2,2,2,2,2,2,2,3)))
#dev.off()
```


```{r test the loop with data preparation}
species_list <- c(
  "citrobacter_braakii",
  "hafnia_paralvei"
)

mags_to_remove_list <- list(
  citrobacter_braakii = character(0),
  hafnia_paralvei = character(0)
)


# ---- Run for all species ----
results <- setNames(vector("list", length(species_list)), species_list)

for (sp in species_list) {
  results[[sp]] <- process_one_species(
    species        = sp,
    mags_to_remove = mags_to_remove_list[[sp]]
  )
}

# Examples:
# results[["lactococcus_lactis"]]$metadata
# results[["lactococcus_lactis"]]$annotations
```

## Testing functions with one species


```{r example loading data}
sp <- "lactococcus_lactis"
res <- process_one_species(sp)

genome_metadata <- res$metadata
genome_annotations <- res$annotations
# ndb <- res$ndb

ndb <- read_csv("data/mags_metadata/lactococcus_lactis_Ndb.csv") #TODO include in process one species!

```


```{r example_drep, fig.height = 10, fig_width = 8}
recreate_drep_tree(ndb)
```

```{r example_drep_final, fig.height = 10, fig_width = 8}
drep_results <- drep_tree_metadata(genome_metadata, ndb)

tree <- drep_results$tree
tip_df <- drep_results$tip_df
ani_matrix <- drep_results$ani_matrix


p_host_order <- plot_tree_basic(tree, tip_df, color_by = "host_order",
                          label_tips = TRUE, show_threshold = 99.5)
p_host_order
```


```{r example run with one species}
# Build matrices
kegg_mat <- make_annotation_matrix(genome_annotations, "kegg")
amr_mat  <- make_annotation_matrix(genome_annotations, "resistance_target")
vf_mat <- make_annotation_matrix(genome_annotations, "vf")

# Fisher + volcano
kegg_fisher <- run_fisher_tests(kegg_mat, genome_metadata, "kegg")
amr_fisher  <- run_fisher_tests(amr_mat, genome_metadata, "amr")
vf_fisher  <- run_fisher_tests(vf_mat, genome_metadata, "vf")

plot_volcano(kegg_fisher, "kegg")
plot_volcano(amr_fisher, "amr")
plot_volcano(vf_fisher, "vf")


# PCA
pca_kegg <- run_pca(kegg_mat)
pca_amr  <- run_pca(amr_mat)
pca_vf  <- run_pca(vf_mat)

# PERMANOVA
kegg <- pa_permanova(kegg_mat, genome_metadata)
kegg$dist
kegg$permanova

amr <- pa_permanova(amr_mat, genome_metadata)

amr$dist
amr$permanova

vf <- pa_permanova(vf_mat, genome_metadata)
vf$dist
vf$permanova

# PCOAs

## KEGG
pcoa_res <- ape::pcoa(kegg$dist, correction = "cailliez") 

#TODO-fix this - subset to only grab common ids
# fails with enterococcus_hirae


pcoa_df <- data.frame(
  ID = rownames(kegg$pa_nz),
  PC1 = pcoa_res$vectors[, 1],
  PC2 = pcoa_res$vectors[, 2],
  host_type = genome_metadata$host_type,
  host_order = genome_metadata$host_order
)

var_exp <- round(100 * pcoa_res$values$Rel_corr_eig[1:2], 1)

pcoa_kegg_pa <- ggplot(pcoa_df, aes(PC1, PC2, color = host_type)) +
  geom_point(size = 2) +
  scale_color_manual(values = host_type_colors, name = "Host type")+
  theme_minimal() +
  labs(
    title = "PCoA of KEGG presence/absence matrix across MAGs (colored by host type)",
    x = paste0("PC1 (",round(var_exp[1], 1), "%)"),
    y = paste0("PC2 (", round(var_exp[2], 1), "%)")
  )

pcoa_kegg_pa

ggplot(pcoa_df, aes(PC1, PC2, color = host_order)) +
  geom_point(size = 2) +
  scale_color_manual(values = host_order_colors, name = "Host order")+
  theme_minimal() +
  labs(
    title = "PCoA of KEGG presence/absence matrix across MAGs (colored by host order)",
    x = paste0("PC1 (",round(var_exp[1], 1), "%)"),
    y = paste0("PC2 (", round(var_exp[2], 1), "%)")
  )

## AMR
pcoa_res <- ape::pcoa(amr$dist, correction = "cailliez")

pcoa_df <- data.frame(
  ID = rownames(amr$pa_nz),
  PC1 = pcoa_res$vectors[, 1],
  PC2 = pcoa_res$vectors[, 2],
  host_type = genome_metadata$host_type,
  host_order = genome_metadata$host_order
)

var_exp <- round(100 * pcoa_res$values$Rel_corr_eig[1:2], 1)

pcoa_amr_pa <- ggplot(pcoa_df, aes(PC1, PC2, color = host_type)) +
  geom_point(size = 2) +
  scale_color_manual(values = host_type_colors, name = "Host type")+
  theme_minimal() +
  labs(
    title = "PCoA of AMR presence/absence matrix across MAGs (colored by host type)",
    x = paste0("PC1 (",round(var_exp[1], 1), "%)"),
    y = paste0("PC2 (", round(var_exp[2], 1), "%)")
  )

pcoa_amr_pa

ggplot(pcoa_df, aes(PC1, PC2, color = host_order)) +
  geom_point(size = 2) +
  scale_color_manual(values = host_order_colors, name = "Host order")+
  theme_minimal() +
  labs(
    title = "PCoA of AMR presence/absence matrix across MAGs (colored by host order)",
    x = paste0("PC1 (",round(var_exp[1], 1), "%)"),
    y = paste0("PC2 (", round(var_exp[2], 1), "%)")
  )


## VF
pcoa_res <- ape::pcoa(vf$dist, correction = "cailliez")

pcoa_df <- data.frame(
  ID = rownames(vf$pa_nz),
  PC1 = pcoa_res$vectors[, 1],
  PC2 = pcoa_res$vectors[, 2],
  host_type = genome_metadata$host_type,
  host_order = genome_metadata$host_order
)

var_exp <- round(100 * pcoa_res$values$Rel_corr_eig[1:2], 1)

pcoa_vf_pa <- ggplot(pcoa_df, aes(PC1, PC2, color = host_type)) +
  geom_point(size = 2) +
  scale_color_manual(values = host_type_colors, name = "Host type")+
  theme_minimal() +
  labs(
    title = "PCoA of VF presence/absence matrix across MAGs (colored by host type)",
    x = paste0("PC1 (",round(var_exp[1], 1), "%)"),
    y = paste0("PC2 (", round(var_exp[2], 1), "%)")
  )

pcoa_vf_pa

ggplot(pcoa_df, aes(PC1, PC2, color = host_order)) +
  geom_point(size = 2) +
  scale_color_manual(values = host_order_colors, name = "Host order")+
  theme_minimal() +
  labs(
    title = "PCoA of VF presence/absence matrix across MAGs (colored by host order)",
    x = paste0("PC1 (",round(var_exp[1], 1), "%)"),
    y = paste0("PC2 (", round(var_exp[2], 1), "%)")
  )

```







<!--chapter:end:06_looping_all_species.Rmd-->


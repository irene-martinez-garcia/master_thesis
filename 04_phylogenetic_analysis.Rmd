# Phylogenetic Analysis

### Load data
```{r load data phylogenetics}
load("data/data.Rdata")
```



## Getphylo tree
```{r check tree, fig.height=8, fig.width=16, fig.fullwidth=TRUE}
# Merge tip data with tree
tip_df <- data.frame(label = getphylo_tree$tip.label) %>%
  left_join(genome_metadata, by = c("label" = "ID"))

p <- ggtree(getphylo_tree) %<+% tip_df +
  geom_tiplab(aes(color = source), size = 3) +
  theme_tree2() +
  scale_color_manual(values = source_colors)

p

```


```{r remove low size mag, fig.height=8, fig.width=10, fig.fullwidth=TRUE}
#Remove GCA_015060925.1
getphylo_tree_trimmed <- drop.tip(getphylo_tree, "GCA_015060925.1")

tip_df_trimmed <- tip_df %>% 
  filter(label != "GCA_015060925.1")

p <- ggtree(getphylo_tree_trimmed) %<+% tip_df_trimmed +
  geom_tiplab(aes(color = source), size = 3) +
  theme_tree2() +
  scale_color_manual(values = source_colors)

p

```


Circular tree with genome size and completeness
```{r genome_phylogeny_completeness, message=FALSE, warning=FALSE, fig.height=7, fig.width=7, fig.fullwidth=TRUE}
# Generate  basal tree
circular_tree <- force.ultrametric(getphylo_tree_trimmed, method="extend") %>% # extend to ultrametric for the sake of visualization
    ggtree(., layout="fan", open.angle=10, size=0.5)

# Add completeness ring
circular_tree <- circular_tree +
        new_scale_fill() +
        scale_fill_gradient(low = "#d1f4ba", high = "#f4baba") +
        geom_fruit(
                data=genome_metadata,
                geom=geom_bar,
                mapping = aes(x=completeness, y=ID, fill=contamination),
                offset = 0.24,
                pwidth = 0.1,
                orientation="y",
              stat="identity")+
  labs(fill="Contamination")

# Add genome-size ring
circular_tree <-  circular_tree + new_scale_fill()

circular_tree <-  circular_tree +
  geom_fruit(
    data=genome_metadata,
    geom=geom_bar,
    mapping = aes(x=genome_size, y=ID),
    fill = "#1e6e55",
    offset = 0.05,
    orientation="y",
    stat="identity")



#Plot circular tree
circular_tree %>% open_tree(30) %>% rotate_tree(90)
```

Circular tree with host and source

```{r genome_phylogeny_plot, message=FALSE, warning=FALSE, fig.height=7, fig.width=7, fig.fullwidth=TRUE}
# Generate  basal tree
circular_tree <- force.ultrametric(getphylo_tree_trimmed, method="extend") %>% # extend to ultrametric for the sake of visualisation
    ggtree(., layout="fan", open.angle=10, size=0.4)

#Host species ring
circular_tree <- circular_tree +
  new_scale_fill() +
  geom_fruit(
    data = genome_metadata,
    geom = geom_tile,
    mapping = aes(y = ID, fill = host_species),
    width = 0.005,
    offset = 0.10
  ) +
  scale_fill_brewer(palette = "Set3") +
  labs(fill = "Host")

#source ring
circular_tree <- circular_tree +
  new_scale_fill() +
  geom_fruit(
    data = genome_metadata,
    geom = geom_tile,
    mapping = aes(y = ID, fill = source),
    width = 0.005,
    offset = 0.15
  ) +
  scale_fill_manual(values = source_colors) +
  labs(fill = "Source")

# Plot
circular_tree %>% open_tree(30) %>% rotate_tree(90)

```


## dRep tree


```{r load drep files}
fastani_comparisons <- read_csv("data/Ndb.csv")  #Secondary comparison results
```




```{r recreate drep tree}
genomes <- unique(c(fastani_comparisons$reference, fastani_comparisons$querry))

# Create empty matrix
ani_matrix <- matrix(0, nrow = length(genomes), ncol = length(genomes))
rownames(ani_matrix) <- genomes
colnames(ani_matrix) <- genomes

# Fill the matrix
for(i in 1:nrow(fastani_comparisons)) {
  ref <- fastani_comparisons$reference[i]
  qry <- fastani_comparisons$querry[i]
  ani_val <- fastani_comparisons$ani[i]
  
  ani_matrix[ref, qry] <- ani_val
  ani_matrix[qry, ref] <- ani_val  # Make symmetric
}

# Set diagonal to 100
diag(ani_matrix) <- 100

# Convert to distance matrix (for tree building)
dist_matrix <- as.dist(1 - ani_matrix)

# Build tree
hc <- hclust(dist_matrix, method = "average") #drep uses hierarchical clustering
tree <- as.phylo(hc)

ggtree(tree) + 
  geom_tiplab(size = 2) +
  theme_tree2()
```



```{r final drep tree}
#remove this outlier that is >95% different (it must be another species)
outlier <- "GCA_015060925.1_ASM1506092v1_genomic.fna"

fastani_filtered <- fastani_comparisons %>%
  filter(reference != outlier,
         querry != outlier)

#create the matrix
genomes <- unique(c(fastani_filtered$reference,
                    fastani_filtered$querry))

ani_matrix <- matrix(0,
                     nrow = length(genomes),
                     ncol = length(genomes),
                     dimnames = list(genomes, genomes))

#fill in the matrix with the distances
for(i in seq_len(nrow(fastani_filtered))) {
  ref <- fastani_filtered$reference[i]
  qry <- fastani_filtered$querry[i]
  ani <- fastani_filtered$ani[i]

  ani_matrix[ref, qry] <- ani
  ani_matrix[qry, ref] <- ani
}

diag(ani_matrix) <- 1


dist_matrix <- as.dist(1 - ani_matrix )

#hierarchical clustering ti generate the tree
hc <- hclust(dist_matrix, method = "average")
tree <- as.phylo(hc)

#use the short labels 
tip_df <- tibble(
  label = tree$tip.label,
label_clean = sub("\\.fna$|\\.fa$", "", tree$tip.label)
)

tip_df <- tip_df %>%
  left_join(genome_metadata, by = c("label_clean" = "mag_name"))

tree$tip.label <- ifelse(
  is.na(tip_df$ID),
  tip_df$label_clean,
  tip_df$ID
)

#check
sum(is.na(tip_df$ID))

tips_to_remove <- tree$tip.label[is.na(tip_df$ID)]
tree <- ape::drop.tip(tree, tips_to_remove)

# Update tip_df to match the pruned tree
tip_df <- tip_df %>%
  filter(!is.na(ID))

```




```{r plot the final tree}
tree_reversed <- tree
# Get the maximum distance (root to furthest tip)
max_dist <- max(node.depth.edgelength(tree))
# Reverse: make tips = 0 and root = max
tree_reversed$edge.length <- tree$edge.length
node_depths <- node.depth.edgelength(tree)
# Calculate new positions (invert from tips)
for(i in 1:length(tree_reversed$edge.length)) {
  tree_reversed$edge.length[i] <- tree$edge.length[i]
}

p <- ggtree(tree) +
  geom_tiplab(size = 2, hjust =  0.8)+
  scale_x_continuous(
    breaks = seq(0, 0.02, by = 0.002),
    labels = function(x) round(100 * (1 - x), 1),  # Reverse the labels
    trans = "reverse"  # Reverse the axis
  ) +
  coord_cartesian(xlim = c(0.02, 0)) +
  labs(x = "Average Nucleotide Identity (ANI, %)") +
  theme_tree2()

p
```




```{r tree final, fig.height = 10, fig.width = 12}
# Create a proper matching data frame
tip_data_for_plot <- data.frame(
  label = tree$tip.label,
  stringsAsFactors = FALSE
)

# Match with metadata
tip_data_for_plot <- tip_data_for_plot %>%
  left_join(
    tip_df %>% dplyr::select(ID, source, host_species, country, locality, continent, completeness),
    by = c("label" = "ID")
  )

# Get the actual x-range of the tree
tree_data <- fortify(tree)
max_x <- max(tree_data$x[tree_data$isTip])

# Plot
p <- ggtree(tree, size = 1) +  
  geom_vline(xintercept = max_x - 0.005,  # 99.5% ANI (0.005 from tips)
             linetype = "dashed", 
             color = "red", 
             size = 0.8) +
  geom_tippoint(aes(color = source), size = 3) +
  geom_tiplab(aes(color = source),
              size = 4,
              hjust = -0.1)

p <- p %<+% tip_data_for_plot +
  scale_color_manual(values = source_colors, name = "Source") +
  scale_x_continuous(
    labels = function(x) round(100 * (1 - (max_x - x)), 1)  # Convert based on distance from tips
  ) +
  coord_cartesian(xlim = c(0, max_x + 0.005)) +
  labs(x = "Average Nucleotide Identity (ANI, %)") +
  theme_tree2() +
  theme(
    legend.position = "right",
    plot.margin = margin(5, 100, 5, 5),
    axis.text.x = element_text(size = 14),
    axis.title.x = element_text(size = 16)
  )
p
```



```{r plot without red line, fig.height = 10, fig.width = 12}
# Plot
p <- ggtree(tree, size = 1) +  
  geom_tippoint(aes(color = source), size = 3) +
  geom_tiplab(aes(color = source),
              size = 4,
              hjust = -0.1)

p <- p %<+% tip_data_for_plot +
  scale_color_manual(values = source_colors, name = "Source") +
  scale_x_continuous(
    labels = function(x) round(100 * (1 - (max_x - x)), 1)  # Convert based on distance from tips
  ) +
  coord_cartesian(xlim = c(0, max_x + 0.005)) +
  labs(x = "Average Nucleotide Identity (ANI, %)") +
  theme_tree2() +
  theme(
    legend.position = "right",
    plot.margin = margin(5, 100, 5, 5),
    axis.text.x = element_text(size = 14),
    axis.title.x = element_text(size = 16)
  )
p
```



```{r cutting tree}
# Convert phylo tree to hclust object
hclust_tree <- as.hclust.phylo(tree)

# Cut at 95% similarity (5% distance)
# The height corresponds to genetic distance
# For 95% similarity = 0.05 distance from tips
cut_height <- 0.05

# Cut the tree
groups <- cutree(hclust_tree, h = cut_height)

# Add group information to your tip data
tip_data_for_plot$group <- groups[match(tip_data_for_plot$label, names(groups))]

# See how many groups you have
table(groups)

# Visualize with groups highlighted
p <- ggtree(tree, size = 1) +  
  geom_vline(xintercept = max_x - 0.05,  # 95% ANI (0.05 from tips)
             linetype = "dashed", 
             color = "red", 
             size = 0.8) +
  geom_tippoint(aes(color = source, shape = as.factor(group)), size = 3) +
  geom_tiplab(aes(color = source),
              size = 4,
              hjust = -0.1)

p <- p %<+% tip_data_for_plot +
  scale_color_manual(values = source_colors, name = "Source") +
  scale_shape_manual(values = rep(15:18, length.out = max(groups)), 
                     name = "95% ANI Group") +
  scale_x_continuous(
    labels = function(x) round(100 * (1 - (max_x - x)), 1)
  ) +
  coord_cartesian(xlim = c(0, max_x + 0.005)) +
  labs(x = "Average Nucleotide Identity (ANI, %)") +
  theme_tree2() +
  theme(
    legend.position = "right",
    plot.margin = margin(5, 100, 5, 5),
    axis.text.x = element_text(size = 14),
    axis.title.x = element_text(size = 16)
  )
p
```




```{r tree final_by_host_species, fig.height = 10, fig.width = 12}
# Get the actual x-range of the tree
tree_data <- fortify(tree)
max_x <- max(tree_data$x[tree_data$isTip])

# Plot
p <- ggtree(tree, size = 1) +  
  geom_vline(xintercept = max_x - 0.005,  # 99.5% ANI (0.005 from tips)
             linetype = "dashed", 
             color = "red", 
             size = 0.8) +
  geom_tippoint(aes(color = host_species), size = 3) +
  geom_tiplab(aes(color = host_species),
              size = 4,
              hjust = -0.1)

p <- p %<+% tip_data_for_plot +
  scale_x_continuous(
    labels = function(x) round(100 * (1 - (max_x - x)), 1)  # Convert based on distance from tips
  ) +
  coord_cartesian(xlim = c(0, max_x + 0.005)) +
  labs(x = "Average Nucleotide Identity (ANI, %)") +
  theme_tree2() +
  theme(
    legend.position = "right",
    plot.margin = margin(5, 100, 5, 5),
    axis.text.x = element_text(size = 14),
    axis.title.x = element_text(size = 16)
  )
p
```



```{r more info tree, eval = FALSE}
library(ggtree)
library(ggnewscale)

# Ensure rownames match tip labels
rownames(tip_data_for_plot) <- tip_data_for_plot$tip_label

p <- ggtree(tree, size = 1) +
  geom_tippoint(aes(color = source), size = 3) +
  geom_tiplab(aes(color = source), size = 4, hjust = -0.1) +
  scale_color_manual(values = source_colors, name = "Source")

# 1) completeness
p <- gheatmap(
  p,
  tip_data_for_plot["completeness"],
  offset = 0.05,
  width = 0.12,
  colnames_position = "top"
) +
  scale_fill_gradient(name = "Completeness", low = "white", high = "darkgreen")


p <- p + ggnewscale::new_scale_fill()

# 2) country
p <- gheatmap(
  p,
  tip_data_for_plot["country"],
  offset = 0.17,
  width = 0.12,
  colnames_position = "top"
) +
  scale_fill_manual(name = "Country", values = country_colors)


p <- p + ggnewscale::new_scale_fill()

# 3) host_species
p <- gheatmap(
  p,
  tip_data_for_plot["host_species"],
  offset = 0.29,
  width = 0.12,
  colnames_position = "top"
) +
  scale_fill_manual(name = "Host species", values = host_colors)

# final x-axis
p <- p +
  scale_x_continuous(labels = function(x) round(100 * (1 - (max_x - x)), 1)) +
  coord_cartesian(xlim = c(0, max_x + 0.005)) +
  labs(x = "Average Nucleotide Identity (ANI, %)") +
  theme_tree2() +
  theme(
    legend.position = "right",
    plot.margin = margin(5, 100, 5, 5),
    axis.text.x = element_text(size = 14),
    axis.title.x = element_text(size = 16)
  )

p

```



```{r tree circular, fig.height = 12, fig.width = 12}
library(ggtree)
library(ggtreeExtra)
library(ggplot2)
library(ggnewscale)

p <- ggtree(tree, layout = "circular") %<+% tip_data_for_plot +
  geom_tippoint(aes(color = host_species), size = 2)

# Country (discrete)
p <- p +
  geom_fruit(
    geom = geom_tile,
    mapping = aes(y = label, fill = country),
    offset = 0.03,
    pwidth = 0.02,
    width = 0.02
  ) +
  scale_fill_discrete(name = "Country")

p <- p + ggnewscale::new_scale_fill()

#Source (discrete) 
p <- p +
  geom_fruit(
    geom = geom_tile,
    mapping = aes(y = label, fill = source),
    offset = 0.04,
    pwidth = 0.02,
    width = 0.02
  ) +
  scale_fill_discrete(name = "Source")

p <- p + ggnewscale::new_scale_fill()

#Completeness
p <- p +
  geom_fruit(
    geom = geom_tile,
    mapping = aes(y = label, fill = completeness),
    offset = 0.05,
    pwidth = 0.01,
    width = 0.02
  ) +
  scale_fill_viridis_c(name = "Completeness (%)")


p <- p + ggplot2::theme_void()

p


```



```{r tree final_by_country, fig.height = 10, fig.width = 12}
# Get the actual x-range of the tree
tree_data <- fortify(tree)
max_x <- max(tree_data$x[tree_data$isTip])

# Plot
p <- ggtree(tree, size = 1) +  
  geom_vline(xintercept = max_x - 0.005,  # 99.5% ANI (0.005 from tips)
             linetype = "dashed", 
             color = "red", 
             size = 0.8) +
  geom_tippoint(aes(color = continent), size = 3) +
  geom_tiplab(aes(color = continent),
              size = 4,
              hjust = -0.1)

p <- p %<+% tip_data_for_plot +
  scale_x_continuous(
    labels = function(x) round(100 * (1 - (max_x - x)), 1)  # Convert based on distance from tips
  ) +
  coord_cartesian(xlim = c(0, max_x + 0.005)) +
  labs(x = "Average Nucleotide Identity (ANI, %)") +
  theme_tree2() +
  theme(
    legend.position = "right",
    plot.margin = margin(5, 100, 5, 5),
    axis.text.x = element_text(size = 14),
    axis.title.x = element_text(size = 16)
  )
p
```





## Load pangenome data

PPanggolin
```{r pangolin presence absence}
gene_matrix <- read.table(
  "data/gene_presence_absence.Rtab",
  header = TRUE,
  row.names = 1
)

# remove the non-parabacteroides MAG
gene_matrix <- gene_matrix[, colnames(gene_matrix) != "GCA_015060925.1_ASM1506092v1_genomic"]
```

```{r pca on presence absence matrix}
gene_matrix_transposed <- gene_matrix %>% t()

pca_gene_matrix <- prcomp(gene_matrix_transposed)

plot_pca_gene_matrix <- as_tibble(pca_gene_matrix$x)%>% bind_cols(genome_metadata)

percent_variance <- summary(pca_gene_matrix)$importance["Proportion of Variance",] * 100
  
```

```{r plot pca}
ggplot( plot_pca_gene_matrix, aes(x=PC1, y=PC2, col=host_species, label = ID)) + 
  geom_point() + 
  geom_text(hjust=0, vjust=0, size=2) +
  xlab(paste("PC1 ", percent_variance[1], "%"))+ 
  ylab(label = paste("PC2 ", percent_variance[2], "%")) +
  theme_bw()


# Removing outlier
outlier_to_remove <- "GCA_015060925.1" 
gene_matrix_filtered <- gene_matrix[, !colnames(gene_matrix) %in% outlier_to_remove]

# Rerun PCA without outlier
gene_matrix_transposed_filtered <- gene_matrix_filtered %>% t()
pca_gene_matrix_filtered <- prcomp(gene_matrix_transposed_filtered)
plot_pca_filtered <- as_tibble(pca_gene_matrix_filtered$x) %>% 
  bind_cols(genome_metadata %>% filter(!rownames(.) %in% outlier_to_remove))
percent_variance_filtered <- summary(pca_gene_matrix_filtered)$importance["Proportion of Variance",] * 100

plot_pca_filtered <- plot_pca_filtered %>%
  mutate(
    collection_date = as.Date(ncbi_date),  
    date_numeric = as.numeric(ncbi_date)
  )

# Plot colored by date with gradient
ggplot(plot_pca_filtered, aes(x=PC1, y=PC2, color=collection_date)) + 
  geom_point(size=3) + 
  scale_color_viridis_c(option="viridis") +  # or use "plasma", "inferno", etc.
  xlab(paste("PC1 ", percent_variance_filtered[1], "%"))+ 
  ylab(paste("PC2 ", percent_variance_filtered[2], "%")) +
  labs(color="Collection Date") +
  theme_bw()

```




```{r mapping the tree to the gene matrix}
mapping_from_tip_df <- setNames(tip_df$ID, tip_df$label_clean)

# Check the mapping
cat("First 10 mappings from tip_df:\n")
head(mapping_from_tip_df, 10)

# How many gene_matrix columns match?
cat("\nGene_matrix columns in tip_df mapping:", 
    sum(colnames(gene_matrix) %in% names(mapping_from_tip_df)), "\n")

# Which gene_matrix columns are NOT in tip_df?
not_in_tipdf <- colnames(gene_matrix)[!colnames(gene_matrix) %in% names(mapping_from_tip_df)]
cat("Not in tip_df (", length(not_in_tipdf), "):\n")
print(head(not_in_tipdf, 20))

# Apply the mapping from tip_df
new_colnames <- mapping_from_tip_df[colnames(gene_matrix)]

cat("\nNumber of successful mappings:", sum(!is.na(new_colnames)), "\n")
cat("Number of NAs:", sum(is.na(new_colnames)), "\n")

# Apply new names
colnames(gene_matrix) <- ifelse(
  is.na(new_colnames),
  colnames(gene_matrix),  # Keep original if no mapping
  new_colnames            # Use mapped EHM ID
)

# Now check matching with tree
cat("\nAfter mapping - columns matching tree:", 
    sum(colnames(gene_matrix) %in% tree$tip.label), "\n")

# Common genomes
common_genomes <- intersect(colnames(gene_matrix), tree$tip.label)
cat("Common genomes:", length(common_genomes), "\n")

# Should be 91 now (or close to it)!
gene_matrix_filtered <- gene_matrix[, common_genomes]
gene_matrix_t <- t(gene_matrix_filtered)
gene_matrix_t <- gene_matrix_t[tree$tip.label, ]

cat("\nFinal verification - Perfect match?", 
    all(rownames(gene_matrix_t) == tree$tip.label), "\n")
```




```{r final_pangenome_fig_heatmap_tree, fig.height=8, fig.width=16, fig.fullwidth=TRUE, eval = TRUE}
hc <- as.hclust(tree)

ann_colors <- list(
  source = source_colors  
)

pheatmap(
  gene_matrix_t,
  cluster_rows = hc,     
  cluster_cols = TRUE,
  show_rownames = TRUE,
  show_colnames = FALSE,
  fontsize = 5,
  color = c("white", "blue")
)

```

```{r dendogram matrix figure, fig.height=10, fig.width=16, fig.fullwidth=TRUE, eval = TRUE}
annotation_row <- data.frame(
  source = genome_metadata$source
)
rownames(annotation_row) <- genome_metadata$ID

ann_colors <- list(
  source = source_colors  
)

# keep only rows in the matrix
annotation_row <- annotation_row[rownames(gene_matrix_t), , drop = FALSE]

pheatmap(
  gene_matrix_t,
  cluster_rows = hc,
  cluster_cols = TRUE,
  treeheight_row = 120,
  show_rownames = TRUE,
  show_colnames = FALSE,
  fontsize = 5,
  color = c("white", "blue"),
  annotation_row = annotation_row,
  annotation_colors = ann_colors,
  legend_breaks = c(0, 1),
  legend_labels = c("Absent", "Present")
)

```




```{r testing with complexheatmap to include ani values of dendogram, fig.height=10, fig.width=16, fig.fullwidth=TRUE}
library(ComplexHeatmap)
library(circlize)

annotation_row <- data.frame(
  source = genome_metadata$source
)
rownames(annotation_row) <- genome_metadata$ID
annotation_row <- annotation_row[rownames(gene_matrix_t), , drop = FALSE]

# Heatmap colors
col_fun <- colorRamp2(c(0, 1), c("white", "blue"))

# Row annotation
row_ha <- rowAnnotation(
  source = annotation_row$source,
  col = list(source = ann_colors$source)
)

Heatmap(
  gene_matrix_t,
  name = "Gene presence",
  col = col_fun,
  cluster_rows = hc,
  cluster_columns = TRUE,
  show_row_names = TRUE,
  show_column_names = FALSE,
  row_names_gp = gpar(fontsize = 6),
  left_annotation = row_ha
)

```




## Exploring ppanggolin outputs
```{r load all pangolin outputs, message = FALSE, warning = FALSE}
functional_modules <- read_tsv("data/pangolin/functional_modules.tsv")
  gene_families <- read_tsv("data/pangolin/gene_families.tsv", col_names = FALSE)
mean_persistent_duplication <- read_tsv("data/pangolin/mean_persistent_duplication.tsv")
modules_in_genomes <- read_tsv("data/pangolin/modules_in_genomes.tsv")
modules_RGP_lists <- read_tsv("data/pangolin/modules_RGP_lists.tsv")
modules_spots <- read_tsv("data/pangolin/modules_spots.tsv")
modules_summary <- read_tsv("data/pangolin/modules_summary.tsv")
spot_borders <- read_tsv("data/pangolin/spot_borders.tsv")
spots <- read_tsv("data/pangolin/spots.tsv")
summarize_spots <- read_tsv("data/pangolin/summarize_spots.tsv")
genomes_statistics <- read_tsv("data/pangolin/genomes_statistics.tsv", comment= "#")
regions_of_genomic_plasticity <- read_tsv("data/pangolin/regions_of_genomic_plasticity.tsv")
```

```{r add genome sizes missing}
genome_metadata <- genome_metadata %>%
  mutate(
    genome_size = case_when(
      ID == "GCF_001406015.1" & is.na(genome_size) ~ 5073478,
      ID == "GCF_002206325.1" & is.na(genome_size) ~ 4963958,
      TRUE ~ genome_size
    )
  )


genome_metadata <- genome_metadata %>%
  mutate(
    host_class   = if_else(source == "GTDB", "Mammalia", host_class),
    host_order   = if_else(source == "GTDB", "Primates", host_order),
    host_species = if_else(source == "GTDB", "Homo sapiens", host_species)
  )
```

```{r remove non_parabacteroidesdistasonis_mag}
excluded_mags <- c("GCA_015060925.1")

valid_mags <- genome_metadata %>%
  filter(!ID %in% excluded_mags) %>%
  pull(ID)

genome_annotations <- genome_annotations %>%
  filter(mag_id %in% valid_mags)

genome_metadata <- genome_metadata %>%
  filter(ID %in% valid_mags)


genome_gifts <- genome_gifts[rownames(genome_gifts) %in% valid_mags, ]

```


















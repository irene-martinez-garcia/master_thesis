
## Data preparation

### EHI MAGs
```{r load ehi mags first_human}
ehi_mags <- read_csv("data/ehi_mags.csv")
```
### Prepare color scheme

[AlberdiLab](www.alberdilab.dk) projects use unified color schemes developed for the [Earth Hologenome Initiative](www.earthhologenome.org), to facilitate figure interpretation.

```{r get_ehi_phylum_colors, warning=FALSE, comments="", message=FALSE, eval=FALSE}
ehi_mags_p <- ehi_mags %>%
  mutate(phylum=str_remove_all(phylum, "p__")) 

phylum_colors <- read_tsv("https://raw.githubusercontent.com/earthhologenome/EHI_taxonomy_colour/main/ehi_phylum_colors.tsv") %>%
    mutate(phylum=str_remove_all(phylum, "p__")) %>%
    right_join(ehi_mags_p, by=join_by(phylum == phylum)) %>%
    dplyr::select(phylum, colors) %>% 
    unique() %>%
    arrange(phylum) %>%
    pull(colors, name=phylum)

```


```{r colors}
source_colors <- c(EHI = "#8BC63F", GTDB = "#2D522D", NCBI= "#20558A")

host_type_colors <- c(human = "#A90D00" , animal = "darkgreen") 

host_order_colors <- c(
  "Accipitriformes" = "#143AC2",  # Aves
  "Carnivora"       = "#633C2C",  # Mammalia
  "Chiroptera"      = "#1B2021",  # Mammalia
  "Primates"        = "#CC0000",  # Mammalia
  "Rodentia"        = "#FDA991",  # Mammalia
  "Diptera"         = "#FFAE2B",  # Insecta
  "Isoptera"        = "#E27500",  # Insecta
  "Lepidoptera"     = "#C8591D",  # Insecta
  "Squamata"        = "#1D921B"   # Reptilia
)
```

### Sample metadata
```{r genome_metadata}
genome_metadata <- read_tsv("data/mags_metadata/lactococcus_lactis_FINAL_metadata.tsv")
```


```{r infer metadata from isolation source}
# Helper across the pipeline
is_blank <- function(x) is.na(x) | x == ""

# 1) Recreate host_text (as you had)
genome_metadata <- genome_metadata %>%
  mutate(
    host_text = str_to_lower(
      str_squish(
        paste(
          coalesce(host_species, ""),
          coalesce(host, ""),
          coalesce(isolation_source, ""),
          coalesce(env_broad, ""),
          coalesce(env_local_context, ""),
          sep = " ; "
        )
      )
    )
  )

# 2) Infer host_species ONLY when missing/empty — now with your new species
genome_metadata <- genome_metadata %>%
  mutate(
    host_species = dplyr::case_when(
      # keep explicit host_species if present
      !is_blank(host_species) ~ host_species,

      # Human
      str_detect(host_text, "homo sapiens|\\bhuman\\b|patient|adult|child|infant") ~ "Homo sapiens",

      # Mouse
      str_detect(host_text, "mus musculus|\\bmouse\\b|\\bmice\\b|murine") ~ "Mus musculus",

      # Rat
      str_detect(host_text, "rattus|\\brat\\b") ~ "Rattus norvegicus",

      # Pig / swine
      str_detect(host_text, "sus scrofa|porcine|\\bpig\\b|swine") ~ "Sus scrofa",

      # Cow / bovine
      str_detect(host_text, "bos taurus|bovine|\\bcow\\b|cattle") ~ "Bos taurus",

      # Dog / canine (normalize variants)
      str_detect(host_text, "canis lupus familiaris|canis familiaris|\\bdog\\b|canine") ~ "Canis lupus familiaris",

      # Chicken / poultry
      str_detect(host_text, "gallus gallus|\\bchicken\\b|poultry") ~ "Gallus gallus",

      # Silkworm
      str_detect(host_text, "bombyx mori|silkworm") ~ "Bombyx mori",

      # Drosophila / fruit fly
      str_detect(host_text, "drosophila|fruit fly") ~ "Drosophila melanogaster",

      # Termite
      str_detect(host_text, "\\btermite\\b") ~ "Termite",

      # Zebrafish
      str_detect(host_text, "danio rerio|zebrafish") ~ "Danio rerio",

      # Generic fish (also catch “fishbut”-style glued tokens)
      str_detect(host_text, "\\bfish\\w*\\b") ~ "Actinopterygii (fish)",

      # Bats and other taxa (from your counts)
      str_detect(host_text, "barbastella barbastellus") ~ "Barbastella barbastellus",
      str_detect(host_text, "glauconycteris\\s*sp\\.?") ~ "Glauconycteris sp",
      str_detect(host_text, "hipposideros ruber") ~ "Hipposideros ruber",
      str_detect(host_text, "rhinolophus capensis") ~ "Rhinolophus capensis",

      # Vulture
      str_detect(host_text, "cathartes aura") ~ "Cathartes aura",

      # Grasshopper
      str_detect(host_text, "\\bgrasshopper\\b") ~ "Grasshopper",

      # New primate + fish species from your list
      str_detect(host_text, "macaca fascicularis") ~ "Macaca fascicularis",
      str_detect(host_text, "oncorhynchus mykiss") ~ "Oncorhynchus mykiss",
      str_detect(host_text, "oreochromis niloticus") ~ "Oreochromis niloticus",

      TRUE ~ host_species
    )
  )

# 3) Normalize existing host_species text so class/order rules match reliably
genome_metadata <- genome_metadata %>%
  mutate(
    hs_lower = str_to_lower(host_species),
    host_species = dplyr::case_when(
      # canonicalize common variants
      str_detect(hs_lower, "^canis(\\s+lupus)?\\s+familiaris$") ~ "Canis lupus familiaris",
      str_detect(hs_lower, "^drosophila melanogaster$") ~ "Drosophila melanogaster",
      str_detect(hs_lower, "^bombyx mori$") ~ "Bombyx mori",
      str_detect(hs_lower, "^danio rerio$") ~ "Danio rerio",
      str_detect(hs_lower, "^homo sapiens$") ~ "Homo sapiens",

      # catch glued fish tokens (e.g., "fishbut", "fishsomething")
      str_detect(hs_lower, "^fish\\w*$") ~ "Actinopterygii (fish)",

      TRUE ~ host_species
    )
  ) %>%
  dplyr::select(-hs_lower)

# 4) Fill host_class / host_order ONLY when missing — extended with your species
genome_metadata <- genome_metadata %>%
  mutate(
    # CLASS
    host_class = dplyr::case_when(
      !is_blank(host_class) ~ host_class,

      str_detect(coalesce(host_species, ""), "Homo sapiens|Mus musculus|Rattus norvegicus|Sus scrofa|Bos taurus|Canis lupus familiaris|Barbastella barbastellus|Glauconycteris sp|Hipposideros ruber|Rhinolophus capensis|Macaca fascicularis") ~ "Mammalia",
      str_detect(coalesce(host_species, ""), "Gallus gallus|Cathartes aura") ~ "Aves",
      str_detect(coalesce(host_species, ""), "Drosophila melanogaster|Bombyx mori|Termite|Grasshopper") ~ "Insecta",
      str_detect(coalesce(host_species, ""), "Danio rerio|Oncorhynchus mykiss|Oreochromis niloticus|Actinopterygii") ~ "Actinopterygii",

      TRUE ~ host_class
    ),

    # ORDER
    host_order = dplyr::case_when(
      !is_blank(host_order) ~ host_order,

      # Mammals
      str_detect(coalesce(host_species, ""), "Homo sapiens|Macaca fascicularis") ~ "Primates",
      str_detect(coalesce(host_species, ""), "Mus musculus|Rattus norvegicus") ~ "Rodentia",
      str_detect(coalesce(host_species, ""), "Sus scrofa|Bos taurus") ~ "Artiodactyla",
      str_detect(coalesce(host_species, ""), "Canis lupus familiaris") ~ "Carnivora",
      str_detect(coalesce(host_species, ""), "Barbastella barbastellus|Glauconycteris sp|Hipposideros ruber|Rhinolophus capensis") ~ "Chiroptera",

      # Birds
      str_detect(coalesce(host_species, ""), "Gallus gallus") ~ "Galliformes",
      # Choose one scheme and be consistent; using Accipitriformes here
      str_detect(coalesce(host_species, ""), "Cathartes aura") ~ "Accipitriformes",

      # Insects
      str_detect(coalesce(host_species, ""), "Drosophila melanogaster") ~ "Diptera",
      str_detect(coalesce(host_species, ""), "Bombyx mori") ~ "Lepidoptera",
      str_detect(coalesce(host_species, ""), "Termite") ~ "Isoptera",
      str_detect(coalesce(host_species, ""), "Grasshopper") ~ "Orthoptera",

      # Fish (species-level)
      str_detect(coalesce(host_species, ""), "Danio rerio") ~ "Cypriniformes",
      str_detect(coalesce(host_species, ""), "Oncorhynchus mykiss") ~ "Salmoniformes",
      str_detect(coalesce(host_species, ""), "Oreochromis niloticus") ~ "Cichliformes",

      # Generic fish remains NA (unknown order)
      str_detect(coalesce(host_species, ""), "Actinopterygii \\(fish\\)") ~ NA_character_,

      TRUE ~ host_order
    )
  ) %>%
  # Drop helper column
  dplyr::select(-host_text)
```

```{r checking genome metadata}

genome_metadata %>%
  filter(is.na(host_class) | is.na(host_order) | host_class == "" | host_order == "") %>%
  dplyr::count(host_species, sort = TRUE)


genome_metadata %>%
  filter(host_species %in% c("Barbastella barbastellus", "Hipposideros ruber", "Glauconycteris sp",
                             "Cathartes aura", "Actinopterygii (fish)", "Grasshopper")) %>%
  dplyr::count(host_species, host_class, host_order, sort = TRUE)

```


```{r country_normalization}
library(countrycode)

# 1) Simplify country strings like "Country: Region"
genome_metadata <- genome_metadata %>%
  mutate(
    country_simple = str_trim(str_split_fixed(coalesce(country, ""), ":", 2)[, 1]),
    country_simple = na_if(country_simple, "")
  )

# 2) Normalization map for common ENA/NCBI variants
.country_map <- c(
  # US variants
  "usa" = "United States",
  "u\\.s\\." = "United States",
  "u\\.s\\.a\\." = "United States",
  "united states of america" = "United States",

  # UK variants
  "uk" = "United Kingdom",
  "u\\.k\\." = "United Kingdom",
  "great britain" = "United Kingdom",
  "england" = "United Kingdom",
  "scotland" = "United Kingdom",
  "wales" = "United Kingdom",
  "northern ireland" = "United Kingdom",

  # Korea variants
  "korea,? republic of" = "South Korea",
  "republic of korea"   = "South Korea",
  "south korea"         = "South Korea",
  "korea,? \\(south\\)" = "South Korea",

  # China variants
  "pr china" = "China",
  "p\\.r\\. china" = "China",

  # Russia variants
  "russian federation" = "Russia",

  # Czech variants
  "czech republic" = "Czechia",

  # Eswatini / Swaziland; Côte d’Ivoire; DRC
  "swaziland" = "Eswatini",
  "cote d['’]ivoire" = "Côte d’Ivoire",
  "democratic republic of the congo" = "DR Congo",

  # Others commonly seen in ENA
  "viet nam" = "Vietnam",
  "myanmar \\(burma\\)" = "Myanmar",
  "bolivia \\(plurinational state of\\)" = "Bolivia",
  "iran,? islamic republic of" = "Iran",
  "syrian arab republic" = "Syria",
  "moldova,? republic of" = "Moldova",
  "lao people'?s democratic republic" = "Laos",
  "macedonia,? the former yugoslav republic of" = "North Macedonia",
  "palestine,? state of" = "Palestine",
  "hong kong" = "Hong Kong",
  "macau|macao" = "Macau"
)

# 3) Apply normalization: lowercase → map → title‑case fallback
normalize_country <- function(x) {
  y <- str_trim(tolower(coalesce(x, "")))
  y[y == ""] <- NA_character_

  # Apply regex replacements from the map (left to right)
  for (pat in names(.country_map)) {
    repl <- .country_map[[pat]]
    y <- ifelse(!is.na(y), str_replace_all(y, paste0("^", pat, "$"), repl), y)
  }

  # General cleanups for accents/spacing variants
  y <- ifelse(!is.na(y), str_replace_all(y, "\\s+", " "), y)
  y <- ifelse(!is.na(y), str_replace_all(y, "^people's republic of china$", "China"), y)

  # If still lowercased plain words (no mapping hit), title‑case them
  # (won’t fix every case, but keeps things readable)
  y <- ifelse(!is.na(y), str_to_title(y), y)

  # Final tidy: replace common leftover patterns
  y <- ifelse(!is.na(y), str_replace_all(y, " And ", " and "), y)  # cosmetic
  y
}


genome_metadata <- genome_metadata %>%
  dplyr::mutate(
    country_normalized = normalize_country(country_simple),
    continent = countrycode::countrycode(
      sourcevar   = country_normalized,
      origin      = "country.name",
      destination = "continent",
      warn        = TRUE
    )
  )


```

```{r human or animal}
genome_metadata <- genome_metadata %>%
  # Normalize casing/whitespace for host_species
  mutate(
    host_species_norm = str_squish(host_species),
    host_species_norm = if_else(
      str_detect(str_to_lower(coalesce(host_species_norm, "")), "^homo\\s+sapiens$"),
      "Homo sapiens",
      # Title-case other species names to keep them tidy (optional)
      str_to_title(host_species_norm)
    )
  ) %>%
  # Human vs animal classification
  mutate(
    host_type = case_when(
      host_species_norm == "Homo sapiens" ~ "human",
      !is.na(host_species_norm) & host_species_norm != "" ~ "animal",
      TRUE ~ NA_character_
    )
  ) %>%
  # Keep your normalized species as the main column (optional)
  mutate(host_species = host_species_norm) %>%
  dplyr::select(-host_species_norm)
```



```{r load master index_human}
# Read master index
master_index <- read_tsv("data/mags_metadata/master_mag_index_lactococcus_lactis.tsv") %>%
  mutate(
    # Extract the actual genome identifier from out_path
    genome_identifier = case_when(
      # For EHI: extract EHA00531_bin.1 from the filename
      str_detect(out_path, "EHA") ~ str_extract(out_path, "EHA[0-9]+_bin\\.[0-9]+"),
      # For NCBI: use the ID as is (GCA/GCF number)
      TRUE ~ ID
    )
  )
```

```{r mapping the ids to the genome identifiers_human}
# Check the mapping
print("Master index mapping:")
master_index %>% 
  dplyr::select(ID, genome_identifier, out_path) %>%
  head(10) %>%
  print()

# Read contig-to-genome mapping
contig_to_genome <- read_tsv("data/mags_metadata/lactococcus_lactis_contig_to_mag.tsv",
                              col_names = c("contig", "genome_filename"))
```


### Genome annotations



```{r load genome annotations}
# Read annotations and add IDs
genome_annotations <- read_tsv("data/mags_metadata/lactococcus_lactis_gene_annotations.tsv.xz") %>%
  mutate(contig = sub("_[^_]*$", "", gene)) %>%
  left_join(contig_to_genome, by = "contig") %>%
  mutate(genome= genome_filename)%>%
   filter(!is.na(genome))
```

#### REMOVE MAGs that do NOT belong to the species!! (specific lactococcus, rest should be fine)
```{r remove_duplicates_and_not_species_mags}
# Cleaner to normalize identifiers
clean_label <- function(x) {
  x <- basename(x)
  sub("\\.(fna|fa|fasta)(\\.gz)?$", "", x, ignore.case = TRUE)
}

# List to remove (MAGs that belong to other species <95% ANI)
mags_to_remove <- c(
  "GCA_018369575.1.fna","GCA_947063445.1.fna","GCA_947101685.1.fna","GCA_948698275.1.fna",
  "GCA_937910935.1.fna","GCA_947072755.1.fna","GCA_948655095.1.fna","GCA_948703095.1.fna",
  "GCA_947041925.1.fna","GCA_947073355.1.fna","GCA_948675165.1.fna","GCA_948718815.1.fna"
)
mags_to_remove_clean <- clean_label(mags_to_remove)

# ---------- genome_metadata: remove + dedup (keep best per ID) ----------
stopifnot("ID" %in% names(genome_metadata))

gm0 <- genome_metadata %>%
  mutate(ID_clean = clean_label(ID))

n_before_meta <- nrow(gm0)
n_to_remove_meta <- sum(gm0$ID_clean %in% mags_to_remove_clean)

genome_metadata_filtered <- gm0 %>%
  filter(!ID_clean %in% mags_to_remove_clean)

has_comp    <- "completeness"   %in% names(genome_metadata_filtered)
has_cont    <- "contamination"  %in% names(genome_metadata_filtered)
has_contigs <- "contigs"        %in% names(genome_metadata_filtered)

if (has_comp || has_cont || has_contigs) {
  genome_metadata_dedup <- genome_metadata_filtered %>%
    mutate(
      completeness  = if (has_comp)    as.numeric(completeness)  else NA_real_,
      contamination = if (has_cont)    as.numeric(contamination) else NA_real_,
      contigs       = if (has_contigs) as.numeric(contigs)       else NA_real_
    ) %>%
    arrange(
      ID_clean,
      desc(if (has_comp) completeness else 0),
      (if (has_cont) contamination else 0),
      (if (has_contigs) contigs else Inf)
    ) %>%
    distinct(ID_clean, .keep_all = TRUE)
} else {
  genome_metadata_dedup <- genome_metadata_filtered %>%
    distinct(ID_clean, .keep_all = TRUE)
}

genome_metadata_dedup <- genome_metadata_dedup %>%
  select(-ID_clean)

# ---------- genome_annotations: ONLY filter (NO dedup) ----------
stopifnot("genome" %in% names(genome_annotations))

ga0 <- genome_annotations %>%
  mutate(genome_clean = clean_label(genome))

n_before_ann <- nrow(ga0)
n_to_remove_ann <- sum(ga0$genome_clean %in% mags_to_remove_clean)

# Remove problematic genomes; keep all remaining genes
genome_annotations_filtered <- ga0 %>%
  filter(!genome_clean %in% mags_to_remove_clean) %>%
  select(-genome_clean)

# ---------- report ----------
cat("genome_metadata:\n")
cat("  - rows before:", n_before_meta, "\n")
cat("  - removed by species list:", n_to_remove_meta, "\n")
cat("  - rows after remove:", nrow(genome_metadata_filtered), "\n")
cat("  - rows after dedup:", nrow(genome_metadata_dedup), "\n\n")

cat("genome_annotations:\n")
cat("  - rows before:", n_before_ann, "\n")
cat("  - removed by species list:", n_to_remove_ann, "\n")
cat("  - rows after remove:", nrow(genome_annotations_filtered), "\n")

# (optional) assign back
genome_metadata   <- genome_metadata_dedup
genome_annotations <- genome_annotations_filtered
```



### Distill annotations into GIFTs

```{r distill_annotations, warning=FALSE, comments="", message=FALSE}
genome_gifts <- distill(genome_annotations,GIFT_db,genomecol= 19, annotcol=c(5,6,7,8), verbosity = F)
```



### Load trees
```{r load trees_human}
genome_metadata$mag_name <- sub("\\.fa$", "", genome_metadata$mag_name)#remove .fa from the mag names so that they match the tree ids
```



# Data Statistics
Total number of MAGs
```{r count n MAGS}
genome_metadata %>%
  dplyr::count(source)

genome_metadata %>% dplyr::count(host_species)

genome_metadata %>% dplyr::count(host_order)

genome_metadata %>% dplyr::count(host_class)
```

### Remove the MAGs with no host metadata
```{r remove_mags}
genome_metadata <- genome_metadata %>%
  filter(!is.na(host_class))
```



### Mean completeness and contamination
```{r mean completeness and contamination}
genome_metadata %>% 
  summarise(
    mean_c = mean(completeness, na.rm = TRUE) %>% round(2),
    sd_c = sd(completeness, na.rm = TRUE) %>% round(2),
    mean_con = mean(contamination, na.rm = TRUE) %>% round(2),
    sd_con = sd(contamination, na.rm = TRUE) %>% round(2)
  ) %>%
  unite("Completeness", mean_c, sd_c, sep = " ± ") %>%
  unite("Contamination", mean_con, sd_con, sep = " ± ") %>%
  tt()
```


```{r genome_quality_plot, message=FALSE, warning=FALSE, fig.height=6, fig.width=10, fig.fullwidth=TRUE}

#Generate quality biplot
genome_biplot <- genome_metadata %>%
  dplyr::select(c(ID,completeness,contamination, host_order)) %>%
  ggplot(aes(x=completeness,y=contamination, color = host_order)) +
  scale_color_manual(values = host_order_colors, name = "Host Order")+
              geom_point(alpha=0.7, size = 4) +
                    xlim(c(90,100)) +
                    ylim(c(2.5,0)) +
                    labs(y= "Contamination", x = "Completeness") +
                    theme_classic() +
                    theme(legend.position = "left",
                          axis.text.y = element_text(size=12),
                          axis.text.x = element_text(size=12),
                          axis.title.x = element_text(size = 16, face = "bold"),
                          axis.title.y = element_text(size = 16, face = "bold"))

#Generate contamination boxplot
genome_contamination <- genome_metadata %>%
            ggplot(aes(y=contamination)) +
                    ylim(c(2.5,0)) +
                    geom_boxplot(colour = "#999999", fill="#cccccc") +
                    theme_classic() +
                    theme(legend.position = "none",
                    axis.line = element_blank(),
                    axis.title = element_blank(),
                    axis.text=element_blank(),
                    axis.ticks=element_blank(),
                        plot.margin = unit(c(0, 0, 0.40, 0),"inches")) #add bottom-margin (top, right, bottom, left)

#Generate completeness boxplot
genome_completeness <- genome_metadata %>%
        ggplot(aes(x=completeness)) +
                xlim(c(90,100)) +
                geom_boxplot(colour = "#999999", fill="#cccccc") +
                theme_classic() +
                theme(legend.position = "none",
                    axis.line = element_blank(),
                    axis.title = element_blank(),
                    axis.text=element_blank(),
                    axis.ticks=element_blank(),
                    plot.margin = unit(c(0, 0, 0, 0.50),"inches")) #add left-margin (top, right, bottom, left)

#Render composite figure
#pdf("figures/completeness_contamination.pdf",width=10, height=5)
grid.arrange(grobs = list(genome_completeness,genome_biplot,genome_contamination),
        layout_matrix = rbind(c(1,1,1,1,1,1,1,1,1,1,1,4),
                              c(2,2,2,2,2,2,2,2,2,2,2,3),
                              c(2,2,2,2,2,2,2,2,2,2,2,3),
                              c(2,2,2,2,2,2,2,2,2,2,2,3),
                              c(2,2,2,2,2,2,2,2,2,2,2,3),
                              c(2,2,2,2,2,2,2,2,2,2,2,3),
                              c(2,2,2,2,2,2,2,2,2,2,2,3),
                              c(2,2,2,2,2,2,2,2,2,2,2,3),
                              c(2,2,2,2,2,2,2,2,2,2,2,3),
                              c(2,2,2,2,2,2,2,2,2,2,2,3),
                              c(2,2,2,2,2,2,2,2,2,2,2,3),
                              c(2,2,2,2,2,2,2,2,2,2,2,3)))
#dev.off()
```



```{r genome size plot}
ggplot(genome_metadata, aes(x= ID, y = genome_size, fill = host_order))+
  scale_fill_manual(values = host_order_colors)+
  geom_col()+ 
  theme_classic()


ggplot(genome_metadata, aes(x= source, y = genome_size, fill = source))+
  scale_fill_manual(values = source_colors)+
  geom_violin()+ 
  geom_point()+
  theme_classic()+
  labs(y = "Genome Size", x = "Source")


genome_metadata %>%
  filter(!is.na(host_class)) %>% 
ggplot(aes(x= host_type, y = genome_size, fill = host_type))+
  scale_fill_manual(values = host_type_colors)+
  geom_violin()+ 
  geom_point()+
  theme_classic()+
  labs(y = "Genome Size", x = "Host Type")
```
```{r lowest_genome_size}
genome_metadata%>%
  filter(genome_size == min(genome_size))
```




```{r contamination and completeness plots}
ggplot(genome_metadata, aes(x= ID, y = contamination, fill = source))+
  scale_fill_manual(values = source_colors)+
  geom_col()+ 
  theme_classic()


ggplot(genome_metadata, aes(x= source, y = contamination, fill = source))+
  scale_fill_manual(values = source_colors)+
  geom_boxplot()+ 
  theme_classic()+
  labs(y = "Contamination", x = "Source")

ggplot(genome_metadata, aes(x= ID, y = completeness, fill = source))+
  scale_fill_manual(values = source_colors)+
  geom_col()+ 
  theme_classic()


ggplot(genome_metadata, aes(x= source, y = completeness, fill = source))+
  scale_fill_manual(values = source_colors)+
  geom_violin()+
 geom_point()+
  theme_classic()+
  labs(y = "Completeness", x = "Source")

ggplot(genome_metadata, aes(x= host_type, y = completeness, fill = host_type))+
  scale_fill_manual(values = host_type_colors)+
  geom_violin()+
 geom_point()+
  theme_classic()+
  labs(y = "Completeness", x = "Host Type")
```
```{r plot togetehr}
genome_metadata_long <- genome_metadata %>%
  filter(!is.na(host_class))%>%
  mutate(genome_size_mb = genome_size/10^6)%>%
  pivot_longer(
    cols = c(genome_size_mb, contamination, completeness),
    names_to = "metric",
    values_to = "value"
  ) %>%
  mutate(
    metric = factor(metric, 
                   levels = c("genome_size_mb","contamination" , "completeness"),
                   labels = c("Genome Size (Mb)", "Contamination (%)" , "Completeness (%)"))
  )

faceted_plot <- ggplot(genome_metadata_long, 
                       aes(x = source, y = value, fill = source)) +
  scale_fill_manual(values = source_colors) +
  geom_violin() +
  geom_point() +
  facet_wrap(~ metric, scales = "free_y", ncol = 2) +
  theme_classic() +
  theme(
    strip.background = element_rect(fill = "white", color = "black"),
    strip.text = element_text(face = "bold", size = 11)
  ) +
  labs(y = "Value", x = "Source", fill = "Source")

print(faceted_plot)
```
```{r plots with animal vs human}
faceted_plot <- ggplot(genome_metadata_long, 
                       aes(x = host_type, y = value, fill = host_type)) +
  scale_fill_manual(values = host_type_colors) +
  geom_violin() +
  geom_point() +
  facet_wrap(~ metric, scales = "free_y", ncol = 2) +
  theme_classic() +
  theme(
    strip.background = element_rect(fill = "white", color = "black"),
    strip.text = element_text(face = "bold", size = 11)
  ) +
  labs(y = "Value", x = "Source", fill = "Host Type")

print(faceted_plot)
```


```{r stats_comparing}
#Comparing animal vs human
wilcox.test(contamination ~ host_type, data=genome_metadata)  %>%
  tidy()

wilcox.test(completeness ~ host_type, data=genome_metadata)  %>%
  tidy()

wilcox.test(genome_size ~ host_type, data=genome_metadata)  %>%
  tidy()

#Comparing sources
kruskal.test(contamination ~ source, data=genome_metadata)  %>%
  tidy()

kruskal.test(completeness ~ source, data=genome_metadata)  %>%
  tidy()

kruskal.test(genome_size ~ source, data=genome_metadata)  %>%
  tidy()

```

```{r stats_mean}
# Combine the summaries
ehi_stats <- genome_metadata %>%
  filter(host_type == "animal") %>%
  mutate(genome_size_mb = genome_size/1000000) %>%
  summarise(
    m_gs = round(mean(genome_size_mb), 2),
    sd_gs = round(sd(genome_size_mb), 2), 
    m_cont = round(mean(contamination), 2),
    sd_cont = round(sd(contamination), 2),
    m_comp = round(mean(completeness), 2),
    sd_comp = round(sd(completeness), 2)
  ) %>%
  unite("Mean genome size",m_gs, sd_gs, sep = " ± ", remove = TRUE) %>%
  unite("Mean completeness",m_comp, sd_comp, sep = " ± ", remove = TRUE) %>%
  unite("Mean contamination",m_cont, sd_cont, sep = " ± ", remove = TRUE) %>%
  mutate(Host_type = "animal") %>%
  dplyr::select(Host_type, everything())

gtdb_stats <- genome_metadata %>%
  filter(host_type == "human") %>%
  filter(!is.na(genome_size)) %>%
  mutate(genome_size_mb = genome_size/1000000) %>%
  summarise(
    m_gs = round(mean(genome_size_mb), 2),
    sd_gs = round(sd(genome_size_mb), 2),
    m_cont = round(mean(contamination), 2),
    sd_cont = round(sd(contamination), 2),
    m_comp = round(mean(completeness), 2),
    sd_comp = round(sd(completeness), 2)
  ) %>%
   unite("Mean genome size",m_gs, sd_gs, sep = " ± ", remove = TRUE) %>%
  unite("Mean completeness",m_comp, sd_comp, sep = " ± ", remove = TRUE) %>%
  unite("Mean contamination",m_cont, sd_cont, sep = " ± ", remove = TRUE) %>%
  mutate(Host_type = "human") %>%
  dplyr::select(Host_type, everything())

# Combine into one table
summary_table <- bind_rows(ehi_stats, gtdb_stats)

summary_table
```


### Country
```{r map}
library(rnaturalearth)
library(rnaturalearthdata)
library(sf) 


world <- ne_countries(scale = "medium", returnclass = "sf")

mag_locations <- genome_metadata %>%
  filter(!is.na(country)) %>%
  left_join(
    world %>%
      dplyr::select(name, geometry) %>%
      st_centroid() %>%
      st_coordinates() %>%
      as_tibble() %>%
      bind_cols(world %>% dplyr::select(name)) ,
    by = c("country" = "name")
  )

mag_locations%>% dplyr::select(ID, host_type, country)

ggplot(world) +
  geom_sf(fill = "gray95", color = "gray80") +
  geom_point(
    data = mag_locations,
    aes(x = X, y = Y, color = host_type),
    size = 2.5,
    alpha = 0.5
  ) +
  scale_color_manual(values = host_type_colors) +
  theme_minimal() +
  labs(color = "Host Type")



```



```{r host class plot,  fig.width = 15, fig.height = 15}
plot_df <- genome_metadata %>%
  dplyr::filter(!is.na(host_species), !is.na(host_class))

species_plot <- ggplot(plot_df, aes(x = host_species, fill = source)) +
  geom_bar(position = "stack") +
  facet_wrap(~ host_class, scales = "free_x") +
  scale_fill_manual(values = source_colors, name = "Source") +
  theme_bw(base_size = 14) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.title.x = element_text(size = 16),
    axis.title.y = element_text(size = 16),
    strip.text = element_text(size = 14, face = "bold")
  ) +
  labs(
    x = "Host species",
    y = "Number of MAGs"
  )

species_plot
#ggsave("./plots/species_plot.png", species_plot, dpi = 300, units = "cm", width = 18, height = 10)

```


```{r country distribution plot, eval = FALSE}
plot_df <- genome_metadata %>%
  dplyr::filter(!is.na(country_normalized))%>%
  dplyr::filter(country_normalized != "none")

library(stringr)

dist_plot <- ggplot(plot_df, aes(x = country_normalized, fill = host_order)) +
  geom_bar(position = "stack") +
  facet_grid(
    ~ continent,
    scales = "free_x",
    space  = "free_x",
    labeller = labeller(
      continent = function(x) str_wrap(x, width = 10)
    )
  ) +
  scale_fill_manual(values = host_order_colors, name = "Host order") +
  theme_bw(base_size = 14) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.title.x = element_text(size = 16),
    axis.title.y = element_text(size = 16),
    strip.text = element_text(size = 12, face = "bold")
  ) +
  labs(
    x = "Country",
    y = "Number of MAGs"
  )

dist_plot
#ggsave("./plots/dist_plot.png", dist_plot, dpi = 300, units = "cm", width = 30, height = 12)


```



# Phylogenetic analysis

## dRep tree


```{r load drep files}
fastani_comparisons <- read_csv("data/mags_metadata/lactococcus_lactis_Ndb.csv")  #Secondary comparison results
```



```{r recreate drep tree}
genomes <- unique(c(fastani_comparisons$reference, fastani_comparisons$querry))

# Create empty matrix
ani_matrix <- matrix(0, nrow = length(genomes), ncol = length(genomes))
rownames(ani_matrix) <- genomes
colnames(ani_matrix) <- genomes

# Fill the matrix
for(i in 1:nrow(fastani_comparisons)) {
  ref <- fastani_comparisons$reference[i]
  qry <- fastani_comparisons$querry[i]
  ani_val <- fastani_comparisons$ani[i]
  
  ani_matrix[ref, qry] <- ani_val
  ani_matrix[qry, ref] <- ani_val  # Make symmetric
}

# Set diagonal to 100
diag(ani_matrix) <- 100

# Convert to distance matrix (for tree building)
dist_matrix <- as.dist(1 - ani_matrix)

# Build tree
hc <- hclust(dist_matrix, method = "average") #drep uses hierarchical clustering
tree <- as.phylo(hc)

ggtree(tree) + 
  geom_tiplab(size = 2) +
  theme_tree2()
```



```{r final drep tree}
fastani_path <- "data/mags_metadata/lactococcus_lactis_Ndb.csv"

metadata <- genome_metadata
id_col   <- "ID"   

# Drop any outliers or specific IDs (use IDs without file suffix)
drop_ids <- character(0)  

# Impute missing ANI pairs 
# "max_distance" (most conservative), "min_ani", or a fixed numeric between 0 and 1
impute_mode <- "max_distance"

# helper: strip file extensions so IDs match metadata
clean_label <- function(x) {
  x <- basename(x)
  sub("\\.(fna|fa|fasta)(\\.gz)?$", "", x, ignore.case = TRUE)
}

# Load & normalize fastani table
fastani_raw <- readr::read_csv(fastani_path, show_col_types = FALSE)

fastani <- fastani_raw %>%
  dplyr::rename(
    reference = dplyr::any_of(c("reference", "ref", "Reference")),
    query     = dplyr::any_of(c("query", "querry", "Qry", "Query")),
    ani       = dplyr::any_of(c("ani", "ANI", "ani_1", "ANI_1"))
  ) %>%
  dplyr::select(reference, query, ani) %>%
  dplyr::filter(!is.na(reference), !is.na(query), reference != query)

# Normalize ANI to [0,1] if needed
ani_max <- max(fastani$ani, na.rm = TRUE)
if (is.finite(ani_max) && ani_max > 1) {
  fastani <- fastani %>% dplyr::mutate(ani = ani / 100)
}

# Clean IDs to remove extensions
fastani <- fastani %>%
  dplyr::mutate(
    reference = clean_label(reference),
    query     = clean_label(query)
  ) %>%
  dplyr::filter(reference != query)

# Remove duplicate pairs (keep the max ANI per pair)
fastani <- fastani %>%
  dplyr::group_by(reference, query) %>%
  dplyr::summarise(ani = max(ani), .groups = "drop")

# Optionally drop genomes (IDs without suffix)
if (length(drop_ids) > 0) {
  fastani <- fastani %>%
    dplyr::filter(!reference %in% drop_ids, !query %in% drop_ids)
}

# Build a symmetric ANI matrix with diag = 1 (dedup-safe)
build_ani_matrix <- function(df) {
  genomes <- sort(unique(c(df$reference, df$query)))

  both <- dplyr::bind_rows(
    df %>% dplyr::transmute(reference, query, ani),
    df %>% dplyr::transmute(reference = query, query = reference, ani)
  ) %>%
    dplyr::distinct(reference, query, .keep_all = TRUE)

  ani_mat <- both %>%
    tidyr::complete(reference = genomes, query = genomes) %>%
    tidyr::pivot_wider(
      names_from  = query,
      values_from = ani,
      values_fn   = max  # <-- ensure no duplicate cells cause errors
    ) %>%
    tibble::column_to_rownames("reference") %>%
    as.matrix()

  diag(ani_mat) <- 1

  # Impute missing if any
  if (anyNA(ani_mat)) {
    if (impute_mode == "max_distance") {
      fill_val <- min(ani_mat, na.rm = TRUE)
    } else if (impute_mode == "min_ani") {
      fill_val <- min(ani_mat, na.rm = TRUE)
    } else if (is.numeric(impute_mode) && impute_mode >= 0 && impute_mode <= 1) {
      fill_val <- impute_mode
    } else {
      fill_val <- min(ani_mat, na.rm = TRUE)
    }
    ani_mat[is.na(ani_mat)] <- fill_val
  }

  ani_mat
}

ani_mat <- build_ani_matrix(fastani)

# Build the tree (UPGMA/average as in dRep)
build_tree_from_ani <- function(ani_mat, method = "average") {
  dist_mat <- 1 - ani_mat
  hc <- hclust(as.dist(dist_mat), method = method)
  ape::as.phylo(hc)
}

tree <- build_tree_from_ani(ani_mat)

# De-duplicate metadata by ID and clean ID if needed
metadata_dedup <- metadata %>%
  dplyr::mutate(!!id_col := clean_label(.data[[id_col]])) %>%  # safe if already clean
  dplyr::distinct(.data[[id_col]], .keep_all = TRUE)

# Add metadata to tips (tree labels are already clean IDs)
make_tip_df <- function(tree, metadata_dedup, id_col) {
  stopifnot(id_col %in% names(metadata_dedup))
  tibble::tibble(label = tree$tip.label) %>%
    dplyr::left_join(metadata_dedup, by = setNames(id_col, "label")) %>%
    dplyr::mutate(label_clean = label)  # keep a consistent column if you use it in labels
}

tip_df <- make_tip_df(tree, metadata_dedup, id_col = id_col)

# Helper for ANI axis labels (unchanged)
ani_axis <- function(p, tree, show_threshold = NULL) {
  df <- ggtree::fortify(tree)
  max_x <- max(df$x[df$isTip])
  p <- p +
    scale_x_continuous(
      labels = function(x) round(100 * (1 - (max_x - x)), 1)
    ) +
    coord_cartesian(xlim = c(0, max_x + 0.005)) +
    labs(x = "Average Nucleotide Identity (ANI, %)") +
    theme_tree2()
  if (!is.null(show_threshold)) {
    thr_delta <- 1 - (show_threshold / 100)
    p <- p + geom_vline(xintercept = max_x - thr_delta,
                        linetype = "dashed", color = "red", size = 0.8)
  }
  p
}

# - BASIC PLOT --
plot_tree_basic <- function(tree, tip_df, color_by = NULL, label_tips = TRUE,
                            point_size = 2.5, show_threshold = NULL) {
  # ensure completeness numeric for continuous gradients
  if ("completeness" %in% names(tip_df)) {
    tip_df <- tip_df %>% dplyr::mutate(completeness = as.numeric(completeness))
  }

  p <- ggtree(tree, size = 0.8)
  p <- p %<+% tip_df

  if (!is.null(color_by) && color_by %in% names(tip_df)) {
    p <- p + geom_tippoint(aes(color = !!rlang::sym(color_by)), size = point_size)

    # Palette/scale logic
    if (identical(color_by, "source") && exists("source_colors")) {
      p <- p + scale_color_manual(values = source_colors, name = "Source", drop = FALSE)
    } else if (identical(color_by, "host_order") && exists("host_order_colors")) {
      p <- p + scale_color_manual(values = host_order_colors, name = "Host order", drop = FALSE)
    } else if (is.numeric(tip_df[[color_by]])) {
      p <- p + scale_color_gradient(low = "white", high = "#08306B",
                                    name = paste0(color_by, " (%)"))
    }
  } else {
    p <- p + geom_tippoint(size = point_size)
  }

  if (label_tips) {
    lab_col <- if ("label_clean" %in% names(tip_df)) "label_clean" else "label"
    p <- p + geom_tiplab(size = 3, hjust = -0.1, aes(label = .data[[lab_col]]))
  }

  ani_axis(p, tree, show_threshold = show_threshold)
}

# - MULTI-AESTHETIC PLOT --
plot_tree_multi <- function(tree, tip_df,
                            color_by = NULL,
                            shape_by = NULL,
                            size_by  = NULL,
                            label_tips = TRUE,
                            show_threshold = NULL) {
  if ("completeness" %in% names(tip_df)) {
    tip_df <- tip_df %>% dplyr::mutate(completeness = as.numeric(completeness))
  }

  p <- ggtree(tree, size = 0.8)
  p <- p %<+% tip_df

  aes_map <- aes()
  if (!is.null(color_by) && color_by %in% names(tip_df)) aes_map <- modifyList(aes_map, aes(color = !!rlang::sym(color_by)))
  if (!is.null(shape_by) && shape_by %in% names(tip_df)) aes_map <- modifyList(aes_map, aes(shape = !!rlang::sym(shape_by)))
  if (!is.null(size_by)  && size_by  %in% names(tip_df)) aes_map <- modifyList(aes_map, aes(size  = !!rlang::sym(size_by)))

  p <- p + geom_tippoint(aes_map, stroke = 0.3)

  if (!is.null(color_by) && color_by %in% names(tip_df)) {
    if (identical(color_by, "source") && exists("source_colors")) {
      p <- p + scale_color_manual(values = source_colors, name = "Source", drop = FALSE)
    } else if (identical(color_by, "host_order") && exists("host_order_colors")) {
      p <- p + scale_color_manual(values = host_order_colors, name = "Host order", drop = FALSE)
    } else if (is.numeric(tip_df[[color_by]])) {
      p <- p + scale_color_gradient(low = "white", high = "#08306B",
                                    name = paste0(color_by, " (%)"))
    }
  }

  if (label_tips) {
    lab_col <- if ("label_clean" %in% names(tip_df)) "label_clean" else "label"
    p <- p + geom_tiplab(size = 3, hjust = -0.1, aes(label = .data[[lab_col]]))
  }

  ani_axis(p, tree, show_threshold = show_threshold)
}
```



```{r tree_plots, fig.height= 12, fig.width = 10}
p_source <- plot_tree_basic(tree, tip_df, color_by = "source", label_tips = TRUE,
                            show_threshold = 99.5)
p_source

p_host <- plot_tree_basic(tree, tip_df, color_by = "host_species",
                          label_tips = TRUE, show_threshold = 99.5)
p_host

p_host_order <- plot_tree_basic(tree, tip_df, color_by = "host_order",
                          label_tips = TRUE, show_threshold = 99.5)
p_host_order

p_continent <- plot_tree_basic(tree, tip_df, color_by = "continent",
                          label_tips = TRUE, show_threshold = 99.5)
p_continent

# Color tips by completeness (0–100; 100 = dark blue, 0 = white)
p_comp <- plot_tree_basic(tree, tip_df, color_by = "completeness",
                          label_tips = TRUE, show_threshold = 99.5)
p_comp


p_multi <- plot_tree_multi(
  tree, tip_df,
  color_by = "host_order",
  size_by  = "completeness",
  label_tips = TRUE,
  show_threshold = 99.5
)
p_multi



```


```{r saving figs, eval = FALSE}
ggsave("plots/tree_by_source.png", p_source, width = 10, height = 8, dpi = 300)
ggsave("plots/tree_by_host.png",   p_host,   width = 10, height = 8, dpi = 300)
ggsave("plots/tree_combo.png",     p_combo,  width = 12, height = 9, dpi = 300)
ggsave("plots/tree_full_heatmap.png", p_full, width = 12, height = 10, dpi = 300)
```


# Functional Analysis
## Functional overview
```{r genomes annotated}
n_genes <- genome_annotations %>%
  group_by(genome) %>%
  summarize(n_genes = n())

head(n_genes)
```


#### Predicted genes
```{r predicted_stats, message=FALSE, warning=FALSE}
pred_genes <- genome_annotations %>%
  nrow()

cat(pred_genes)
```

#### Number of annotated genes and percentages
```{r annotation_stats, message=FALSE, warning=FALSE}
#How many genes have at least 1 annotation
genome_annota <- genome_annotations %>%
  filter(if_any(c(kegg, pfam, cazy), ~ !is.na(.))) %>%
  nrow()

cat(genome_annota)

#Percentage of predicted genes with at least 1 annotation
genome_annota*100/pred_genes
```

#### Number of KEGG annotatated genes and percentages
```{r kegg_stats_gut, message=FALSE, warning=FALSE}
# KEGG annotation
kegg_annota <- genome_annotations %>%
  filter(!is.na(kegg)) %>%
  nrow()
cat(kegg_annota)

# KEGG annotation percentage
kegg_annota*100/genome_annota


# AMR annotation
amr_annota <- genome_annotations %>%
  filter(resistance_type == "AMR") %>%
  nrow()
cat(amr_annota)

# AMR annotation percentage
amr_annota*100/genome_annota


# VF annotation
vf_annota <- genome_annotations %>%
  filter(!is.na(vf)) %>%
  nrow()
cat(vf_annota)

# VF annotation percentage
vf_annota*100/genome_annota
```

```{r n genes per mag}
n_pred_genes <- genome_annotations %>%
  group_by(genome) %>%
  summarize(n_genes = n()) %>%
  left_join(
    genome_metadata %>% dplyr::select(ID, host_type),
    by = c("genome" = "ID")
  )

annotated_genes <- genome_annotations %>%
  filter(if_any(c(kegg, pfam, cazy), ~ !is.na(.))) %>%
  group_by(genome) %>%
  summarize(n_annotated_genes = n()) %>%
  left_join(
    genome_metadata %>% dplyr::select(ID, host_type),
    by = c("genome" = "ID")
  )
```

```{r plotting n genes}
ggplot(n_pred_genes, aes(x= host_type, y = n_genes, fill = host_type))+
  scale_fill_manual(values = host_type_colors)+
  geom_boxplot()+ 
  geom_point()+
  theme_classic()+
  labs(y = "Gene Number", x = "Host Type")

ggplot(annotated_genes, aes(x= host_type, y = n_annotated_genes, fill = host_type))+
  scale_fill_manual(values = host_type_colors)+
  geom_boxplot()+ 
  geom_point()+
  theme_classic()+
  labs(y = "Annotated Gene Number", x = "Host Type")

wilcox.test(n_genes ~ host_type, data=n_pred_genes)  %>%
  tidy()


wilcox.test(n_annotated_genes ~ host_type, data=annotated_genes)  %>%
  tidy()

```


## KEGG
### Nº of MAGs with KOs
```{r mag counts per kegg}
#Proportion of MAGs belonging to each group per KEGG
#I want to know for example 5% of MAGs from anials have this KEGG, but 40 % of MAGs from humans have it

# KEGG presence/absence
kegg_presence <- genome_annotations %>%
  filter(!is.na(kegg)) %>%
  dplyr::select(genome, kegg) %>%
  distinct() 

#Add the host_type info
kegg_with_host_type <- kegg_presence %>%
  left_join(
    genome_metadata %>% dplyr::select(ID, host_type),
    by = c("genome" = "ID")
  )

# Count how many MAGs in each KEGG
kegg_mag_counts <- kegg_with_host_type %>%
  group_by(host_type, kegg) %>%
  summarise(
    n_mags = n(),
    .groups = "drop"
  )

#Count total MAGs per host_type (except the outlier)
total_mags_per_host_type <- genome_metadata %>%
  group_by(host_type) %>%
  summarise(
    total_mags = n_distinct(ID),
    .groups = "drop"
  )

#Calculate proportions of MAGs from each host_type in each KEGG
kegg_mag_proportions <- kegg_mag_counts %>%
  left_join(total_mags_per_host_type, by = "host_type") %>%
  mutate(
    proportion = n_mags / total_mags,
    absent = total_mags - n_mags
  )

```

#### Plotting KEGG MAG proportions
```{r plotting kegg mag proportions}
kegg_mag_proportions %>%
  filter(n_mags >= 20)
```

#### Statistical testing of MAG proportions
```{r statistical testing mag proportions}
fisher_results <- kegg_mag_proportions %>%
  dplyr::select(kegg, host_type, n_mags, absent) %>%
  pivot_wider(
    names_from = host_type,
    values_from = c(n_mags, absent),
    values_fill = 0
  ) %>%
  rowwise() %>%
  mutate(
    p_value = fisher.test(
      matrix(
        c(n_mags_animal,  absent_animal,
          n_mags_human, absent_human),
        nrow = 2,
        byrow = TRUE
      )
    )$p.value
  ) %>%
  ungroup() %>%
  mutate(p_adj = p.adjust(p_value, method = "BH"))

fisher_results <- fisher_results %>%
  mutate(
    prop_animal  = n_mags_animal  / (n_mags_animal  + absent_animal),
    prop_human = n_mags_human / (n_mags_human + absent_human),
    diff_prop = prop_human - prop_animal
  )
```

```{r volcano for fisher results}
volcano_df <- fisher_results %>%
  # Keep rows with non-missing p_adj and diff_prop
  filter(!is.na(p_adj), !is.na(diff_prop)) %>%
  # Avoid Inf y-values if p_adj == 0 by flooring at 1e-300 (or your choice)
  mutate(
    p_adj_capped = pmax(p_adj, 1e-300),
    nl10 = -log10(p_adj_capped),
    sig = p_adj < 0.05
  )


to_label <- volcano_df %>%
  filter(sig) %>%
  arrange(desc(nl10)) %>%
  dplyr::slice(1:10)

ggplot(volcano_df, aes(x = diff_prop, y = nl10)) +
  geom_point(aes(color = sig), alpha = 0.8, size = 2) +
  geom_text_repel(
    data = to_label,
    aes(label = kegg),        # or `Name`
    max.overlaps = 20,
    size = 3,
    segment.color = "grey70"
  ) +
  scale_color_manual(values = c(`TRUE` = "#1f77b4", `FALSE` = "grey70"), name ="p_adj < 0.05") +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "grey50") +
  theme_minimal() +
  labs(
    x = "Effect size (diff_prop)",
    y = expression(-log[10](p[adj])),
    title = "Volcano plot: differential KEGG presence"
  )

```


```{r fisher and volcano}
# Ensure host_type has the intended order
genome_metadata <- genome_metadata %>%
  mutate(host_type = factor(host_type, levels = c("animal", "human")))

# 1) KEGG presence (unique genome–kegg)
kegg_presence <- genome_annotations %>%
  dplyr::select(genome, kegg) %>%
  distinct() %>%
  filter(!is.na(kegg))

# 2) Add host type
kegg_with_host <- kegg_presence %>%
  left_join(
    genome_metadata %>% dplyr::select(ID, host_type),
    by = c("genome" = "ID")
  )

# 3) Count present per (kegg, host_type)
kegg_counts <- kegg_with_host %>%
  group_by(kegg, host_type) %>%
  summarise(n_present = n_distinct(genome), .groups = "drop")

# 4) Totals per host_type
totals <- genome_metadata %>%
  group_by(host_type) %>%
  summarise(total_mags = n_distinct(ID), .groups = "drop")

# 5) Complete grid and compute absent correctly
kegg_counts_complete <- kegg_counts %>%
  tidyr::complete(kegg, host_type, fill = list(n_present = 0)) %>%
  left_join(totals, by = "host_type") %>%
  mutate(n_absent = total_mags - n_present)

# 6) Pivot to 2×2 format
wide <- kegg_counts_complete %>%
  dplyr::select(kegg, host_type, n_present, n_absent) %>%
  pivot_wider(
    id_cols = kegg,
    names_from = host_type,
    values_from = c(n_present, n_absent),
    values_fill = 0
  )

# Sanity: ensure expected columns exist (adjust names if your levels differ)
stopifnot(all(c("n_present_animal","n_absent_animal","n_present_human","n_absent_human") %in% names(wide)))

wide <- wide %>%
  mutate(
    n_animal = n_present_animal,
    a_animal = n_absent_animal,
    n_human  = n_present_human,
    a_human  = n_absent_human
  )

# 7) SAFE P-VALUE: robust computation avoiding FEXACT 40
safe_fisher_p <- function(n_animal, a_animal, n_human, a_human) {
    m <- matrix(c(n_animal, a_animal, n_human, a_human), nrow = 2, byrow = TRUE)

    # If any row or column sums to zero, Fisher is fine (returns 1) or undefined;
    # handle degenerate cases: if all zero or all present, return p=1
    if (any(rowSums(m) == 0) || any(colSums(m) == 0)) {
        return(1.0)
    }

    # 1) Try exact Fisher with large workspace
    p1 <- tryCatch(
        fisher.test(m, workspace = 2e8)$p.value,
        error = function(e) NA_real_
    )
    if (!is.na(p1)) return(p1)

    # 2) Fall back to simulated Fisher
    p2 <- tryCatch(
        fisher.test(m, simulate.p.value = TRUE, B = 1e6)$p.value,
        error = function(e) NA_real_
    )
    if (!is.na(p2)) return(p2)

    # 3) Last resort: chi-square with Yates correction
    p3 <- tryCatch(
        suppressWarnings(chisq.test(m, correct = TRUE)$p.value),
        error = function(e) NA_real_
    )
    if (!is.na(p3)) return(p3)

    # If everything fails, return NA
    return(NA_real_)
}

# 8) Compute stats rowwise with robust p-values
fisher_df <- wide %>%
  rowwise() %>%
  mutate(
    # p-value
    p_value = safe_fisher_p(n_animal, a_animal, n_human, a_human),

    # proportions and difference
    prop_animal = ifelse((n_animal + a_animal) > 0, n_animal / (n_animal + a_animal), NA_real_),
    prop_human  = ifelse((n_human  + a_human)  > 0, n_human  / (n_human  + a_human),  NA_real_),
    diff_prop   = prop_human - prop_animal,

    # Haldane–Anscombe for OR if any zero cell (effect size only)
    needs_ha    = (n_animal == 0L) | (a_animal == 0L) | (n_human == 0L) | (a_human == 0L),
    n_animal_ha = ifelse(needs_ha, n_animal + 0.5, n_animal),
    a_animal_ha = ifelse(needs_ha, a_animal + 0.5, a_animal),
    n_human_ha  = ifelse(needs_ha, n_human  + 0.5, n_human),
    a_human_ha  = ifelse(needs_ha, a_human  + 0.5, a_human),

    or      = (n_human_ha * a_animal_ha) / (a_human_ha * n_animal_ha),
    log2_or = log2(or),

    # Relative risk with light Laplace smoothing (fold-change of proportions)
    rr      = ((n_human + 0.5)  / (n_human + a_human + 1)) /
              ((n_animal + 0.5) / (n_animal + a_animal + 1)),
    log2_rr = log2(rr)
  ) %>%
  ungroup() %>%
  mutate(p_adj = p.adjust(p_value, method = "BH"))

# 9) Optional prevalence filter to stabilize estimates
fisher_df <- fisher_df %>%
  mutate(total_present = n_animal + n_human) %>%
  filter(
    total_present >= 5 |
      prop_animal >= 0.03 | prop_human >= 0.03
  )

# 10) Volcano (log2 OR)
volcano_df <- fisher_df %>%
  filter(!is.na(p_adj), !is.na(log2_or)) %>%
  mutate(
    p_adj_capped = pmax(p_adj, 1e-300),
    nl10 = -log10(p_adj_capped),
    sig = p_adj < 0.05
  )

to_label <- volcano_df %>%
  filter(sig) %>%
  arrange(desc(nl10)) %>%
  dplyr::slice(1:10)

ggplot(volcano_df, aes(x = log2_or, y = nl10)) +
  geom_point(aes(color = sig), alpha = 0.8, size = 2) +
  geom_text_repel(
    data = to_label,
    aes(label = kegg),
    max.overlaps = 20,
    size = 3,
    segment.color = "grey70"
  ) +
  scale_color_manual(values = c(`TRUE` = "#1f77b4", `FALSE` = "grey70"), name = "FDR < 0.05") +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "grey50") +
  geom_vline(xintercept = c(-1, 1), linetype = "dotted", color = "grey60") + # OR ~0.5 and ~2
  theme_minimal() +
  labs(
    x = "Effect size (log2 odds ratio, human vs animal)",
    y = expression(-log[10](FDR)),
    title = "Volcano plot: differential KEGG presence (human vs animal)"
  )

# 11) Top 20 by significance then effect size
top20 <- fisher_df %>%
  arrange(p_adj, desc(abs(log2_or))) %>%
  dplyr::select(
    kegg,
    n_human, a_human, prop_human,
    n_animal, a_animal, prop_animal,
    diff_prop, log2_rr, log2_or, p_value, p_adj
  ) %>%
  dplyr::slice(1:20)

top20
```


```{r function to get info from KEGG}
library(KEGGREST)

# Function to get info from KEGG
get_kegg_info <- function(ko_id) {
  query <- keggGet(ko_id)[[1]]
  
  # Extract Name and Definition
  name <- ifelse(!is.null(query$NAME), query$NAME, "N/A")
  definition <- ifelse(!is.null(query$DEFINITION), query$DEFINITION, "N/A")
  
  # Extract Pathways (often multiple)
  pathways <- if(!is.null(query$PATHWAY)) {
    paste(names(query$PATHWAY), query$PATHWAY, sep = ": ", collapse = "; ")
  } else {
    "No pathway assigned"
  }
  
  return(c(KO = ko_id, Name = name, Definition = definition, Pathways = pathways))
}

```

```{r significant kos}
ko_list <- lapply(top20$kegg, get_kegg_info)
ko_summary <- as.data.frame(do.call(rbind, ko_list))

print(ko_summary)
```


```{r heatmap data}
fish_results_names <- left_join(top20, ko_summary, join_by(kegg== KO))


heatmap_data <- fish_results_names %>%
  dplyr::select(Name, prop_animal, prop_human)%>%
  pivot_longer(!Name, names_to = "host_type", values_to= "proportion" ) %>%
   mutate(
    host_type = case_when(
      host_type == "prop_animal"  ~ "animal",
      host_type == "prop_human" ~ "human",
      TRUE ~ host_type
    )
  )
```


```{r plot the keggs, fig.height = 10, fig.width= 14}
# 1) Reduce to one row per Name × host_type
heatmap_summary <- heatmap_data %>%
  group_by(Name, host_type) %>%
  summarise(
    proportion = mean(proportion, na.rm = TRUE),  # or median(), max(), first()
    .groups = "drop"
  )

# 2) Compute diff = animal - human in wide form
heatmap_wide <- heatmap_summary %>%
  filter(host_type %in% c("animal", "human")) %>%  # just in case there are other types
  tidyr::pivot_wider(
    names_from = host_type,
    values_from = proportion
  ) %>%
  mutate(
    diff = animal - human
  )

# 3) Reorder Name by diff and bring back to long for plotting
heatmap_plot <- heatmap_wide %>%
  mutate(Name = forcats::fct_reorder(Name, diff)) %>%
  tidyr::pivot_longer(
    cols = c(animal, human),
    names_to = "host_type",
    values_to = "proportion"
  )

# 4) Plot — heatmap
ggplot(heatmap_plot,
       aes(x = host_type, y = Name, fill = proportion)) +
  geom_tile() +
  geom_text(aes(label = scales::number(proportion, accuracy = 0.01)),
            size = 6) +
  scale_fill_viridis_c(
    name = "Proportion of MAGs",
    limits = c(0, 1)
  ) +
  theme_minimal() +
  labs(
    x = "host_type",
    y = "KEGG ortholog",
    title = "Differential KEGG presence between animal and human"
  )

```

```{r put it in a table}
table_data <- fish_results_names %>%
  transmute(
    `KEGG ortholog` = Name,
    `Proportion in animal`  = prop_animal,
    `Proportion in human` = prop_human,
    `Δ (human - animal)`  =  prop_human - prop_animal ,
    `Log2(Odds Ratio)`  =  log2_or ,
    `Fisher p-value`  = p_adj
  ) %>%
  arrange(desc(abs(`Δ (human - animal)`)))

table_data
```
```{r testing table format}
library(gt)

table_data %>%
  gt() %>%
  fmt_number(
    columns = c(`Proportion in animal`, `Proportion in human`, `Δ (human - animal)`, `Log2(Odds Ratio)` ),
    decimals = 2
  ) %>%
  fmt_scientific(
    columns = `Fisher p-value`,
    decimals = 2
  ) %>%
  tab_header(
    title = "KEGG orthologs differing between animal and human MAGs"
  ) %>%
  cols_align(
    align = "center",
    everything()
  )%>%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_column_labels(everything())
  )
```


### Functional Ordination

PCA of KEGG annotations:
```{r pca of kegg}
kegg_counts <- genome_annotations %>%
  filter(!is.na(kegg)) %>%          
  dplyr::count(genome, kegg) %>%           
  pivot_wider(
    names_from = kegg,
    values_from = n,
    values_fill = 0
  )

# Normalization
kegg_rel <- kegg_counts %>%
  column_to_rownames("genome")
kegg_rel <- kegg_rel / rowSums(kegg_rel)  # Each row sums to 1

# Remove zero variance
kegg_rel_nz <- kegg_rel[, apply(kegg_rel, 2, sd) > 0]

# PCA with scaling
pca <- prcomp(kegg_rel_nz, scale. = TRUE)

# Check variance explained
summary(pca)$importance[,1:5]
```
```{r country colors}
country_palette <- c(
  # Southern Europe
  "Spain" = "#1B9E77",
  "Italy" = "#33A02C",
  "Greece" = "#66C2A5",
  "Portugal" = "#2CA25F",
  "Malta" = "#99D8C9",

  # Northern/Central Europe
  "Germany" = "#1F78B4",
  "United Kingdom" = "#4A90E2",
  "Ireland" = "#6BAED6",

  # East Asia 
  "Japan" = "#E31A1C",
  "South Korea" = "#FB6A4A",
  "China" = "#CB181D",

  # North America 
  "USA" = "#756BB1",
  "Canada" = "#9E9AC8",

  # Distinct
  "Australia" = "#FFD92F",   
  "Greenland" = "#A6CEE3",

  "none" = "grey70"
)


```


```{r plot pca kegg}
scores <- as.data.frame(pca$x)
scores$ID <- rownames(scores)

scores <- scores %>%
  left_join(genome_metadata, by = "ID")

ggplot(scores, aes(PC1, PC2, color = host_type, label = ID)) +
  geom_point(size = 2) +
   scale_color_manual(values = host_type_colors)+
  theme_minimal() +
  labs(
    title = "PCA of KEGG annotations across MAGs",
    x = paste0("PC1 (", round(summary(pca)$importance[2,1] * 100, 1), "%)"),
    y = paste0("PC2 (", round(summary(pca)$importance[2,2] * 100, 1), "%)")
  ) + geom_text_repel()


##PCA again without outlier
kegg_counts <- genome_annotations %>%
  filter(genome != "EHM071389") %>%
  filter(!is.na(kegg)) %>%          
  dplyr::count(genome, kegg) %>%           
  pivot_wider(
    names_from = kegg,
    values_from = n,
    values_fill = 0
  )

# Normalization
kegg_rel <- kegg_counts %>%
  column_to_rownames("genome")
kegg_rel <- kegg_rel / rowSums(kegg_rel)  # Each row sums to 1

# Remove zero variance
kegg_rel_nz <- kegg_rel[, apply(kegg_rel, 2, sd) > 0]

# PCA with scaling
pca <- prcomp(kegg_rel_nz, scale. = TRUE)

# Check variance explained
summary(pca)$importance[,1:5]

scores_filtered <- scores %>% filter(ID != "EHM071389")

ggplot(scores_filtered, aes(PC1, PC2, color = host_type)) +
  geom_point(size = 2) +
   scale_color_manual(values = host_type_colors)+
  theme_minimal() +
  labs(
    title = "PCA of KEGG annotations across MAGs",
    x = paste0("PC1 (", round(summary(pca)$importance[2,1] * 100, 1), "%)"),
    y = paste0("PC2 (", round(summary(pca)$importance[2,2] * 100, 1), "%)")
  ) 

ggplot(scores_filtered, aes(PC2, PC3, color = host_type)) +
   scale_color_manual(values = host_type_colors)+
  geom_point(size = 2) +
  theme_minimal() +
  labs(
    title = "P2 vs PC3 of KEGG annotations across MAGs",
    x = paste0("PC2 (", round(summary(pca)$importance[2,2] * 100, 1), "%)"),
    y = paste0("PC3 (", round(summary(pca)$importance[2,3] * 100, 1), "%)")
  )

ggplot(scores_filtered, aes(PC3, PC4, color = host_type)) +
   scale_color_manual(values = host_type_colors)+
  geom_point(size = 2) +
  theme_minimal() +
  labs(
    title = "P3 vs PC4 of KEGG annotations across MAGs",
    x = paste0("PC3 (", round(summary(pca)$importance[2,3] * 100, 1), "%)"),
    y = paste0("PC4 (", round(summary(pca)$importance[2,4] * 100, 1), "%)")
  )


ggplot(scores_filtered, aes(PC1, PC2, color = genome_size)) +
  geom_point(size = 2) +
  theme_minimal() +
  labs(
    title = "KEGG PCA colored by genome size",
    x = paste0("PC1 (", round(summary(pca)$importance[2,1] * 100, 1), "%)"),
    y = paste0("PC2 (", round(summary(pca)$importance[2,2] * 100, 1), "%)")
  )

ggplot(scores_filtered, aes(PC1, PC2, color = completeness)) +
  geom_point(size = 2) +
  theme_minimal() +
  labs(
    title = "KEGG PCA colored by completeness",
    x = paste0("PC1 (", round(summary(pca)$importance[2,1] * 100, 1), "%)"),
    y = paste0("PC2 (", round(summary(pca)$importance[2,2] * 100, 1), "%)")
  )

ggplot(scores_filtered, aes(PC1, PC2, color = host_order)) +
  scale_color_manual(values = host_order_colors)+
  geom_point(size = 2) +
  theme_minimal() +
  labs(
    title = "KEGG PCA colored by host order ",
    x = paste0("PC1 (", round(summary(pca)$importance[2,1] * 100, 1), "%)"),
    y = paste0("PC2 (", round(summary(pca)$importance[2,2] * 100, 1), "%)")
  )

ggplot(scores_filtered, aes(PC1, PC2, color = country_normalized)) +
  geom_point(size = 2) +
  theme_minimal() +
  scale_color_manual(values = country_palette, na.value = "grey70")+
  labs(
    title = "KEGG PCA colored by country ",
    x = paste0("PC1 (", round(summary(pca)$importance[2,1] * 100, 1), "%)"),
    y = paste0("PC2 (", round(summary(pca)$importance[2,2] * 100, 1), "%)")
  )

ggplot(scores_filtered, aes(PC1, PC2, color = continent)) +
  geom_point(size = 2) +
  theme_minimal() +
  labs(
    title = "KEGG PCA colored by continent",
    x = paste0("PC1 (", round(summary(pca)$importance[2,1] * 100, 1), "%)"),
    y = paste0("PC2 (", round(summary(pca)$importance[2,2] * 100, 1), "%)")
  )
```
```{r loadings pca total}
loadings <- pca$rotation

abs_loadings <- apply(abs(loadings[, 1:2]), 1, sum)
top_combined <- sort(abs_loadings, decreasing = TRUE)[1:10]
top_combined


```
```{r pca loadings pc1}
library(KEGGREST)

top_loadings <- loadings %>%
  as.data.frame() %>%
  rownames_to_column("KEGG") %>%
  arrange(desc(abs(PC1))) 

head(top_loadings)

top_kos <- head(top_loadings)%>%pull(KEGG)

ko_pathways <- lapply(top_kos, function(k) {
  info <- keggGet(paste0("ko:", k))[[1]]
  pathways <- info$PATHWAY
  if(is.null(pathways)) pathways <- NA
  return(pathways)
})

names(ko_pathways) <- top_kos
ko_pathways
```


### Testing the differences in KEGG presence/absence with PERMANOVA
```{r kegg presence_absence anova}
kegg_counts_mat <- kegg_counts %>%
  column_to_rownames("genome")

kegg_pa <- (kegg_counts_mat > 0) * 1


# remove zero-variance KOs
kegg_pa_nz <- kegg_pa[, colSums(kegg_pa) > 0 & colSums(kegg_pa) < nrow(kegg_pa)]

# Determine the common genomes
common_ids <- base::intersect(rownames(kegg_pa_nz), genome_metadata$ID)

# Report what will be kept/dropped
message("# common: ", length(common_ids))
message("# in KEGG only: ", length(setdiff(rownames(kegg_pa_nz), genome_metadata$ID)))
message("# in metadata only: ", length(setdiff(genome_metadata$ID, rownames(kegg_pa_nz))))

# Subset to the intersection (and keep order identical)
kegg_pa_nz <- kegg_pa_nz[common_ids, , drop = FALSE]

meta <- genome_metadata %>%
  dplyr::filter(ID %in% common_ids) %>%
  dplyr::distinct(ID, .keep_all = TRUE) %>%
  tibble::column_to_rownames("ID") %>%
  .[common_ids, , drop = FALSE]

stopifnot(identical(rownames(meta), rownames(kegg_pa_nz)))

# Prepare variables for PERMANOVA
required_vars <- c("genome_size", "completeness", "host_type")

# Coerce types as needed
meta <- meta %>%
  dplyr::mutate(
    genome_size  = as.numeric(genome_size),
    completeness = as.numeric(completeness),
    host_type    = as.factor(host_type)
  )

# Align on complete cases (adonis2 drops NAs otherwise)
ok <- stats::complete.cases(meta[, required_vars, drop = FALSE])
kegg_pa_nz <- kegg_pa_nz[ok, , drop = FALSE]
meta       <- meta[ok, , drop = FALSE]
stopifnot(identical(rownames(meta), rownames(kegg_pa_nz)))

# Distance, dispersion, PERMANOVA
kegg_dist_pa <- vegan::vegdist(kegg_pa_nz, method = "jaccard", binary = TRUE)

disp_pa <- vegan::betadisper(kegg_dist_pa, meta$host_type)
anova(disp_pa)

vegan::adonis2(
  kegg_dist_pa ~ genome_size + completeness + host_type,
  data = meta,
  permutations = 999,
  by = "margin"
)

```


```{r pcoa on presence absence kegg}
pcoa_pa <- cmdscale(kegg_dist_pa, eig = TRUE, k = 2)

variance_explained <- pcoa_pa$eig / sum(pcoa_pa$eig)

pcoa_df <- data.frame(
  ID = rownames(kegg_pa_nz),
  PC1 = pcoa_pa$points[,1],
  PC2 = pcoa_pa$points[,2],
  host_type = meta$host_type
) %>% left_join(genome_metadata, by = "ID")

pcoa_kegg_pa <- ggplot(pcoa_df, aes(PC1, PC2, color = host_type.x)) +
  geom_point(size = 2) +
  scale_color_manual(values = host_type_colors, name = "Host type")+
  theme_minimal() +
  labs(
    title = "PCoA of KEGG presence/absence matrix across MAGs (colored by host type)",
    x = paste0("PC1 (",round(variance_explained[1] * 100, 1), "%)"),
    y = paste0("PC2 (", round(variance_explained[2] * 100, 1), "%)")
  )

pcoa_kegg_pa

pcoa_kegg_pa <- ggplot(pcoa_df, aes(PC1, PC2, color = host_order)) +
  geom_point(size = 2) +
  scale_color_manual(values = host_order_colors, name = "Host order")+
  theme_minimal() +
  labs(
    title = "PCoA of KEGG presence/absence matrix across MAGs (colored by host order)",
    x = paste0("PC1 (",round(variance_explained[1] * 100, 1), "%)"),
    y = paste0("PC2 (", round(variance_explained[2] * 100, 1), "%)")
  )

pcoa_kegg_pa

ggplot(pcoa_df, aes(PC1, PC2, color = completeness)) +
  geom_point(size = 2) +
  theme_minimal() +
  labs(
    title = "PCoA of KEGG presence/absence matrix across MAGs (colored by completeness)",
    x = paste0("PC1 (",round(variance_explained[1] * 100, 1), "%)"),
    y = paste0("PC2 (", round(variance_explained[2] * 100, 1), "%)")
  )

ggplot(pcoa_df, aes(PC1, PC2, color = continent)) +
  geom_point(size = 2) +
  theme_minimal() +
  labs(
    title = "PCoA of KEGG presence/absence matrix across MAGs (colored by continent)",
    x = paste0("PC1 (",round(variance_explained[1] * 100, 1), "%)"),
    y = paste0("PC2 (", round(variance_explained[2] * 100, 1), "%)")
  )

```




```{r pcoa with completeness}
library(patchwork)
p_main <- ggplot(pcoa_df, aes(PC1, PC2, color = host_type.x)) +
  scale_color_manual(values = host_type_colors) +
  geom_point(size = 2) +
  theme_minimal() +
  labs(
    title = "PCoA of KEGG annotations across MAGs",
    x = paste0("PC1 (", round(variance_explained[1] * 100, 1), "%)"),
    y = paste0("PC2 (", round(variance_explained[2] * 100, 1), "%)")
  ) +
  theme(
    legend.position = "right",
    axis.title.x = element_blank(),  
    axis.text.x = element_blank(),   
    axis.ticks.x = element_blank(),  
    plot.margin = margin(5, 5, 0, 5)
  )

cor_value <- cor(pcoa_df$PC1, pcoa_df$completeness, method = "spearman")
cor_pvalue <- cor.test(pcoa_df$PC1, pcoa_df$completeness, 
                       method = "spearman")$p.value

cor_text <- paste0("Spearman ρ = ", round(cor_value, 3), 
                  "\np < ", format.pval(cor_pvalue, digits = 2))

p_completeness_annotated <- ggplot(pcoa_df, aes(x = PC1, y = completeness, 
                                                 color = host_type.x)) +
  scale_color_manual(values = host_type_colors) +
  geom_point(alpha = 0.6, size = 2) +
  geom_smooth(method = "lm", se = TRUE, color = "black", linewidth = 1) +
  annotate("text", 
           x = min(pcoa_df$PC1) + 0.1 * diff(range(pcoa_df$PC1)), 
           y = max(pcoa_df$completeness) - 5,
           label = cor_text, 
           hjust = 0, 
           size = 3,  # Changed from 4 to 3 (smaller)
           fontface = "plain") +  # Changed from "bold" to "plain"
  theme_minimal() +
  labs(
    y = "Completeness (%)",
    x = paste0("PC1 (", round(variance_explained[1] * 100, 1), "%)")
  ) +
  theme(
    legend.position = "none",
    plot.margin = margin(0, 5, 5, 5),
    panel.border = element_rect(color = "black", fill = NA, linewidth = 0.5)  # Add border
  )


p_main <- p_main + 
  theme(panel.border = element_rect(color = "black", fill = NA, linewidth = 0.5))

combined_annotated <- p_main / p_completeness_annotated + 
  plot_layout(heights = c(3, 1), guides = "collect")

print(combined_annotated)


```



## GIFTs

### PCoA with Euclidean distances:
```{r pcoa_ordination, message=FALSE, fig.height=8, fig.width=10, fig.fullwidth=TRUE}
# Convert the GIFTs into a matrix of functional elements per genome (row)
gift_pcoa <- genome_gifts %>%
    to.elements(., GIFT_db) %>%
    as.data.frame() %>%
    vegdist(method="euclidean") %>%
    pcoa() #principal component analysis

#Extract eigenvalues (variance explained by first 10 axes)
gift_pcoa_rel_eigen <- gift_pcoa$values$Relative_eig[1:10]


# Get genome positions
gift_pcoa_vectors <- gift_pcoa$vectors %>% #extract vectors
  as.data.frame() %>% 
 dplyr::select(Axis.1,Axis.2) # keep the first 2 axes


gift_pcoa_eigenvalues <- gift_pcoa$values$Eigenvalues[c(1,2)]


#For the black arrows: Functional group loadings
# covariance between each functional trait and pcoa axis scores
#scale with the eigenvectors
gift_pcoa_gifts <- cov(genome_gifts, scale(gift_pcoa_vectors)) %*%
  diag((gift_pcoa_eigenvalues/(nrow(genome_gifts)-1))^(-0.5)) %>%
  as.data.frame() %>% 
  dplyr::rename(Axis.1=1,Axis.2=2) %>% 
  rownames_to_column(var="label") %>% 
  #get function summary vectors
  mutate(func=substr(label,1,3)) %>% 
  group_by(func) %>% #grouping by function
  summarise(Axis.1=mean(Axis.1),
            Axis.2=mean(Axis.2)) %>% 
  dplyr::rename(label=func) %>% 
  filter(!label %in% c("S01","S02","S03"))


```


```{r pcoa_ordination_plot, message=FALSE, fig.height=8, fig.width=10, fig.fullwidth=TRUE}
set.seed(101)
scale <- 20 # scale for vector loadings (to make arrows visible)
gift_pcoa_vectors %>% 
  rownames_to_column(var="ID") %>% 
  left_join(genome_metadata, by="ID") %>%
  ggplot() +
      #genome positions
      scale_color_manual(values=host_type_colors)+
      geom_point(aes(x=Axis.1,y=Axis.2, color = host_type), 
                 alpha=0.9, shape=16) +
      scale_size_continuous(range = c(0.1,5)) +
      #loading positions
      geom_segment(data=gift_pcoa_gifts, 
                   aes(x=0, y=0, xend=Axis.1 * scale, yend=Axis.2 * scale),
                    arrow = arrow(length = unit(0.3, "cm"), 
                    type = "open", 
                    angle = 25),
                    linewidth = 0.5, 
                    color = "black") +
     #Primary and secondary scale adjustments
     scale_x_continuous(name = paste0("PCoA1 (",round(gift_pcoa_rel_eigen[1]*100, digits = 2), " %)"),
                      sec.axis = sec_axis(~ . / scale, name = "Loadings on PCoA1")
            ) +
     scale_y_continuous(name = paste0("PCoA2 (",round(gift_pcoa_rel_eigen[2]*100, digits = 2), " %)"),
                      sec.axis = sec_axis(~ . / scale, name = "Loadings on PCoA2")
            ) +
    geom_label_repel(data = gift_pcoa_gifts,
                     aes(label = label, x = Axis.1 * scale, y = Axis.2 * scale),
                     segment.color = 'transparent') +
    xlim(-0.8,1) + 
    ylim(-1,1.5) +
    theme_minimal() + 
  
  labs(
    x = paste0("PCoA1 (", round(gift_pcoa_rel_eigen[1]*100, 2), " %)"),
    y = paste0("PCoA2 (", round(gift_pcoa_rel_eigen[2]*100, 2), " %)")
  )


gift_pcoa_vectors %>% 
  rownames_to_column(var="ID") %>% 
  left_join(genome_metadata, by="ID") %>%
  ggplot() +
      #genome positions
      geom_point(aes(x=Axis.1,y=Axis.2, color = completeness), 
                 alpha=0.9, shape=16) +
      scale_size_continuous(range = c(0.1,5)) +
      #loading positions
      geom_segment(data=gift_pcoa_gifts, 
                   aes(x=0, y=0, xend=Axis.1 * scale, yend=Axis.2 * scale),
                    arrow = arrow(length = unit(0.3, "cm"), 
                    type = "open", 
                    angle = 25),
                    linewidth = 0.5, 
                    color = "black") +
     #Primary and secondary scale adjustments
     scale_x_continuous(name = paste0("PCoA1 (",round(gift_pcoa_rel_eigen[1]*100, digits = 2), " %)"),
                      sec.axis = sec_axis(~ . / scale, name = "Loadings on PCoA1")
            ) +
     scale_y_continuous(name = paste0("PCoA2 (",round(gift_pcoa_rel_eigen[2]*100, digits = 2), " %)"),
                      sec.axis = sec_axis(~ . / scale, name = "Loadings on PCoA2")
            ) +
    geom_label_repel(data = gift_pcoa_gifts,
                     aes(label = label, x = Axis.1 * scale, y = Axis.2 * scale),
                     segment.color = 'transparent') +
    xlim(-0.8,1) + 
    ylim(-1,1.5) +
    theme_minimal() + 
  
  labs(
    x = paste0("PCoA1 (", round(gift_pcoa_rel_eigen[1]*100, 2), " %)"),
    y = paste0("PCoA2 (", round(gift_pcoa_rel_eigen[2]*100, 2), " %)")
  )



gift_pcoa_vectors %>%
  rownames_to_column(var="ID") %>%
  left_join(genome_metadata, by="ID") %>%
  ggplot() +
      #genome positions
      geom_point(aes(x=Axis.1,y=Axis.2, color = continent),
                 alpha=0.9, shape=16) +
      scale_size_continuous(range = c(0.1,5)) +
      #loading positions
      geom_segment(data=gift_pcoa_gifts,
                   aes(x=0, y=0, xend=Axis.1 * scale, yend=Axis.2 * scale),
                    arrow = arrow(length = unit(0.3, "cm"),
                    type = "open",
                    angle = 25),
                    linewidth = 0.5,
                    color = "black") +
     #Primary and secondary scale adjustments
     scale_x_continuous(name = paste0("PCoA1 (",round(gift_pcoa_rel_eigen[1]*100, digits = 2), " %)"),
                      sec.axis = sec_axis(~ . / scale, name = "Loadings on PCoA1")
            ) +
     scale_y_continuous(name = paste0("PCoA2 (",round(gift_pcoa_rel_eigen[2]*100, digits = 2), " %)"),
                      sec.axis = sec_axis(~ . / scale, name = "Loadings on PCoA2")
            ) +
    geom_label_repel(data = gift_pcoa_gifts,
                     aes(label = label, x = Axis.1 * scale, y = Axis.2 * scale),
                     segment.color = 'transparent') +
    xlim(-0.8,1) +
    ylim(-1,1.5) +
    theme_minimal() +

  labs(
    x = paste0("PCoA1 (", round(gift_pcoa_rel_eigen[1]*100, 2), " %)"),
    y = paste0("PCoA2 (", round(gift_pcoa_rel_eigen[2]*100, 2), " %)")
  )


gift_pcoa_vectors %>% 
  rownames_to_column(var="ID") %>% 
  left_join(genome_metadata, by="ID") %>%
  ggplot() +
      #genome positions
      geom_point(aes(x=Axis.1,y=Axis.2, color = host_class), 
                 alpha=0.9, shape=16) +
      scale_size_continuous(range = c(0.1,5)) +
      #loading positions
      geom_segment(data=gift_pcoa_gifts, 
                   aes(x=0, y=0, xend=Axis.1 * scale, yend=Axis.2 * scale),
                    arrow = arrow(length = unit(0.3, "cm"), 
                    type = "open", 
                    angle = 25),
                    linewidth = 0.5, 
                    color = "black") +
     #Primary and secondary scale adjustments
     scale_x_continuous(name = paste0("PCoA1 (",round(gift_pcoa_rel_eigen[1]*100, digits = 2), " %)"),
                      sec.axis = sec_axis(~ . / scale, name = "Loadings on PCoA1")
            ) +
     scale_y_continuous(name = paste0("PCoA2 (",round(gift_pcoa_rel_eigen[2]*100, digits = 2), " %)"),
                      sec.axis = sec_axis(~ . / scale, name = "Loadings on PCoA2")
            ) +
    geom_label_repel(data = gift_pcoa_gifts,
                     aes(label = label, x = Axis.1 * scale, y = Axis.2 * scale),
                     segment.color = 'transparent') +
    xlim(-0.8,1) + 
    ylim(-1,1.5) +
    theme_minimal() + 
  
  labs(
    x = paste0("PCoA1 (", round(gift_pcoa_rel_eigen[1]*100, 2), " %)"),
    y = paste0("PCoA2 (", round(gift_pcoa_rel_eigen[2]*100, 2), " %)")
  )

gift_pcoa_vectors %>% 
  rownames_to_column(var="ID") %>% 
  left_join(genome_metadata, by="ID") %>%
  ggplot() +
      #genome positions
      geom_point(aes(x=Axis.1,y=Axis.2, color = host_order), 
                 alpha=0.9, shape=16) +
      scale_color_manual(values = host_order_colors)+
      scale_size_continuous(range = c(0.1,5)) +
      #loading positions
      geom_segment(data=gift_pcoa_gifts, 
                   aes(x=0, y=0, xend=Axis.1 * scale, yend=Axis.2 * scale),
                    arrow = arrow(length = unit(0.3, "cm"), 
                    type = "open", 
                    angle = 25),
                    linewidth = 0.5, 
                    color = "black") +
     #Primary and secondary scale adjustments
     scale_x_continuous(name = paste0("PCoA1 (",round(gift_pcoa_rel_eigen[1]*100, digits = 2), " %)"),
                      sec.axis = sec_axis(~ . / scale, name = "Loadings on PCoA1")
            ) +
     scale_y_continuous(name = paste0("PCoA2 (",round(gift_pcoa_rel_eigen[2]*100, digits = 2), " %)"),
                      sec.axis = sec_axis(~ . / scale, name = "Loadings on PCoA2")
            ) +
    geom_label_repel(data = gift_pcoa_gifts,
                     aes(label = label, x = Axis.1 * scale, y = Axis.2 * scale),
                     segment.color = 'transparent') +
    xlim(-0.8,1) + 
    ylim(-1,1.5) +
    theme_minimal() + 
  
  labs(
    x = paste0("PCoA1 (", round(gift_pcoa_rel_eigen[1]*100, 2), " %)"),
    y = paste0("PCoA2 (", round(gift_pcoa_rel_eigen[2]*100, 2), " %)")
  )

```



```{r pcoa for report}
centroids <- gift_pcoa_vectors %>%
  rownames_to_column(var = "ID") %>%
  left_join(genome_metadata, by = "ID") %>%
  group_by(host_type) %>%
  summarise(
    Axis.1 = mean(Axis.1, na.rm = TRUE),
    Axis.2 = mean(Axis.2, na.rm = TRUE),
    .groups = "drop"
  )

gift_pcoa_vectors %>% 
  rownames_to_column(var = "ID") %>% 
  left_join(genome_metadata, by = "ID") %>%
  ggplot(aes(x = Axis.1, y = Axis.2, color = host_type)) +
  geom_point(size = 3, alpha = 0.9) +
  scale_color_manual(values = host_type_colors) +

  labs(
    x = paste0("PCoA1 (", round(gift_pcoa_rel_eigen[1] * 100, 2), " %)"),
    y = paste0("PCoA2 (", round(gift_pcoa_rel_eigen[2] * 100, 2), " %)")
  ) +

  coord_cartesian(xlim = c(-0.6, 1), ylim = c(-1, 1)) +

  theme_minimal(base_size = 16) +
  theme(
    axis.title = element_text(size = 14, face = "bold"),
    axis.text  = element_text(size = 14),
    legend.title = element_text(size = 14),
    legend.text  = element_text(size = 14),
    panel.grid.minor = element_blank()
  )

```



Using k-means to cluster the groups and check which MAGs cluster together:
```{r checking the groups}
coords <- gift_pcoa_vectors %>%
  rownames_to_column("MAG") %>%
  as_tibble()

set.seed(123)
km <- kmeans(coords[, c("Axis.1", "Axis.2")], centers = 2, nstart = 25, iter.max = 100)

coords <- coords %>% mutate(cluster = factor(km$cluster))

```


```{r kmeans plot}
# centroids as a tibble for plotting
centroids <- as_tibble(km$centers) %>% mutate(cluster = factor(1:nrow(km$centers)))

ggplot(coords, aes(x = Axis.1, y = Axis.2, color = cluster)) +
  geom_point(size = 2, alpha = 0.8) +
  geom_point(data = centroids, aes(x = Axis.1, y = Axis.2, color = cluster),
             shape = 4, size = 5, stroke = 1.25) +   # X marks centroids
  theme_minimal() +
  labs(title = paste0("PCoA colored by kmeans (k=2)"),
       color = "cluster")

```

```{r cluster mag lists}
mags_by_cluster <- split(coords$MAG, km$cluster)
mags_by_cluster
```

### Checking each cluster at once
```{r clusters}
cluster1_MAGs <- mags_by_cluster[[1]]
genome_metadata %>% filter(ID %in% cluster1_MAGs)

cluster2_MAGs <- mags_by_cluster[[2]]
genome_metadata %>% filter(ID %in% cluster2_MAGs)

```


```{r clean out the RS and GB}
genome_metadata <- genome_metadata %>%
  dplyr::mutate(
    ID_clean = ID %>%
      basename() %>%
      # remove file extensions
      sub("\\.(fna|fa|fasta)(\\.gz)?$", "", ., ignore.case = TRUE) %>%
      # remove GB_ or RS_ at the beginning
      sub("^(GB_|RS_)", "", ., ignore.case = TRUE) %>%
      # extract the real GCA/GCF accession (robust)
      sub(".*\\b(GC[AF]_[0-9]+\\.[0-9]+).*", "\\1", ., perl = TRUE)
  )
```



```{r combined table}
metadata_with_cluster <- genome_metadata %>%
  left_join(coords %>% dplyr::select(MAG, cluster), by = c("ID_clean" = "MAG"))

metadata_with_cluster %>%
  group_by(cluster, host_type) %>%
  summarise(n = n(), .groups = "drop") %>%
  arrange(cluster, desc(n))

# Group summaries
metadata_with_cluster %>%
  group_by(cluster) %>%
  summarise(mean_genome_size = mean(genome_size, na.rm = TRUE),
            median_contamination = median(contamination, na.rm = TRUE),
            .groups = "drop")

```

```{r save the cluster info into rdata}
# save(ehi_mags,
#      phylum_colors,
#      genome_annotations,
#      genome_gifts,
#      contig_to_genome,
#      gtdb_metadata,
#      ehi_metadata,
#      master_index,
#      genome_metadata,
#      host_type_colors,
#      getphylo_tree,
#      metadata_with_cluster,
#      file = "data/data.Rdata")
```




Is the genome size different between clusters?
```{r testing genome size differences}
kruskal.test(genome_size ~ cluster, data = metadata_with_cluster)


pairwise.wilcox.test(
  x = metadata_with_cluster$genome_size,
  g = metadata_with_cluster$cluster,
  p.adjust.method = "BH"   # FDR correction
)
```




Plots
```{r summary plots}
ggplot(metadata_with_cluster, aes(x = genome_size, y = GC, col = cluster))+
  geom_point()+
  theme_bw()

ggplot(metadata_with_cluster, aes(x = cluster, y = genome_size, col = cluster))+
  geom_point()+
  theme_bw()
```


```{r clustering proportion fisher}
count_table <- metadata_with_cluster %>%
  filter(!is.na(cluster))%>%
  dplyr::count(cluster, host_type) %>%
  pivot_wider(
    names_from = host_type,
    values_from = n,
    values_fill = 0
  )

count_table

mat <- metadata_with_cluster %>%
  filter(!is.na(cluster))%>%
  dplyr::count(cluster, host_type) %>%
  pivot_wider(names_from = host_type, values_from = n, values_fill = 0) %>%
  column_to_rownames("cluster") %>%
  as.matrix()

chisq.test(mat)$expected


fisher.test(mat)

```


```{r GIFT aggregations}
#Aggregate bundle-level GIFTs into the compound level
GIFTs_elements <- to.elements(genome_gifts,GIFT_db)

#Aggregate element-level GIFTs into the function level
GIFTs_functions <- to.functions(GIFTs_elements,GIFT_db)

#Aggregate function-level GIFTs into overall Biosynthesis, Degradation and Structural GIFTs
GIFTs_domains <- to.domains(GIFTs_functions,GIFT_db)

```

### GIFT community plots

```{r comumnity_elem_plot_gut, comment="", message=FALSE, warning=FALSE, fig.height=16, fig.width=14, fig.fullwidth=TRUE}
GIFTs_elements %>%
    as.data.frame() %>%
    rownames_to_column(var="MAG")%>%
    pivot_longer(!MAG,names_to="trait",values_to="gift") %>%
    left_join(metadata_with_cluster, by = join_by(MAG == ID)) %>%
    mutate(functionid = substr(trait, 1, 3)) %>%
    mutate(trait = case_when(
      trait %in% GIFT_db$Code_element ~ GIFT_db$Element[match(trait, GIFT_db$Code_element)],
      TRUE ~ trait
    )) %>%
    mutate(functionid = case_when(
      functionid %in% GIFT_db$Code_function ~ GIFT_db$Function[match(functionid, GIFT_db$Code_function)],
      TRUE ~ functionid
    )) %>%
    mutate(trait=factor(trait,levels=unique(GIFT_db$Element))) %>%
    mutate(functionid=factor(functionid,levels=unique(GIFT_db$Function))) %>%
    ggplot(aes(x=MAG,y=trait,fill=gift)) +
        geom_tile(colour="white", linewidth=0.2)+
        scale_fill_gradientn(colours=rev(c("#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#e6f598", "#abdda4", "#ddf1da")))+
        facet_grid(functionid ~ cluster, scales="free",space="free") +
        theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
              axis.text.y = element_text(size=6),
              strip.text.y = element_text(angle = 0)
              ) +
        labs(y="Traits",x="Samples",fill="GIFT")
```




```{r comumnity_elem_plot_host_type, comment="", message=FALSE, warning=FALSE, fig.height=16, fig.width=14, fig.fullwidth=TRUE}
p <- GIFTs_elements %>%
    as.data.frame() %>%
    rownames_to_column(var="MAG")%>%
    pivot_longer(!MAG,names_to="trait",values_to="gift") %>%
    left_join(metadata_with_cluster, by = join_by(MAG == ID)) %>%
    mutate(functionid = substr(trait, 1, 3)) %>%
    mutate(trait = case_when(
      trait %in% GIFT_db$Code_element ~ GIFT_db$Element[match(trait, GIFT_db$Code_element)],
      TRUE ~ trait
    )) %>%
    mutate(functionid = case_when(
      functionid %in% GIFT_db$Code_function ~ GIFT_db$Function[match(functionid, GIFT_db$Code_function)],
      TRUE ~ functionid
    )) %>%
    mutate(trait=factor(trait,levels=unique(GIFT_db$Element))) %>%
    mutate(functionid=factor(functionid,levels=unique(GIFT_db$Function))) %>%
    ggplot(aes(x=MAG,y=trait,fill=gift)) +
        geom_tile(colour="white", linewidth=0.2)+
        scale_fill_gradientn(colours=rev(c("#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#e6f598", "#abdda4", "#ddf1da")))+
        facet_grid(functionid ~ host_type, scales="free",space="free") +
        theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
              axis.text.y = element_text(size=6),
              strip.text.y = element_text(angle = 0)
              ) +
        labs(y="Traits",x="Samples",fill="GIFT")

p
```

```{r save plot, eval = FALSE}
ggplot2::ggsave(
  filename = "plots/GIFT_heatmap_final.png",
  plot = p,
  width = 14,
  height = 16,
  units = "in",
  dpi = 600,
  bg = "white"
)
```



```{r horizontal gift plot with antibiotic resistance genes}
library(RColorBrewer)
library(reshape2)

GIFTs_elements %>%
  melt() %>%
  dplyr::rename(Genome = Var1, Code_element = Var2, GIFT = value) %>%
  inner_join(GIFT_db, by = "Code_element") %>%
  filter(str_starts(Code_element, "D09")) %>%
  left_join(metadata_with_cluster, by = join_by(Genome == ID)) %>%
  mutate(cluster = factor(cluster)) %>%
  droplevels() %>%
  arrange(cluster, Genome) %>%
  mutate(trait = Element) %>%
  # Ensure trait is a factor to maintain order
  mutate(trait = factor(trait, levels = rev(unique(GIFT_db$Element)))) %>%
  ggplot( aes(x = Genome, y = trait)) +
  # Heatmap
  geom_tile(aes(fill = GIFT), color = "white") +
  scale_fill_gradientn(colours = brewer.pal(7, "YlGnBu"), name = "GIFT Score") +
  
  # Start a new fill scale for the host_type bar
  new_scale_fill() +
  
  # Add the host_type bar at the very top or bottom
  geom_tile(aes(y = -0.5, fill = host_type), height = 0.5) +
  scale_fill_manual(values = host_type_colors) +
  
  facet_grid(~ cluster, scales = "free_x", space = "free_x") +
  theme_minimal(base_size = 8) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
```



### Checking difference in GIFTs

#### Cluster-wise
Element GIFTs different between clusters of pcoa
```{r testing gifts between clusters, message = FALSE, warning = FALSE}
# Get only the GIFT columns
gift_cols <- colnames(GIFTs_elements)[!(colnames(GIFTs_elements) %in% c("genome","cluster","host_type"))]

gift_dataframe <- GIFTs_elements %>%
  as.data.frame() %>%            
  rownames_to_column(var = "ID") 

gift_df_meta <- gift_dataframe %>%
  left_join(metadata_with_cluster, by = "ID")


# Kruskal-Wallis for 4 groups
kruskal_results <- sapply(gift_cols, function(g) {
  kruskal.test(as.formula(paste(g, "~ cluster")), data = gift_df_meta)$p.value
})

# Adjust for multiple testing
kruskal_results_adj <- p.adjust(kruskal_results, method = "BH")

# Combine into a table
kruskal_table <- data.frame(
  GIFT = gift_cols,
  p_value = kruskal_results,
  p_adj = kruskal_results_adj
)

kruskal_table %>% filter(p_adj<0.05)
```


```{r testing gifts between clusters pairwise, message = FALSE, warning = FALSE}
pairwise_results <- lapply(gift_cols, function(g) {
  pairwise.wilcox.test(
    x = gift_df_meta[[g]],
    g = gift_df_meta$cluster,
    p.adjust.method = "BH"
  )
})

names(pairwise_results) <- gift_cols

pairwise_sig_table <- lapply(names(pairwise_results), function(g) {
  
  # Extract p-value matrix
  pmat <- pairwise_results[[g]]$p.value
  
  # Convert to long format
  pmat_long <- as.data.frame(as.table(pmat)) %>%
    filter(!is.na(Freq)) %>%       # remove NA (diagonal / upper triangle)
    dplyr::rename(group1 = Var1, group2 = Var2, p_adj = Freq) %>%
    filter(p_adj < 0.05) %>%      
    mutate(GIFT = g)
  
  return(pmat_long)
})



# Combine all GIFTs into one table
pairwise_sig_table <- bind_rows(pairwise_sig_table) %>%
  dplyr::select(GIFT, group1, group2, p_adj)

pairwise_sig_table 

```


```{r gifts different between cluster_1}
GIFTs_elements %>%
  melt() %>%
  dplyr::rename(Genome = Var1, Code_element = Var2, GIFT = value) %>%
  inner_join(GIFT_db, by = "Code_element") %>%
  filter(Code_element %in% pairwise_sig_table$GIFT) %>%
  left_join(metadata_with_cluster, by = join_by(Genome == ID)) %>%
  distinct(Genome, Code_element, .keep_all = TRUE) %>%
  mutate(cluster = factor(cluster)) %>%
  droplevels() %>%
  arrange(cluster, Genome) %>%
  mutate(trait = Element) %>%
  ggplot(aes(x = Genome, y = trait, fill = GIFT)) +
    geom_tile(colour = "white", linewidth = 0.2) +
    scale_y_discrete(guide = guide_axis(check.overlap = TRUE)) +
    scale_x_discrete(guide = guide_axis(check.overlap = TRUE)) +
    scale_fill_gradientn(limits = c(0,1), colours = RColorBrewer::brewer.pal(7, "YlGnBu")) +
  new_scale_fill() +
  
  # Add the host_type bar at the very top or bottom
  geom_tile(aes(y = -0.5, fill = host_type), height = 0.3) +
  scale_fill_manual(values = host_type_colors, name = "host_type") +
    facet_grid(~ cluster, scales = "free_x", space = "free_x") + 
    theme(
      axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, size = 4),
      strip.text.x = element_text(face = "bold")
    ) +
    labs(y = "Trait", x = "Genome", fill = "GIFT")
```

```{r checking code elements}
GIFT_db%>%
  filter(Code_element %in%  pairwise_sig_table$GIFT)
```


```{r pairwise wilcox cluster with effect size}
library(rstatix)
library(dplyr)
library(purrr)

pairwise_sig_table <- map_df(gift_cols, function(g) {
  
  # Check if there is variation in the GIFT values
  # If all values are the same, skip this GIFT
  if(length(unique(gift_df_meta[[g]])) < 2) return(NULL)
  
  # Run the test safely
  tryCatch({
    results <- gift_df_meta %>%
      wilcox_test(as.formula(paste0("`", g, "` ~ cluster")), p.adjust.method = "BH")
    
    eff <- gift_df_meta %>%
      wilcox_effsize(as.formula(paste0("`", g, "` ~ cluster")))
    
    results %>%
      left_join(eff, by = c("group1", "group2", ".y." = ".y.", "n1", "n2")) %>%
      filter(p.adj < 0.05) %>%
      mutate(GIFT = g)
  }, error = function(e) return(NULL)) # If it still fails, just skip it
})

top_gifts <- pairwise_sig_table %>%
  arrange(desc(effsize))


top_gifts
```


```{r gifts different between cluster}
GIFTs_elements %>%
  melt() %>%
  dplyr::rename(Genome = Var1, Code_element = Var2, GIFT = value) %>%
  inner_join(GIFT_db, by = "Code_element") %>%
  filter(Code_element %in% pairwise_sig_table$GIFT) %>%
  left_join(metadata_with_cluster, by = join_by(Genome == ID)) %>%
  distinct(Genome, Code_element, .keep_all = TRUE) %>%
  mutate(cluster = factor(cluster)) %>%
  droplevels() %>%
  arrange(cluster, Genome) %>%
  mutate(trait = Element) %>%
  ggplot(aes(x = Genome, y = trait, fill = GIFT)) +
    geom_tile(colour = "white", linewidth = 0.2) +
    scale_y_discrete(guide = guide_axis(check.overlap = TRUE)) +
    scale_x_discrete(guide = guide_axis(check.overlap = TRUE)) +
    scale_fill_gradientn(limits = c(0,1), colours = RColorBrewer::brewer.pal(7, "YlGnBu")) +
    facet_grid(~ cluster, scales = "free_x", space = "free_x") + 
    theme_grey(base_size = 8) +
    theme(
      axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),
      strip.text.x = element_text(face = "bold")
    ) +
    labs(y = "Trait", x = "Genome", fill = "GIFT")
```



#### host_type-wise
GIFTs that are different between EHI and GTDB
```{r testing gifts between host_types pairwise, message = FALSE, warning = FALSE}
wilcox_results <- sapply(gift_cols, function(g) {
  wilcox.test(as.formula(paste(g, "~ host_type")), data = gift_df_meta)$p.value
})

wilcox_results_adj <- p.adjust(wilcox_results, method = "BH")

data.frame(
  GIFT = gift_cols,
  p_value = wilcox_results,
  p_adj = wilcox_results_adj
)

effect_size <- sapply(gift_cols, function(g) {
  median(gift_df_meta[[g]][gift_df_meta$host_type=="human"]) -
    median(gift_df_meta[[g]][gift_df_meta$host_type=="animal"])
})

wilcox_res_host_type <- data.frame(
  GIFT = gift_cols,
  p_value = wilcox_results,
  p_adj = wilcox_results_adj,
  effect = effect_size
)


wilcox_res_host_type %>% dplyr::select(GIFT, p_adj, effect) %>% filter(p_adj<0.05)

```
```{r checking code element B0215}
GIFT_db%>%
  filter(Code_element %in% c("B0215", "B0701", "D0508") )
```
```{r adding effect size wilcox host_type}

wilcox_res_host_type <- map_df(gift_cols, function(g) {
  
 
  if(length(unique(gift_df_meta[[g]])) < 2) return(NULL)
  
  tryCatch({
    # Calculate p-value
    res <- gift_df_meta %>%
      wilcox_test(as.formula(paste0("`", g, "` ~ host_type")))
    
    # Calculate effect size (Rank-Biserial Correlation)
    eff <- gift_df_meta %>%
      wilcox_effsize(as.formula(paste0("`", g, "` ~ host_type")))
    
    # Combine results
    res %>%
      left_join(eff, by = c("group1", "group2", ".y." = ".y.", "n1", "n2")) %>%
      mutate(GIFT = g)
  }, error = function(e) return(NULL))
})

#  Adjust P-values and filter
wilcox_res_host_type <- wilcox_res_host_type %>%
  mutate(p_adj = p.adjust(p, method = "BH")) %>%
  dplyr::select(GIFT, group1, group2, p_adj, effsize, magnitude) %>%
  filter(p_adj < 0.05) %>%
  arrange(desc(abs(effsize))) # Sort by strongest effect

# View the top results
print(wilcox_res_host_type)
```

```{r gifts different between host_type plot, eval = FALSE}
host_class_colors <- c(
  "Mammalia"  = "#8B1E3F",  
  "Reptilia"  = "#3A7D44", 
  "Aves"      = "#E1B12C"   
)

GIFTs_elements %>%
  melt() %>%
  dplyr::rename(Genome = Var1, Code_element = Var2, GIFT = value) %>%
  inner_join(GIFT_db, by = "Code_element") %>%
  filter(Code_element %in% wilcox_res_host_type$GIFT) %>%
  left_join(metadata_with_cluster, by = join_by(Genome == ID)) %>%
  distinct(Genome, Code_element, .keep_all = TRUE) %>%
  mutate(cluster = factor(cluster)) %>%
  droplevels() %>%
  arrange(cluster, Genome) %>%
  mutate(trait = Element) %>%
  ggplot(aes(x = Genome, y = trait, fill = GIFT)) +
    geom_tile(colour = "white", linewidth = 0.2) +
    scale_y_discrete(guide = guide_axis(check.overlap = TRUE)) +
    scale_x_discrete(guide = guide_axis(check.overlap = TRUE)) +
    scale_fill_gradientn(limits = c(0,1), colours = RColorBrewer::brewer.pal(7, "YlGnBu")) +
  new_scale_fill() +
  
  # Add the host_type bar at the very top or bottom
  geom_tile(aes(y = -0.5, fill = host_class), height = 0.5) +
    facet_grid(~ host_type, scales = "free_x", space = "free_x") + 
  scale_fill_manual(values = host_class_colors, name = "Host class")
    theme(
      axis.text.x = element_blank()
    ) +
    labs(y = "Trait", x = "Genome", fill = "GIFT")
```
# Antibiotic resistance analysis

### Nº of MAGs with AMRs
```{r mag counts per AMR}
# AMR presence/absence
amr_presence <- genome_annotations %>%
  filter(resistance_type == "AMR") %>%
  dplyr::select(genome, resistance_target) %>%
  distinct() 

#Add the host_type info
amr_with_host_type <- amr_presence %>%
  left_join(
    genome_metadata %>% dplyr::select(ID, host_type),
    by = c("genome" = "ID")
  )

# Count how many MAGs in each AMR
amr_mag_counts <- amr_with_host_type %>%
  group_by(host_type, resistance_target) %>%
  summarise(
    n_mags = n(),
    .groups = "drop"
  )

#Count total MAGs per host_type 
total_mags_per_host_type <- genome_metadata %>%
  group_by(host_type) %>%
  summarise(
    total_mags = n_distinct(ID),
    .groups = "drop"
  )

#Calculate proportions of MAGs from each host_type in each AMR
amr_mag_proportions <- amr_mag_counts %>%
  left_join(total_mags_per_host_type, by = "host_type") %>%
  mutate(
    proportion = n_mags / total_mags,
    absent = total_mags - n_mags
  )

```

#### Statistical testing of MAG proportions
```{r statistical testing mag proportions amr}
fisher_results <- amr_mag_proportions %>%
  dplyr::select(resistance_target, host_type, n_mags, absent) %>%
  pivot_wider(
    names_from = host_type,
    values_from = c(n_mags, absent),
    values_fill = 0
  ) %>%
  rowwise() %>%
  mutate(
    p_value = fisher.test(
      matrix(
        c(n_mags_animal,  absent_animal,
          n_mags_human, absent_human),
        nrow = 2,
        byrow = TRUE
      )
    )$p.value
  ) %>%
  ungroup() %>%
  mutate(p_adj = p.adjust(p_value, method = "BH"))

fisher_results <- fisher_results %>%
  mutate(
    prop_animal  = n_mags_animal  / (n_mags_animal  + absent_animal),
    prop_human = n_mags_human / (n_mags_human + absent_human),
    diff_prop = prop_human - prop_animal
  )
```

```{r filtering padj amr}
fisher_results%>% filter(p_adj < 0.05) 
```


## Building an AMR abundance table

```{r amr table}
# select the AMR annotations
amr_abundance <- genome_annotations %>%
  filter(resistance_type == "AMR") %>%
  group_by(genome, resistance_target) %>%
  summarise(count = n(), .groups="drop") %>%
  tidyr::pivot_wider(
    names_from = resistance_target,
    values_from = count,
    values_fill = 0
  )

```

```{r join with metadata}
amr_cluster <- amr_abundance %>%
  dplyr::full_join(metadata_with_cluster, by= join_by(genome == ID))
```

```{r investigation macrolide and beta_lactam}
amr_cluster %>%
  dplyr::select("BETA-LACTAM", "MACROLIDE", genome, cluster) %>%
  group_by( cluster) %>%
  summarise(mean_beta_lactam = mean(`BETA-LACTAM`, na.rm = TRUE),
            mean_macrolide = mean(MACROLIDE, na.rm = TRUE))
```


```{r AMR abundance heatmap,  fig.height=14, fig.width=12, fig.fullwidth=TRUE}
amr_matrix <- amr_abundance %>%
  column_to_rownames("genome") %>%
  as.matrix()

# Abundance heatmap
min_val <- min(amr_matrix, na.rm = TRUE)
max_val <- max(amr_matrix, na.rm = TRUE)

colors <- viridis(100, option = "viridis")

breaks <- seq(min_val, max_val, length.out = 101)   

pheatmap( amr_matrix,
  color = colors,
  cluster_rows = FALSE,
  cluster_cols = TRUE,
  fontsize = 9,
  border_color = NA
)





```



```{r AMR presence heatmap_1,  fig.height=14, fig.width=12, fig.fullwidth=TRUE}
amr_presence <- amr_abundance %>%
  column_to_rownames("genome") %>%   
  mutate(across(everything(), ~ ifelse(. > 0, 1, 0)))%>%
  as.matrix()


pheatmap(
  amr_presence,
  cluster_rows = TRUE,
  cluster_cols = TRUE,
  color = c("white", "darkblue"),     # white = absent, black = present
  legend_breaks = c(0,1),
  legend_labels = c("Absent", "Present"),
  border_color = NA
)

```
```{r heatmap presence absence by ehi vs gtdb,  fig.height=14, fig.width=12, fig.fullwidth=TRUE}
pheatmap(
  amr_presence,
  cluster_rows = FALSE,
  cluster_cols = TRUE,
  color = c("white", "darkblue"),     # white = absent, black = present
  legend_breaks = c(0,1),
  legend_labels = c("Absent", "Present"),
  border_color = NA
)
```

## PERMANOVA presence/absence
```{r amr presence_absence permanova}
# Remove zero-variance AMR features
amr_pa_nz <- amr_presence[, colSums(amr_presence) > 0 & colSums(amr_presence) < nrow(amr_presence), drop = FALSE]

# Determine the common genomes/IDs between AMR matrix and metadata
common_ids <- base::intersect(rownames(amr_pa_nz), genome_metadata$ID)

# Report what will be kept/dropped
message("# common: ", length(common_ids))
message("# in AMR only: ", length(setdiff(rownames(amr_pa_nz), genome_metadata$ID)))
message("# in metadata only: ", length(setdiff(genome_metadata$ID, rownames(amr_pa_nz))))

# Subset AMR to the intersection (and keep the identical order)
amr_pa_nz <- amr_pa_nz[common_ids, , drop = FALSE]

# Build aligned metadata (unique IDs, same order as amr_pa_nz)
meta <- genome_metadata %>%
  dplyr::filter(ID %in% common_ids) %>%
  dplyr::distinct(ID, .keep_all = TRUE) %>%
  tibble::column_to_rownames("ID") %>%
  .[common_ids, , drop = FALSE]

stopifnot(identical(rownames(meta), rownames(amr_pa_nz)))

# Prepare variables for PERMANOVA
required_vars <- c("genome_size", "completeness", "host_type")

# Coerce types as needed
meta <- meta %>%
  dplyr::mutate(
    genome_size  = as.numeric(genome_size),
    completeness = as.numeric(completeness),
    host_type    = as.factor(host_type)
  )

# Align on complete cases for the required variables
ok <- stats::complete.cases(meta[, required_vars, drop = FALSE])
amr_pa_nz <- amr_pa_nz[ok, , drop = FALSE]
meta      <- meta[ok, , drop = FALSE]

stopifnot(identical(rownames(meta), rownames(amr_pa_nz)))

# Distance, dispersion, PERMANOVA
amr_dist_pa <- vegan::vegdist(amr_pa_nz, method = "jaccard", binary = TRUE)

disp_pa <- vegan::betadisper(amr_dist_pa, meta$host_type)
anova(disp_pa)

vegan::adonis2(
  amr_dist_pa ~ genome_size + completeness + host_type,
  data = meta,
  permutations = 999,
  by = "margin"
)


```

## PCoA presence/absence

```{r pcoa on presence absence amr}
pcoa_pa <- cmdscale(amr_dist_pa, eig = TRUE, k = 2)

variance_explained <- pcoa_pa$eig / sum(pcoa_pa$eig)


pcoa_df <- data.frame(
  ID = rownames(amr_pa_nz),
  PC1 = pcoa_pa$points[,1],
  PC2 = pcoa_pa$points[,2],
  host_type = meta$host_type
) %>%
  left_join(metadata_with_cluster, by = "ID")


pcoa_amr_pa <- ggplot(pcoa_df, aes(PC1, PC2, color = host_type.x)) +
  geom_point(size = 2) +
  scale_color_manual(values = host_type_colors, name = "host_type") +
  theme_minimal() +
  labs(
    title = "PCoA of AMR annotations across MAGs",
    x = paste0("PCoA1 (", round(variance_explained[1] * 100, 1), "%)"),
    y = paste0("PCoA2 (", round(variance_explained[2] * 100, 1), "%)")
  )

pcoa_amr_pa

ggplot(pcoa_df, aes(PC1, PC2, color = host_order)) +
  geom_point(size = 2) +
  scale_color_manual(values = host_order_colors, name = "Host Order")+
  theme_minimal() +
  labs(
    title = "PCoA of AMR annotations across MAGs (colored by host order)",
    x = paste0("PCoA1 (", round(variance_explained[1] * 100, 1), "%)"),
    y = paste0("PCoA2 (", round(variance_explained[2] * 100, 1), "%)")
  )

ggplot(pcoa_df, aes(PC1, PC2, color = completeness)) +
  geom_point(size = 2) +

  theme_minimal() +
  labs(
    title = "PCoA of AMR annotations across MAGs (colored by completeness)",
    x = paste0("PCoA1 (", round(variance_explained[1] * 100, 1), "%)"),
    y = paste0("PCoA2 (", round(variance_explained[2] * 100, 1), "%)")
  )

ggplot(pcoa_df, aes(PC1, PC2, color = genome_size)) +
  geom_point(size = 2) +

  theme_minimal() +
  labs(
    title = "PCoA of AMR annotations across MAGs (colored by genome_size)",
    x = paste0("PCoA1 (", round(variance_explained[1] * 100, 1), "%)"),
    y = paste0("PCoA2 (", round(variance_explained[2] * 100, 1), "%)")
  )

ggplot(pcoa_df, aes(PC1, PC2, color = country)) +
  geom_point(size = 2) +
  scale_color_manual(values = country_palette, na.value = "grey70")+
  theme_minimal() +
  labs(
    title = "PCoA of AMR annotations across MAGs (colored by country)",
    x = paste0("PCoA1 (", round(variance_explained[1] * 100, 1), "%)"),
    y = paste0("PCoA2 (", round(variance_explained[2] * 100, 1), "%)")
  )


ggplot(pcoa_df, aes(PC1, PC2, color = continent)) +
  geom_point(size = 2) +
  theme_minimal() +
  labs(
    title = "PCoA of AMR annotations across MAGs (colored by continent)",
    x = paste0("PCoA1 (", round(variance_explained[1] * 100, 1), "%)"),
    y = paste0("PCoA2 (", round(variance_explained[2] * 100, 1), "%)")
  )

ggplot(pcoa_df, aes(PC1, PC2, color = cluster)) +
  geom_point(size = 2) +
  theme_minimal() +
  labs(
    title = "PCoA of AMR annotations across MAGs (colored by functional cluster)",
    x = paste0("PCoA1 (", round(variance_explained[1] * 100, 1), "%)"),
    y = paste0("PCoA2 (", round(variance_explained[2] * 100, 1), "%)")
  )


```




## Testing proportions (Fisher)
```{r testing prevalence with fischer test}
amr_counts <- genome_annotations %>%
  filter(resistance_type == "AMR") %>%
  dplyr::count(genome, resistance_target) %>%            
  pivot_wider(names_from = resistance_target, values_from = n, values_fill = 0) %>%
  filter(rowSums(dplyr::select(., -genome)) > 0) # Removes MAGs with no AMR genes found


amr_binary <- amr_counts %>%
  left_join(genome_metadata %>% dplyr::select(ID, host_type), by = c("genome" = "ID")) %>%
  # Convert all numeric columns to 0 or 1
  mutate(across(where(is.numeric), ~ ifelse(.x > 0, 1, 0)))

#Function to run Fischer test for each gene
run_fisher <- function(gene_name, df) {
  tab <- table(df$host_type, df[[gene_name]])
  
  # Only run if the table is actually 2x2 
  if(ncol(tab) == 2) {
    test <- fisher.test(tab)
    return(tidy(test) %>% mutate(AMR_Target = gene_name))
  } else {
    return(NULL)
  }
}

# Apply the function to all AMR columns
amr_names <- colnames(amr_counts)[-1] # everything except mag_id

fisher_results <- map_df(amr_names, ~ run_fisher(.x, amr_binary))

# Adjust for multiple testing (FDR)
fisher_results <- fisher_results %>%
  mutate(p.adj = p.adjust(p.value, method = "fdr")) %>%
  filter(p.adj < 0.05) %>%
  arrange(p.adj)

print(fisher_results)
```



# Virulence factors analysis
### Nº of MAGs with VFs
```{r mag counts per VF}
# AMR presence/absence
vf_presence <- genome_annotations %>%
  filter(!is.na(vf)) %>%
  dplyr::select(genome, vf) %>%
  distinct() 

#Add the host_type info
vf_with_host_type <- vf_presence %>%
  left_join(
    genome_metadata %>% dplyr::select(ID, host_type),
    by = c("genome" = "ID")
  )

# Count how many MAGs in each vf
vf_mag_counts <- vf_with_host_type %>%
  group_by(host_type, vf) %>%
  summarise(
    n_mags = n(),
    .groups = "drop"
  )

#Count total MAGs per host_type (except the outlier)
total_mags_per_host_type <- genome_metadata %>%
  group_by(host_type) %>%
  summarise(
    total_mags = n_distinct(ID),
    .groups = "drop"
  )

#Calculate proportions of MAGs from each host_type in each vf
vf_mag_proportions <- vf_mag_counts %>%
  left_join(total_mags_per_host_type, by = "host_type") %>%
  mutate(
    proportion = n_mags / total_mags,
    absent = total_mags - n_mags
  )

```

#### Statistical testing of MAG proportions (Fisher)
```{r statistical testing mag proportions vf}
fisher_results <- vf_mag_proportions %>%
  dplyr::select(vf, host_type, n_mags, absent) %>%
  pivot_wider(
    names_from = host_type,
    values_from = c(n_mags, absent),
    values_fill = 0
  ) %>%
  rowwise() %>%
  mutate(
    p_value = fisher.test(
      matrix(
        c(n_mags_animal,  absent_animal,
          n_mags_human, absent_human),
        nrow = 2,
        byrow = TRUE
      )
    )$p.value
  ) %>%
  ungroup() %>%
  mutate(p_adj = p.adjust(p_value, method = "BH"))

fisher_results <- fisher_results %>%
  mutate(
    prop_animal  = n_mags_animal  / (n_mags_animal  + absent_animal),
    prop_human = n_mags_human / (n_mags_human + absent_human),
    diff_prop = prop_human - prop_animal
  )
```

```{r filtering padj vf}
fisher_results%>% filter(p_adj < 0.05) 
```



## Building a virulence factor abundance table

```{r select virulence factor data from gene annotations}
vf_data <- genome_annotations %>%
  dplyr::select(genome, vf, vf_type) 
```


```{r vf table}
vf_abundance <- genome_annotations %>%
  dplyr::select(genome, vf) %>%
  group_by(genome, vf) %>%
  summarise(count = n(), .groups="drop") %>%
  tidyr::pivot_wider(
    names_from = vf,
    values_from = count,
    values_fill = 0
  )

dim(vf_abundance)
```

```{r vf join with metadata}
vf_cluster <- vf_abundance %>%
  dplyr::full_join(genome_metadata, by= join_by(genome == ID))
```



```{r vf heatmaps}
# make into a matrix
vf_matrix <- vf_abundance %>%
  column_to_rownames("genome") %>%
  as.matrix()

# Unscaled abundance heatmap
pheatmap(vf_matrix,
  color = viridis(100, option = "viridis"),
  cluster_rows = FALSE,
  cluster_cols = TRUE,
  fontsize = 9,
  border_color = NA
)

# For scaled heatmap -> remove zero variance columns 
col_vars <- apply(vf_matrix, 2, var, na.rm = TRUE)
vf_matrix_filtered <- vf_matrix[, col_vars > 0 & !is.na(col_vars)]

# Scale the filtered matrix
vf_scaled <- scale(vf_matrix_filtered, center = TRUE, scale = TRUE)

# Check for any remaining Inf/NaN values
if(any(!is.finite(vf_scaled))) {
  vf_scaled[!is.finite(vf_scaled)] <- 0  # Replace Inf/NaN with 0
}

# Scaled heatmap
pheatmap(vf_scaled,
  color = viridis(100, option = "viridis"),
  cluster_rows = FALSE,
  cluster_cols = TRUE,
  fontsize = 5,
  border_color = NA
)
```

## Virulence presence/absence heatmap
```{r VF presence heatmap,  fig.height=14, fig.width=12, fig.fullwidth=TRUE}
vf_presence <- vf_abundance %>%
  column_to_rownames("genome") %>%   
  mutate(across(everything(), ~ ifelse(. > 0, 1, 0)))%>%
  as.matrix()


pheatmap(
  vf_presence,
  cluster_rows = FALSE,
  cluster_cols = TRUE,
  color = c("white", "darkblue"),     
  legend_breaks = c(0,1),
  legend_labels = c("Absent", "Present"),
  border_color = NA
)

```


## Virulence presence/absence PERMANOVA
```{r vf presence_absence anova}
# remove zero-variance KOs
vf_pa_nz <- vf_presence[, colSums(vf_presence) > 0 & colSums(vf_presence) < nrow(vf_presence)]

# Determine the common genomes
common_ids <- base::intersect(rownames(vf_pa_nz), genome_metadata$ID)

# Report what will be kept/dropped
message("# common: ", length(common_ids))
message("# in KEGG only: ", length(setdiff(rownames(amr_pa_nz), genome_metadata$ID)))
message("# in metadata only: ", length(setdiff(genome_metadata$ID, rownames(vf_pa_nz))))

# Subset to the intersection (and keep order identical)
vf_pa_nz <- vf_pa_nz[common_ids, , drop = FALSE]

meta <- genome_metadata %>%
  dplyr::filter(ID %in% common_ids) %>%
  dplyr::distinct(ID, .keep_all = TRUE) %>%
  tibble::column_to_rownames("ID") %>%
  .[common_ids, , drop = FALSE]

stopifnot(identical(rownames(meta), rownames(vf_pa_nz)))

# VERY IMPORTANT: enforce same order
meta <- meta[rownames(vf_pa_nz), ]

stopifnot(identical(rownames(meta), rownames(vf_pa_nz)))


# Prepare variables for PERMANOVA
required_vars <- c("genome_size", "completeness", "host_type")

# Coerce types as needed
meta <- meta %>%
  dplyr::mutate(
    genome_size  = as.numeric(genome_size),
    completeness = as.numeric(completeness),
    host_type    = as.factor(host_type)
  )

# Align on complete cases (adonis2 drops NAs otherwise)
ok <- stats::complete.cases(meta[, required_vars, drop = FALSE])
vf_pa_nz <- vf_pa_nz[ok, , drop = FALSE]
meta       <- meta[ok, , drop = FALSE]
stopifnot(identical(rownames(meta), rownames(vf_pa_nz)))

# Distance, dispersion, PERMANOVA
vf_dist_pa <- vegan::vegdist(vf_pa_nz, method = "jaccard", binary = TRUE)

disp_pa <- vegan::betadisper(vf_dist_pa, meta$host_type)
anova(disp_pa)

vegan::adonis2(
  vf_dist_pa ~ genome_size + completeness + host_type,
  data = meta,
  permutations = 999,
  by = "margin"
)

```


## Virulence presence/absence PCoA
```{r pcoa on presence absence vf}
pcoa_pa <- cmdscale(vf_dist_pa, eig = TRUE, k = 2)

variance_explained <- pcoa_pa$eig / sum(pcoa_pa$eig)


pcoa_df <- data.frame(
  ID = rownames(vf_pa_nz),
  PC1 = pcoa_pa$points[,1],
  PC2 = pcoa_pa$points[,2],
  host_type = meta$host_type
) %>%
  left_join(metadata_with_cluster, by = "ID")


pcoa_vf_pa <- ggplot(pcoa_df, aes(PC1, PC2, color = host_type.x)) +
  geom_point(size = 2) +
  scale_color_manual(values = host_type_colors, name = "host_type") +
  theme_minimal() +
  labs(
    title = "PCoA of VF annotations across MAGs",
    x = paste0("PCoA1 (", round(variance_explained[1] * 100, 1), "%)"),
    y = paste0("PCoA2 (", round(variance_explained[2] * 100, 1), "%)")
  )

pcoa_vf_pa

ggplot(pcoa_df, aes(PC1, PC2, color = host_order)) +
  geom_point(size = 2) +
  scale_color_manual(values = host_order_colors, na.value = "grey70")+
  theme_minimal() +
  labs(
    title = "PCoA of VF annotations across MAGs (colored by host order)",
    x = paste0("PCoA1 (", round(variance_explained[1] * 100, 1), "%)"),
    y = paste0("PCoA2 (", round(variance_explained[2] * 100, 1), "%)")
  )


ggplot(pcoa_df, aes(PC1, PC2, color = completeness)) +
  geom_point(size = 2) +

  theme_minimal() +
  labs(
    title = "PCoA of VF annotations across MAGs (colored by completeness)",
    x = paste0("PCoA1 (", round(variance_explained[1] * 100, 1), "%)"),
    y = paste0("PCoA2 (", round(variance_explained[2] * 100, 1), "%)")
  )

ggplot(pcoa_df, aes(PC1, PC2, color = genome_size)) +
  geom_point(size = 2) +

  theme_minimal() +
  labs(
    title = "PCoA of VF annotations across MAGs (colored by genome_size)",
    x = paste0("PCoA1 (", round(variance_explained[1] * 100, 1), "%)"),
    y = paste0("PCoA2 (", round(variance_explained[2] * 100, 1), "%)")
  )

ggplot(pcoa_df, aes(PC1, PC2, color = country)) +
  geom_point(size = 2) +
  scale_color_manual(values = country_palette, na.value = "grey70")+
  theme_minimal() +
  labs(
    title = "PCoA of VF annotations across MAGs (colored by country)",
    x = paste0("PCoA1 (", round(variance_explained[1] * 100, 1), "%)"),
    y = paste0("PCoA2 (", round(variance_explained[2] * 100, 1), "%)")
  )


ggplot(pcoa_df, aes(PC1, PC2, color = continent)) +
  geom_point(size = 2) +
  theme_minimal() +
  labs(
    title = "PCoA of VF annotations across MAGs (colored by continent)",
    x = paste0("PCoA1 (", round(variance_explained[1] * 100, 1), "%)"),
    y = paste0("PCoA2 (", round(variance_explained[2] * 100, 1), "%)")
  )

pcoa_vf_pa_cluster <- ggplot(pcoa_df, aes(PC1, PC2, color = cluster)) +
  geom_point(size = 2) +
  theme_minimal() +
  labs(
    title = "PCoA of VF annotations across MAGs (colored by functional cluster)",
    x = paste0("PCoA1 (", round(variance_explained[1] * 100, 1), "%)"),
    y = paste0("PCoA2 (", round(variance_explained[2] * 100, 1), "%)")
  )

pcoa_vf_pa_cluster
```

# CAZY
```{r cazy annotations}
cazy_genes <- genome_annotations %>%
  filter(!is.na(cazy)) %>%
  nrow()

cazy_genes
```


```{r cazy abundance heatmap,  fig.height=14, fig.width=12, fig.fullwidth=TRUE}
cazy_abundance <- genome_annotations %>%
  filter(!is.na(cazy)) %>%
  group_by(genome, cazy) %>%
  summarise(count = n(), .groups="drop") %>%
  tidyr::pivot_wider(
    names_from = cazy,
    values_from = count,
    values_fill = 0
  )

cazy_matrix <- cazy_abundance %>%
  column_to_rownames("genome") %>%
  as.matrix()

# Abundance heatmap
min_val <- min(cazy_matrix, na.rm = TRUE)
max_val <- max(cazy_matrix, na.rm = TRUE)

colors <- viridis(100, option = "viridis")

breaks <- seq(min_val, max_val, length.out = 101)   

pheatmap( cazy_matrix,
  color = colors,
  cluster_rows = FALSE,
  cluster_cols = TRUE,
  fontsize = 9,
  border_color = NA
)


#Scaled abundance heatmap
cazy_scaled <- scale(cazy_matrix, center = TRUE, scale = TRUE)

min_val <- min(cazy_scaled, na.rm = TRUE)
max_val <- max(cazy_scaled, na.rm = TRUE)

colors <- viridis(100, option = "viridis")

breaks <- seq(min_val, max_val, length.out = 101)   



```


## Defense
```{r defense}
genome_annotations %>% dplyr::select(genome, defense, defense_type, antidefense, antidefense_type) %>%
  filter(!is.na(defense))
```


## PCoAs KEGG, AMR and VF
```{r pcoas together, fig.height = 6, fig.width = 7}
library(patchwork)

combined_plot <- (pcoa_kegg_pa + ggtitle("PCoA: KEGG")) +
                 (pcoa_amr_pa  + ggtitle("PCoA: AMR")) +
                 (pcoa_vf_pa   + ggtitle("PCoA: VF")) +
                 plot_layout(ncol = 2, guides = "collect") &
                 theme(legend.position = "bottom")

combined_plot

```



















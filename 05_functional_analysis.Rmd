# Functional Analysis

```{r load_data_mag, message=FALSE, warning=FALSE, echo=FALSE}
load("data/data.Rdata")
```

## Functional overview

```{r genomes annotated}
n_genes <- genome_annotations %>%
  group_by(genome) %>%
  summarize(n_genes = n())

n_genes
```


#### Predicted genes
```{r predicted_stats, message=FALSE, warning=FALSE}
pred_genes <- genome_annotations %>%
  nrow()

cat(pred_genes)
```

#### Number of annotated genes and percentages
```{r annotation_stats, message=FALSE, warning=FALSE, fig.height=10, fig.width=10, fig.fullwidth=TRUE}
#How many genes have at least 1 annotation
genome_annota <- genome_annotations %>%
  filter(if_any(c(kegg, pfam, cazy), ~ !is.na(.))) %>%
  nrow()

cat(genome_annota)

#Percentage of predicted genes with at least 1 annotation
genome_annota*100/pred_genes
```

#### Number of KEGG annotatated genes and percentages
```{r kegg_stats_gut, message=FALSE, warning=FALSE, fig.height=10, fig.width=10, fig.fullwidth=TRUE}
# KEGG annotation
kegg_annota <- genome_annotations %>%
  filter(!is.na(kegg)) %>%
  nrow()
cat(kegg_annota)

# KEGG annotation percentage
kegg_annota*100/genome_annota


# AMR annotation
amr_annota <- genome_annotations %>%
  filter(resistance_type == "AMR") %>%
  nrow()
cat(amr_annota)

# AMR annotation percentage
amr_annota*100/genome_annota


# VF annotation
vf_annota <- genome_annotations %>%
  filter(!is.na(vf)) %>%
  nrow()
cat(vf_annota)

# VF annotation percentage
vf_annota*100/genome_annota
```

```{r n genes per mag}
n_pred_genes <- genome_annotations %>%
  group_by(mag_id) %>%
  summarize(n_genes = n()) %>%
  left_join(
    genome_metadata %>% dplyr::select(ID, source),
    by = c("mag_id" = "ID")
  )

annotated_genes <- genome_annotations %>%
  filter(if_any(c(kegg, pfam, cazy), ~ !is.na(.))) %>%
  group_by(mag_id) %>%
  summarize(n_annotated_genes = n()) %>%
  left_join(
    genome_metadata %>% dplyr::select(ID, source),
    by = c("mag_id" = "ID")
  )
```

```{r plotting n genes}
ggplot(n_pred_genes, aes(x= source, y = n_genes, fill = source))+
  scale_fill_manual(values = source_colors)+
  geom_boxplot()+ 
  geom_point()+
  theme_classic()+
  labs(y = "Gene Number", x = "Source")

ggplot(annotated_genes, aes(x= source, y = n_annotated_genes, fill = source))+
  scale_fill_manual(values = source_colors)+
  geom_boxplot()+ 
  geom_point()+
  theme_classic()+
  labs(y = "Annotated Gene Number", x = "Source")

wilcox.test(n_genes ~ source, data=n_pred_genes)  %>%
  tidy()


wilcox.test(n_annotated_genes ~ source, data=annotated_genes)  %>%
  tidy()

```


## KEGG
### Nº of MAGs with KOs
```{r mag counts per kegg}
#Proportion of MAGs belonging to each group per KEGG
#I want to know for example 5% of MAGs in the EHI group have this KEGG, but 40 % of MAGs in the GTDB group have it

# KEGG presence/absence
kegg_presence <- genome_annotations %>%
  filter(mag_id != "GCA_015060925.1") %>%   # remove weird MAG
  filter(!is.na(kegg)) %>%
  dplyr::select(mag_id, kegg) %>%
  distinct() 

#Add the source info
kegg_with_source <- kegg_presence %>%
  left_join(
    genome_metadata %>% dplyr::select(ID, source),
    by = c("mag_id" = "ID")
  )

# Count how many MAGs in each KEGG
kegg_mag_counts <- kegg_with_source %>%
  group_by(source, kegg) %>%
  summarise(
    n_mags = n(),
    .groups = "drop"
  )

#Count total MAGs per source (except the outlier)
total_mags_per_source <- genome_metadata %>%
  filter(ID != "GCA_015060925.1") %>%
  group_by(source) %>%
  summarise(
    total_mags = n_distinct(ID),
    .groups = "drop"
  )

#Calculate proportions of MAGs from each source in each KEGG
kegg_mag_proportions <- kegg_mag_counts %>%
  left_join(total_mags_per_source, by = "source") %>%
  mutate(
    proportion = n_mags / total_mags,
    absent = total_mags - n_mags
  )

```

#### Plotting KEGG MAG proportions
```{r plotting kegg mag proportions}
kegg_mag_proportions %>%
  filter(n_mags >= 20)

ggplot(kegg_mag_proportions,
       aes(x = kegg, y = proportion, fill = source)) +
  geom_col(position = "dodge") +
  scale_fill_manual(values = source_colors) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  ) +
  labs(
    x = "KEGG ortholog",
    y = "Proportion of MAGs"
  )

```

#### Statistical testing of MAG proportions
```{r statistical testing mag proportions}
fisher_results <- kegg_mag_proportions %>%
  dplyr::select(kegg, source, n_mags, absent) %>%
  pivot_wider(
    names_from = source,
    values_from = c(n_mags, absent),
    values_fill = 0
  ) %>%
  rowwise() %>%
  mutate(
    p_value = fisher.test(
      matrix(
        c(n_mags_EHI,  absent_EHI,
          n_mags_GTDB, absent_GTDB),
        nrow = 2,
        byrow = TRUE
      )
    )$p.value
  ) %>%
  ungroup() %>%
  mutate(p_adj = p.adjust(p_value, method = "BH"))

fisher_results <- fisher_results %>%
  mutate(
    prop_EHI  = n_mags_EHI  / (n_mags_EHI  + absent_EHI),
    prop_GTDB = n_mags_GTDB / (n_mags_GTDB + absent_GTDB),
    diff_prop = prop_GTDB - prop_EHI
  )
```

```{r filtering padj}
sig_fisher_results <- fisher_results%>% filter(p_adj < 0.05) 
sig_fisher_results
```
```{r function to get info from KEGG}
library(KEGGREST)

# Function to get info from KEGG
get_kegg_info <- function(ko_id) {
  query <- keggGet(ko_id)[[1]]
  
  # Extract Name and Definition
  name <- ifelse(!is.null(query$NAME), query$NAME, "N/A")
  definition <- ifelse(!is.null(query$DEFINITION), query$DEFINITION, "N/A")
  
  # Extract Pathways (often multiple)
  pathways <- if(!is.null(query$PATHWAY)) {
    paste(names(query$PATHWAY), query$PATHWAY, sep = ": ", collapse = "; ")
  } else {
    "No pathway assigned"
  }
  
  return(c(KO = ko_id, Name = name, Definition = definition, Pathways = pathways))
}

```

```{r significant kos}
signigicant_kos <- fisher_results%>% filter(p_adj < 0.05) %>% pull(kegg)


ko_list <- lapply(signigicant_kos, get_kegg_info)
ko_summary <- as.data.frame(do.call(rbind, ko_list))

print(ko_summary)
```


```{r heatmap data}
fish_results_names <- left_join(sig_fisher_results, ko_summary, join_by(kegg== KO))


heatmap_data <- fish_results_names %>%
  dplyr::select(Name, prop_EHI, prop_GTDB)%>%
  pivot_longer(!Name, names_to = "source", values_to= "proportion" ) %>%
   mutate(
    source = case_when(
      source == "prop_EHI"  ~ "EHI",
      source == "prop_GTDB" ~ "GTDB",
      TRUE ~ source
    )
  )


```


```{r plot the keggs}
ggplot(heatmap_data,
       aes(x = source, y = Name, fill = proportion)) +
  geom_tile() +
  scale_fill_viridis_c(
    name = "Proportion of MAGs",
    limits = c(0, 1)
  ) +
  theme_minimal() +
  labs(
    x = "Source",
    y = "KEGG ortholog",
    title = "Differential KEGG presence between EHI and GTDB"
  )

```



### Functional Ordination

PCA of KEGG annotations:
```{r pca of kegg}
kegg_counts <- genome_annotations %>%
  filter(mag_id != "GCA_015060925.1")%>% #this is the smaller mag that's weird
  filter(!is.na(kegg)) %>%          
  dplyr::count(mag_id, kegg) %>%           
  pivot_wider(
    names_from = kegg,
    values_from = n,
    values_fill = 0
  )

# Normalization
kegg_rel <- kegg_counts %>%
  column_to_rownames("mag_id")
kegg_rel <- kegg_rel / rowSums(kegg_rel)  # Each row sums to 1

# Remove zero variance
kegg_rel_nz <- kegg_rel[, apply(kegg_rel, 2, sd) > 0]

# PCA with scaling
pca <- prcomp(kegg_rel_nz, scale. = TRUE)

# Check variance explained
summary(pca)$importance[,1:5]
```
```{r country colors}
country_palette <- c(
  # Southern Europe
  "Spain" = "#1B9E77",
  "Italy" = "#33A02C",
  "Greece" = "#66C2A5",
  "Portugal" = "#2CA25F",
  "Malta" = "#99D8C9",

  # Northern/Central Europe
  "Germany" = "#1F78B4",
  "United Kingdom" = "#4A90E2",
  "Ireland" = "#6BAED6",

  # East Asia 
  "Japan" = "#E31A1C",
  "South Korea" = "#FB6A4A",
  "China" = "#CB181D",

  # North America 
  "USA" = "#756BB1",
  "Canada" = "#9E9AC8",

  # Distinct
  "Australia" = "#FFD92F",   
  "Greenland" = "#A6CEE3",

  "none" = "grey70"
)


```


```{r plot pca kegg}
scores <- as.data.frame(pca$x)
scores$ID <- rownames(scores)

scores <- scores %>%
  left_join(genome_metadata, by = "ID")

ggplot(scores, aes(PC1, PC2, color = source)) +
  geom_point(size = 2) +
   scale_color_manual(values = source_colors)+
  theme_minimal() +
  labs(
    title = "PCA of KEGG annotations across MAGs",
    x = paste0("PC1 (", round(summary(pca)$importance[2,1] * 100, 1), "%)"),
    y = paste0("PC2 (", round(summary(pca)$importance[2,2] * 100, 1), "%)")
  )

ggplot(scores, aes(PC2, PC3, color = source)) +
   scale_color_manual(values = source_colors)+
  geom_point(size = 2) +
  theme_minimal() +
  labs(
    title = "P2 vs PC3 of KEGG annotations across MAGs",
    x = paste0("PC2 (", round(summary(pca)$importance[2,2] * 100, 1), "%)"),
    y = paste0("PC3 (", round(summary(pca)$importance[2,3] * 100, 1), "%)")
  )

ggplot(scores, aes(PC3, PC4, color = source)) +
   scale_color_manual(values = source_colors)+
  geom_point(size = 2) +
  theme_minimal() +
  labs(
    title = "P3 vs PC4 of KEGG annotations across MAGs",
    x = paste0("PC3 (", round(summary(pca)$importance[2,3] * 100, 1), "%)"),
    y = paste0("PC4 (", round(summary(pca)$importance[2,4] * 100, 1), "%)")
  )


ggplot(scores, aes(PC1, PC2, color = genome_size)) +
  geom_point(size = 2) +
  theme_minimal() +
  labs(
    title = "KEGG PCA colored by genome size",
    x = paste0("PC1 (", round(summary(pca)$importance[2,1] * 100, 1), "%)"),
    y = paste0("PC2 (", round(summary(pca)$importance[2,2] * 100, 1), "%)")
  )

ggplot(scores, aes(PC1, PC2, color = completeness)) +
  geom_point(size = 2) +
  theme_minimal() +
  labs(
    title = "KEGG PCA colored by completeness",
    x = paste0("PC1 (", round(summary(pca)$importance[2,1] * 100, 1), "%)"),
    y = paste0("PC2 (", round(summary(pca)$importance[2,2] * 100, 1), "%)")
  )

ggplot(scores, aes(PC1, PC2, color = host_species)) +
  geom_point(size = 2) +
  theme_minimal() +
  labs(
    title = "KEGG PCA colored by host species ",
    x = paste0("PC1 (", round(summary(pca)$importance[2,1] * 100, 1), "%)"),
    y = paste0("PC2 (", round(summary(pca)$importance[2,2] * 100, 1), "%)")
  )

ggplot(scores, aes(PC1, PC2, color = country)) +
  geom_point(size = 2) +
  theme_minimal() +
  scale_color_manual(values = country_palette, na.value = "grey70")+
  labs(
    title = "KEGG PCA colored by country ",
    x = paste0("PC1 (", round(summary(pca)$importance[2,1] * 100, 1), "%)"),
    y = paste0("PC2 (", round(summary(pca)$importance[2,2] * 100, 1), "%)")
  )

ggplot(scores, aes(PC1, PC2, color = continent)) +
  geom_point(size = 2) +
  theme_minimal() +
  labs(
    title = "KEGG PCA colored by continent",
    x = paste0("PC1 (", round(summary(pca)$importance[2,1] * 100, 1), "%)"),
    y = paste0("PC2 (", round(summary(pca)$importance[2,2] * 100, 1), "%)")
  )
```
```{r loadings pca total}
loadings <- pca$rotation

abs_loadings <- apply(abs(loadings[, 1:2]), 1, sum)
top_combined <- sort(abs_loadings, decreasing = TRUE)[1:10]
top_combined


```
```{r pca loadings pc1}
library(KEGGREST)

top_loadings <- loadings %>%
  as.data.frame() %>%
  rownames_to_column("KEGG") %>%
  arrange(desc(abs(PC1))) 

head(top_loadings)

top_kos <- head(top_loadings)%>%pull(KEGG)

ko_pathways <- lapply(top_kos, function(k) {
  info <- keggGet(paste0("ko:", k))[[1]]
  pathways <- info$PATHWAY
  if(is.null(pathways)) pathways <- NA
  return(pathways)
})

names(ko_pathways) <- top_kos
ko_pathways
```


### KEGG heatmap
```{r kegg heatmap}
# Relative abundance heatmap
pheatmap(kegg_rel_nz,
  color = viridis(100, option = "viridis"),
  cluster_rows = TRUE,
  cluster_cols = TRUE,
  fontsize = 9,
  border_color = NA
)

# For scaled heatmap -> remove zero variance columns 
col_vars <- apply(kegg_rel_nz, 2, var, na.rm = TRUE)
matrix_filtered <- kegg_rel_nz[, col_vars > 0 & !is.na(col_vars)]

# Scale the filtered matrix
scaled <- scale(matrix_filtered, center = TRUE, scale = TRUE)

# Check for any remaining Inf/NaN values
if(any(!is.finite(scaled))) {
  scaled[!is.finite(scaled)] <- 0  # Replace Inf/NaN with 0
}

# Scaled heatmap
pheatmap(scaled,
  color = viridis(100, option = "viridis"),
  cluster_rows = TRUE,
  cluster_cols = TRUE,
  fontsize = 5,
  border_color = NA
)

```


### Testing the differences in KEGG annotations with PERMANOVA

```{r permanova_kegg}
# Distance matrix from normalized data
kegg_dist <- vegdist(kegg_rel_nz, method = "bray") 

# Add metadata
kegg_rel_nz_meta <- kegg_rel_nz %>%
  rownames_to_column("ID") %>%
  left_join(genome_metadata, by = "ID")

#Beta dispersion test
dispersion <- betadisper(kegg_dist, kegg_rel_nz_meta$source)
anova(dispersion) 


# PERMANOVA test
permanova_result <- adonis2(kegg_dist ~ genome_size + source, 
                            data = kegg_rel_nz_meta, 
                            permutations = 999)
print(permanova_result)

adonis2(
  kegg_dist ~ genome_size + source,
  data = kegg_rel_nz_meta,
  permutations = 999,
  by = "margin"
)
```

```{r kegg presence_absence anova}
kegg_counts_mat <- kegg_counts %>%
  column_to_rownames("mag_id")

kegg_pa <- (kegg_counts_mat > 0) * 1


# remove zero-variance KOs
kegg_pa_nz <- kegg_pa[, colSums(kegg_pa) > 0 & colSums(kegg_pa) < nrow(kegg_pa)]

meta <- genome_metadata %>%
  filter(ID %in% rownames(kegg_pa_nz)) %>%
  column_to_rownames("ID")

# VERY IMPORTANT: enforce same order
meta <- meta[rownames(kegg_pa_nz), ]

stopifnot(identical(rownames(meta), rownames(kegg_pa_nz)))


kegg_dist_pa <- vegdist(kegg_pa_nz, method = "jaccard", binary = TRUE)

# dispersion check
disp_pa <- betadisper(kegg_dist_pa, meta$source)
anova(disp_pa)

# PERMANOVA
adonis2(
  kegg_dist_pa ~ genome_size +completeness+ source,
  data = meta,
  permutations = 999, by = "margin"
)

```

```{r permanova on continent}
# Identify rows that have NO missing values
keep_indices <- complete.cases(meta[, c("continent", "genome_size", "completeness", "source")])

# Filter the metadata
meta_clean <- meta[keep_indices, ]


kegg_dist_mat <- as.matrix(kegg_dist_pa)
kegg_dist_clean <- as.dist(kegg_dist_mat[keep_indices, keep_indices])


adonis2(
  kegg_dist_clean ~ country + genome_size + completeness,
  data = meta_clean,
  permutations = 999, 
  by = "margin"
)
```




```{r pcoa on presence absence kegg}
pcoa_pa <- cmdscale(kegg_dist_pa, eig = TRUE, k = 2)

pcoa_df <- data.frame(
  ID = rownames(kegg_pa_nz),
  PC1 = pcoa_pa$points[,1],
  PC2 = pcoa_pa$points[,2],
  source = meta$source
) %>%
  left_join(genome_metadata, by = "ID")


ggplot(pcoa_df, aes(PC1, PC2, color = source.x)) +
  geom_point(size = 3, alpha = 0.8) +
  theme_classic()

ggplot(pcoa_df, aes(PC1, PC2, color = completeness)) +
  geom_point(size = 3, alpha = 0.8) +
  theme_classic()

ggplot(pcoa_df, aes(PC1, PC2, color = continent)) +
  geom_point(size = 3, alpha = 0.8) +
  theme_classic()

```



### Principal Coordinate Analysis - KEGG

```{r pcoa_kegg_dist}
pcoa_res <- cmdscale(kegg_dist, k = 2, eig = TRUE)

# Calculate variance explained 
variance_explained <- pcoa_res$eig / sum(pcoa_res$eig)

pcoa_df <- data.frame(
  PC1 = pcoa_res$points[,1], 
  PC2 = pcoa_res$points[,2], 
  ID = rownames(kegg_rel_nz)
) %>%
  left_join(genome_metadata, by = "ID")


ggplot(pcoa_df, aes(PC1, PC2, color = source)) +
  scale_color_manual(values = source_colors)+
  geom_point(size = 2) +
  theme_minimal() +
  labs(
    title = "PCoA of KEGG annotations across MAGs",
    x = paste0("PC1 (", round(variance_explained[1] * 100, 1), "%)"),
    y = paste0("PC2 (", round(variance_explained[2] * 100, 1), "%)")
  )


ggplot(pcoa_df, aes(PC1, PC2, color = genome_size)) +
  geom_point(size = 2) +
  theme_minimal() +
  labs(
    title = "PCoA of KEGG annotations across MAGs",
    x = paste0("PC1 (",round(variance_explained[1] * 100, 1), "%)"),
    y = paste0("PC2 (", round(variance_explained[2] * 100, 1), "%)")
  )

ggplot(pcoa_df, aes(PC1, PC2, color = host_species)) +
  geom_point(size = 2) +
  theme_minimal() +
  labs(
    title = "PCoA of KEGG annotations across MAGs (colored by host species)",
    x = paste0("PC1 (",round(variance_explained[1] * 100, 1), "%)"),
    y = paste0("PC2 (", round(variance_explained[2] * 100, 1), "%)")
  )

 ggplot(pcoa_df, aes(PC1, PC2, color = country)) +
   geom_point(size = 2) +
   theme_minimal() +
   labs(
   title = "PCoA of KEGG annotations across MAGs (colored by country)",
     x = paste0("PC1 (",round(variance_explained[1] * 100, 1), "%)"),
     y = paste0("PC2 (", round(variance_explained[2] * 100, 1), "%)")
   )

 ggplot(pcoa_df, aes(PC1, PC2, color = continent)) +
   geom_point(size = 2) +
   theme_minimal() +
   labs(
     title = "PCoA of KEGG annotations across MAGs (colored by continent)",
     x = paste0("PC1 (",round(variance_explained[1] * 100, 1), "%)"),
     y = paste0("PC2 (", round(variance_explained[2] * 100, 1), "%)")
   )
```

```{r pcoa with completenedds}
library(patchwork)
p_main <- ggplot(pcoa_df, aes(PC1, PC2, color = source)) +
  scale_color_manual(values = source_colors) +
  geom_point(size = 2) +
  theme_minimal() +
  labs(
    title = "PCoA of KEGG annotations across MAGs",
    x = paste0("PC1 (", round(variance_explained[1] * 100, 1), "%)"),
    y = paste0("PC2 (", round(variance_explained[2] * 100, 1), "%)")
  ) +
  theme(
    legend.position = "right",
    axis.title.x = element_blank(),  
    axis.text.x = element_blank(),   
    axis.ticks.x = element_blank(),  
    plot.margin = margin(5, 5, 0, 5)
  )

cor_value <- cor(pcoa_df$PC1, pcoa_df$completeness, method = "spearman")
cor_pvalue <- cor.test(pcoa_df$PC1, pcoa_df$completeness, 
                       method = "spearman")$p.value

cor_text <- paste0("Spearman ρ = ", round(cor_value, 3), 
                  "\np < ", format.pval(cor_pvalue, digits = 2))

p_completeness_annotated <- ggplot(pcoa_df, aes(x = PC1, y = completeness, 
                                                 color = source)) +
  scale_color_manual(values = source_colors) +
  geom_point(alpha = 0.6, size = 2) +
  geom_smooth(method = "lm", se = TRUE, color = "black", linewidth = 1) +
  annotate("text", 
           x = min(pcoa_df$PC1) + 0.1 * diff(range(pcoa_df$PC1)), 
           y = max(pcoa_df$completeness) - 5,
           label = cor_text, 
           hjust = 0, 
           size = 3,  # Changed from 4 to 3 (smaller)
           fontface = "plain") +  # Changed from "bold" to "plain"
  theme_minimal() +
  labs(
    y = "Completeness (%)",
    x = paste0("PC1 (", round(variance_explained[1] * 100, 1), "%)")
  ) +
  theme(
    legend.position = "none",
    plot.margin = margin(0, 5, 5, 5),
    panel.border = element_rect(color = "black", fill = NA, linewidth = 0.5)  # Add border
  )


p_main <- p_main + 
  theme(panel.border = element_rect(color = "black", fill = NA, linewidth = 0.5))

combined_annotated <- p_main / p_completeness_annotated + 
  plot_layout(heights = c(3, 1), guides = "collect")

print(combined_annotated)


```





### Differential abundance

Differential expression analysis- trying to find which KEGG orthologs are significantly different between EHI vs GTDB
DESeq2

```{r deseq_kegg}
library(DESeq2)

# Prepare the count matrix (KOs as rows, MAGs as columns)
# Ensure only integer columns are kept
counts_mtx <- kegg_counts %>%
  column_to_rownames("mag_id") %>%
  t() 

# Prepare metadata (Must match column names of counts_mtx)
metadata <- genome_metadata %>%
  filter(ID %in% colnames(counts_mtx)) %>%
  column_to_rownames("ID")

# Ensure order matches exactly
metadata <- metadata[colnames(counts_mtx), , drop = FALSE]

#Create DESeq2 object
dds <- DESeqDataSetFromMatrix(countData = counts_mtx,
                              colData = metadata,
                              design = ~ source)

# Run the differential analysis
dds <- DESeq(dds)

# save results (Wildlife vs Human)
res <- results(dds, contrast=c("source", "EHI", "GTDB"), alpha=0.05)


summary(res)



```



```{r saving res_1}
res_df <-res %>% as.data.frame %>% 
  rownames_to_column("KO") %>% 
  as_tibble
```


```{r plot deseq ma plot}
ggplot(res_df,aes(x=baseMean, y=log2FoldChange)) + 
  geom_point(alpha=0.8) + 
  geom_smooth() + 
  scale_x_log10() + 
  geom_hline(yintercept = 0, alpha = 0.75,
  color="red")+
  theme_bw()+ coord_cartesian(ylim=c(-10, 10))
```
```{r volcano plot}
res_df_2<- res_df%>% 
  mutate(label2= ifelse (abs(log2FoldChange) > 0.58 ,KO, ""))

ggplot(res_df_2, aes(x=baseMean, 
                 y=log2FoldChange, 
                 col=padj<0.05, label=label2)) + 
  geom_point(alpha=0.5) + 
  scale_x_log10() + 
  geom_hline(yintercept = 0, alpha = 0.75,
  color="red")+
  geom_text_repel()+
  theme_bw()+ coord_cartesian(ylim=c(-10, 10))


ggplot(res_df_2, aes(x=log2FoldChange, y=-log10(pvalue), color=padj < 0.05, label=label2)) + 
  geom_point(alpha=0.5) +
  geom_vline(xintercept = 1, alpha = 0.75, 
  linetype="dashed")+
  geom_vline(xintercept = -1, alpha = 0.75, 
  linetype="dashed")+
   geom_text_repel() +
  theme_bw()
```


### Wilcoxon

```{r wilcoxon_keggs, message = FALSE, warning = FALSE}
#Transform to long format and run test for every KO
wilcox_results <- kegg_rel_nz_meta %>%
  pivot_longer(cols = starts_with("K"), 
               names_to = "KO", 
               values_to = "rel_abundance") %>%
  group_by(KO) %>%
  do(tidy(wilcox.test(rel_abundance ~ source, data = .))) %>%
  ungroup()

#  Adjust p-values
wilcox_results <- wilcox_results %>%
  mutate(p.adj = p.adjust(p.value, method = "fdr")) %>%
  filter(p.adj < 0.05) %>%
  arrange(p.adj)

head(wilcox_results)
```

```{r plotting top term, message = FALSE, warning = FALSE}
res_df <- as.data.frame(res) %>%
  rownames_to_column("KO") %>%
  filter(padj < 0.05) %>%
  arrange(padj)

# Find KOs that are significant in BOTH tests
common_KOs <- intersect(res_df$KO, wilcox_results$KO)

# Boxplot of the top hit
top_ko <- common_KOs[1]

ggplot(kegg_rel_nz_meta, aes(x = source, y = .data[[top_ko]], fill = source)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(width = 0.2, alpha = 0.5) +
  theme_minimal() +
  labs(title = paste("Distribution of", top_ko),
       y = "Relative Abundance")
```

```{r plot all, message = FALSE, warning = FALSE}
# Filter data to only include the common KOs
plot_data <- kegg_rel_nz_meta %>%
  dplyr::select(ID, source, all_of(common_KOs)) %>%
  pivot_longer(cols = all_of(common_KOs), 
               names_to = "KO", 
               values_to = "Relative_Abundance")


ggplot(plot_data, aes(x = source, y = Relative_Abundance, fill = source)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(width = 0.2, alpha = 0.4, size = 1) +
  facet_wrap(~KO, scales = "free_y", ncol = 5) + # 'free_y' is important as abundance scales vary
  scale_fill_manual(values = source_colors) +
  theme_minimal() +
  theme(strip.text = element_text(face = "bold"),
        legend.position = "bottom") +
  labs(title = "Relative Abundance of Consensus Significant KOs",
       x = "Host Source",
       y = "Relative Abundance")
```

Check alignment with DESeq:
```{r checking medians, message = FALSE, warning = FALSE} 
# Calculate medians for each group to see direction
direction_check <- kegg_rel_nz_meta %>%
  dplyr::select(source, all_of(common_KOs)) %>%
  pivot_longer(-source, names_to = "KO", values_to = "val") %>%
  group_by(KO, source) %>%
  summarize(median_val = median(val), .groups = 'drop') %>%
  pivot_wider(names_from = source, values_from = median_val) %>%
  mutate(Enriched_In = ifelse(GTDB > EHI, "GTDB", "EHI"))

# Merge with your DESeq2 results to see if they align
final_comparison <- res_df %>%
  filter(KO %in% common_KOs) %>%
  dplyr::select(KO, log2FoldChange, padj) %>%
  left_join(direction_check, by = "KO")

print(final_comparison)
```


```{r get the ko pathways, message = FALSE, warning = FALSE}
target_kos <- common_KOs 



ko_info_list <- lapply(target_kos, get_kegg_info)
ko_summary <- as.data.frame(do.call(rbind, ko_info_list))

print(ko_summary)
```


```{r heatmap ko from wilcoxon and deseq, message = FALSE, warning = FALSE}
#Prepare the matrix (KOs as rows, MAGs as columns)
heatmap_mat <- kegg_rel_nz_meta %>%
  column_to_rownames("ID") %>%
  dplyr::select(all_of(common_KOs)) %>%
  as.matrix() %>%
  t()

#  Prepare the annotation data frame
annotation_col <- data.frame(Source = kegg_rel_nz_meta$source)
rownames(annotation_col) <- kegg_rel_nz_meta$ID

# Check if they match
all(colnames(heatmap_mat) == rownames(annotation_col))

#colors
ann_colors <- list(
  Source = source_colors
)

# Plot
pheatmap(heatmap_mat, 
         annotation_col = annotation_col, 
         annotation_colors = ann_colors,
         scale = "row",          
         show_colnames = TRUE, 
         cluster_cols = TRUE,    
         main = "Consensus KOs: Human vs Wildlife")
```

```{r heatmap with all significant ko from wilcoxon, message = FALSE, warning = FALSE}
#Prepare the matrix (KOs as rows, MAGs as columns)
heatmap_mat <- kegg_rel_nz_meta %>%
  column_to_rownames("ID") %>%
  dplyr::select(all_of(wilcox_results$KO)) %>%
  as.matrix() %>%
  t()

#  Prepare the annotation data frame
annotation_col <- data.frame(Source = kegg_rel_nz_meta$source)
rownames(annotation_col) <- kegg_rel_nz_meta$ID

# Check if they match
all(colnames(heatmap_mat) == rownames(annotation_col))

#colors
ann_colors <- list(
  Source = source_colors
)

# Plot
pheatmap(heatmap_mat, 
         annotation_col = annotation_col, 
         annotation_colors = ann_colors,
         scale = "row",          
         show_colnames = TRUE, 
         cluster_cols = TRUE,    
         main = "Consensus KOs: Human vs Wildlife")
```



### ALDEX2
```{r testing aldex raw, message = FALSE, warning = FALSE}
library(ALDEx2)
kegg_raw_mat <- kegg_counts %>%
  column_to_rownames("mag_id") %>%
  as.matrix()

kegg_raw_mat[is.na(kegg_raw_mat)] <- 0


conds <- kegg_rel_nz_meta %>%
  filter(ID %in% rownames(kegg_raw_mat)) %>%
  arrange(match(ID, rownames(kegg_raw_mat))) %>%
  pull(source)

table(conds)  

aldex_clr <- aldex.clr(
  reads = t(kegg_raw_mat),
  conds = conds,
  mc.samples = 128,   # number of Monte Carlo instances
  denom = "all",      
  verbose = TRUE
)

# Welch's t-test and Wilcoxon test
aldex_test   <- aldex.ttest(aldex_clr)
aldex_effect <- aldex.effect(aldex_clr)

# Combine results
aldex_res <- cbind(aldex_test, aldex_effect)

sig_kegg <- aldex_res %>%
  as.data.frame() %>%
  rownames_to_column("KEGG") %>%
  filter(we.eBH < 0.05) %>%  # FDR-corrected
  arrange(we.eBH)

# Add direction of enrichment
sig_kegg <- sig_kegg %>%
  mutate(enriched_in = ifelse(effect > 0, "GTDB", "EHI"))

sig_kegg

```
No significant results...




GENOME SIZE is significantly larger in GTDB MAGs --> correct for genome size

Which functions are enriched per unit genome by source?

```{r adjust kegg matrix by genome size, message = FALSE, warning = FALSE}
genome_sizes <- genome_metadata %>%
  dplyr::select(ID, genome_size)

kegg_counts_gs <- kegg_counts %>%
  left_join(genome_sizes, by = c("mag_id" = "ID")) %>%
  column_to_rownames("mag_id")

# Divide by genome size (in Mb)
kegg_per_mb <- kegg_counts_gs[, -ncol(kegg_counts_gs)] /
  (kegg_counts_gs$genome_size / 1e6)

```



```{r preparation for aldex2, message = FALSE, warning = FALSE}
kegg_mat <- as.matrix(kegg_per_mb)

# Replace any NA
kegg_mat[is.na(kegg_mat)] <- 0

#Filter rare keggs 
keep_kegg <- colSums(kegg_mat > 0) >= 0.1 * nrow(kegg_mat)
kegg_mat <- kegg_mat[, keep_kegg]

#add a pseudocount
kegg_mat <- kegg_mat + 1e-6

conds <- kegg_rel_nz_meta %>%
  filter(ID %in% rownames(kegg_mat)) %>%
  arrange(match(ID, rownames(kegg_mat))) %>%
  pull(source)

table(conds)


scale_factor <- 1e4

kegg_pseudo <- round(kegg_per_mb * scale_factor)

# Replace zeros (ALDEx2 hates structural zeros)
kegg_pseudo[kegg_pseudo == 0] <- 1

```
```{r aldex2, message = FALSE, warning = FALSE}


aldex_clr <- aldex.clr(
  reads = t(kegg_pseudo),
  conds = conds,
  mc.samples = 128,
  denom = "all",
  verbose = TRUE
)

aldex_test   <- aldex.ttest(aldex_clr)
aldex_effect <- aldex.effect(aldex_clr)

aldex_res <- cbind(aldex_test, aldex_effect)

head(aldex_res)
```



```{r aldex2 significant kegg results}
sig_kegg <- aldex_res %>%
  as.data.frame() %>%
  rownames_to_column("KEGG") %>%
  filter(
    we.eBH < 0.05,
    abs(effect) > 1
  ) %>%
  arrange(desc(abs(effect)))

sig_kegg

```




```{r clr wilcoxon, message = FALSE, warning = FALSE}
library(compositions)

clr_mat <- clr(kegg_per_mb + 1e-6)

res <- apply(clr_mat, 2, function(x) {
  wilcox.test(x ~ conds)$p.value
})

res_adj <- p.adjust(res, method = "BH")

```

```{r check, message = FALSE, warning = FALSE}
clr_res <- data.frame(
  KEGG = names(res),
  p_value = res,
  p_adj = res_adj
) %>%
  arrange(p_adj)

head(clr_res)


sum(clr_res$p_adj < 0.05)


res_lm <- apply(clr_mat, 2, function(x) {
  model <- lm(x ~ conds + kegg_counts_gs$genome_size)
  summary(model)$coefficients["condsGTDB","Pr(>|t|)"]
})

res_lm_adj <- p.adjust(res_lm, method = "BH")
sum(res_lm_adj < 0.05)


```
```{r linear model results, message = FALSE, warning = FALSE}

clr_res_lm <- data.frame(
  KEGG = colnames(clr_mat),
  p_value = res_lm,
  p_adj = res_lm_adj
)

sig_kegg <- clr_res_lm %>%
  filter(p_adj < 0.05) %>%
  arrange(p_adj)


sig_kegg$effect <- sapply(sig_kegg$KEGG, function(k) {
  median(clr_mat[, k][conds == "GTDB"]) -
    median(clr_mat[, k][conds == "EHI"])
})

sig_kegg <- sig_kegg %>%
  arrange(desc(abs(effect)))

sig_kegg
```



## GIFTs

PCoA with Euclidean distances:
```{r pcoa_ordination, message=FALSE, fig.height=8, fig.width=10, fig.fullwidth=TRUE}
# Convert the GIFTs into a matrix of functional elements per genome (row)
gift_pcoa <- genome_gifts %>%
    to.elements(., GIFT_db) %>%
    as.data.frame() %>%
    vegdist(method="euclidean") %>%
    pcoa() #principal component analysis

#Extract eigenvalues (variance explained by first 10 axes)
gift_pcoa_rel_eigen <- gift_pcoa$values$Relative_eig[1:10]


# Get genome positions
gift_pcoa_vectors <- gift_pcoa$vectors %>% #extract vectors
  as.data.frame() %>% 
 dplyr::select(Axis.1,Axis.2) # keep the first 2 axes


gift_pcoa_eigenvalues <- gift_pcoa$values$Eigenvalues[c(1,2)]


#For the black arrows: Functional group loadings
# covariance between each functional trait and pcoa axis scores
#scale with the eigenvectors
gift_pcoa_gifts <- cov(genome_gifts, scale(gift_pcoa_vectors)) %*%
  diag((gift_pcoa_eigenvalues/(nrow(genome_gifts)-1))^(-0.5)) %>%
  as.data.frame() %>% 
  dplyr::rename(Axis.1=1,Axis.2=2) %>% 
  rownames_to_column(var="label") %>% 
  #get function summary vectors
  mutate(func=substr(label,1,3)) %>% 
  group_by(func) %>% #grouping by function
  summarise(Axis.1=mean(Axis.1),
            Axis.2=mean(Axis.2)) %>% 
  dplyr::rename(label=func) %>% 
  filter(!label %in% c("S01","S02","S03"))


```


```{r pcoa_ordination_plot, message=FALSE, fig.height=8, fig.width=10, fig.fullwidth=TRUE}
set.seed(101)
scale <- 20 # scale for vector loadings (to make arrows visible)
gift_pcoa_vectors %>% 
  rownames_to_column(var="ID") %>% 
  left_join(genome_metadata, by="ID") %>%
  ggplot() +
      #genome positions
      scale_color_manual(values=source_colors)+
      geom_point(aes(x=Axis.1,y=Axis.2, color = source), 
                 alpha=0.9, shape=16) +
      scale_size_continuous(range = c(0.1,5)) +
      #loading positions
      geom_segment(data=gift_pcoa_gifts, 
                   aes(x=0, y=0, xend=Axis.1 * scale, yend=Axis.2 * scale),
                    arrow = arrow(length = unit(0.3, "cm"), 
                    type = "open", 
                    angle = 25),
                    linewidth = 0.5, 
                    color = "black") +
     #Primary and secondary scale adjustments
     scale_x_continuous(name = paste0("PCoA1 (",round(gift_pcoa_rel_eigen[1]*100, digits = 2), " %)"),
                      sec.axis = sec_axis(~ . / scale, name = "Loadings on PCoA1")
            ) +
     scale_y_continuous(name = paste0("PCoA2 (",round(gift_pcoa_rel_eigen[2]*100, digits = 2), " %)"),
                      sec.axis = sec_axis(~ . / scale, name = "Loadings on PCoA2")
            ) +
    geom_label_repel(data = gift_pcoa_gifts,
                     aes(label = label, x = Axis.1 * scale, y = Axis.2 * scale),
                     segment.color = 'transparent') +
    xlim(-0.8,1) + 
    ylim(-1,1.5) +
    theme_minimal() + 
  
  labs(
    x = paste0("PCoA1 (", round(gift_pcoa_rel_eigen[1]*100, 2), " %)"),
    y = paste0("PCoA2 (", round(gift_pcoa_rel_eigen[2]*100, 2), " %)")
  )


gift_pcoa_vectors %>% 
  rownames_to_column(var="ID") %>% 
  left_join(genome_metadata, by="ID") %>%
  ggplot() +
      #genome positions
      geom_point(aes(x=Axis.1,y=Axis.2, color = completeness), 
                 alpha=0.9, shape=16) +
      scale_size_continuous(range = c(0.1,5)) +
      #loading positions
      geom_segment(data=gift_pcoa_gifts, 
                   aes(x=0, y=0, xend=Axis.1 * scale, yend=Axis.2 * scale),
                    arrow = arrow(length = unit(0.3, "cm"), 
                    type = "open", 
                    angle = 25),
                    linewidth = 0.5, 
                    color = "black") +
     #Primary and secondary scale adjustments
     scale_x_continuous(name = paste0("PCoA1 (",round(gift_pcoa_rel_eigen[1]*100, digits = 2), " %)"),
                      sec.axis = sec_axis(~ . / scale, name = "Loadings on PCoA1")
            ) +
     scale_y_continuous(name = paste0("PCoA2 (",round(gift_pcoa_rel_eigen[2]*100, digits = 2), " %)"),
                      sec.axis = sec_axis(~ . / scale, name = "Loadings on PCoA2")
            ) +
    geom_label_repel(data = gift_pcoa_gifts,
                     aes(label = label, x = Axis.1 * scale, y = Axis.2 * scale),
                     segment.color = 'transparent') +
    xlim(-0.8,1) + 
    ylim(-1,1.5) +
    theme_minimal() + 
  
  labs(
    x = paste0("PCoA1 (", round(gift_pcoa_rel_eigen[1]*100, 2), " %)"),
    y = paste0("PCoA2 (", round(gift_pcoa_rel_eigen[2]*100, 2), " %)")
  )



gift_pcoa_vectors %>% 
  rownames_to_column(var="ID") %>% 
  left_join(genome_metadata, by="ID") %>%
  ggplot() +
      #genome positions
      geom_point(aes(x=Axis.1,y=Axis.2, color = continent), 
                 alpha=0.9, shape=16) +
      scale_size_continuous(range = c(0.1,5)) +
      #loading positions
      geom_segment(data=gift_pcoa_gifts, 
                   aes(x=0, y=0, xend=Axis.1 * scale, yend=Axis.2 * scale),
                    arrow = arrow(length = unit(0.3, "cm"), 
                    type = "open", 
                    angle = 25),
                    linewidth = 0.5, 
                    color = "black") +
     #Primary and secondary scale adjustments
     scale_x_continuous(name = paste0("PCoA1 (",round(gift_pcoa_rel_eigen[1]*100, digits = 2), " %)"),
                      sec.axis = sec_axis(~ . / scale, name = "Loadings on PCoA1")
            ) +
     scale_y_continuous(name = paste0("PCoA2 (",round(gift_pcoa_rel_eigen[2]*100, digits = 2), " %)"),
                      sec.axis = sec_axis(~ . / scale, name = "Loadings on PCoA2")
            ) +
    geom_label_repel(data = gift_pcoa_gifts,
                     aes(label = label, x = Axis.1 * scale, y = Axis.2 * scale),
                     segment.color = 'transparent') +
    xlim(-0.8,1) + 
    ylim(-1,1.5) +
    theme_minimal() + 
  
  labs(
    x = paste0("PCoA1 (", round(gift_pcoa_rel_eigen[1]*100, 2), " %)"),
    y = paste0("PCoA2 (", round(gift_pcoa_rel_eigen[2]*100, 2), " %)")
  )

```




Using k-means to cluster the groups and check which MAGs cluster together:
```{r checking the groups}
coords <- gift_pcoa_vectors %>%
  rownames_to_column("MAG") %>%
  as_tibble()

set.seed(123)
km <- kmeans(coords[, c("Axis.1", "Axis.2")], centers = 4, nstart = 25, iter.max = 100)

coords <- coords %>% mutate(cluster = factor(km$cluster))

```


```{r kmeans plot}
# centroids as a tibble for plotting
centroids <- as_tibble(km$centers) %>% mutate(cluster = factor(1:nrow(km$centers)))

ggplot(coords, aes(x = Axis.1, y = Axis.2, color = cluster)) +
  geom_point(size = 2, alpha = 0.8) +
  geom_point(data = centroids, aes(x = Axis.1, y = Axis.2, color = cluster),
             shape = 4, size = 5, stroke = 1.25) +   # X marks centroids
  theme_minimal() +
  labs(title = paste0("PCoA colored by kmeans (k=4)"),
       color = "cluster")

```

```{r cluster mag lists}
mags_by_cluster <- split(coords$MAG, km$cluster)
mags_by_cluster
```
### Checking each cluster at once
```{r clusters}
cluster1_MAGs <- mags_by_cluster[[1]]
genome_metadata %>% filter(ID %in% cluster1_MAGs)

cluster2_MAGs <- mags_by_cluster[[2]]
genome_metadata %>% filter(ID %in% cluster2_MAGs)

cluster3_MAGs <- mags_by_cluster[[3]]
genome_metadata %>% filter(ID %in% cluster3_MAGs)

cluster4_MAGs <- mags_by_cluster[[4]]
genome_metadata %>% filter(ID %in% cluster4_MAGs)
```


```{r combined table}
metadata_with_cluster <- genome_metadata %>%
  left_join(coords %>% dplyr::select(MAG, cluster), by = c("ID" = "MAG"))

metadata_with_cluster %>%
  group_by(cluster, source) %>%
  summarise(n = n(), .groups = "drop") %>%
  arrange(cluster, desc(n))

# Group summaries
metadata_with_cluster %>%
  group_by(cluster) %>%
  summarise(mean_genome_size = mean(genome_size, na.rm = TRUE),
            median_contamination = median(contamination, na.rm = TRUE),
            .groups = "drop")

```

```{r save the cluster info into rdata}
save(ehi_mags,
     phylum_colors,
     genome_annotations,
     genome_gifts,
     contig_to_genome,
     gtdb_metadata,
     ehi_metadata,
     master_index,
     genome_metadata,
     source_colors,
     getphylo_tree,
     metadata_with_cluster,
     file = "data/data.Rdata")
```




Is the genome size different between clusters?
```{r testing genome size differences}
kruskal.test(genome_size ~ cluster, data = metadata_with_cluster)


pairwise.wilcox.test(
  x = metadata_with_cluster$genome_size,
  g = metadata_with_cluster$cluster,
  p.adjust.method = "BH"   # FDR correction
)
```



Plots
```{r summary plots}
ggplot(metadata_with_cluster, aes(x = genome_size, y = GC, col = cluster))+
  geom_point()+
  theme_bw()

ggplot(metadata_with_cluster, aes(x = assembly_type, y = source, col = cluster))+
  geom_point()+
  theme_bw()

ggplot(metadata_with_cluster, aes(x = cluster, y = genome_size, col = cluster))+
  geom_point()+
  theme_bw()
```
```{r GIFT aggregations}
#Aggregate bundle-level GIFTs into the compound level
GIFTs_elements <- to.elements(genome_gifts,GIFT_db)

#Aggregate element-level GIFTs into the function level
GIFTs_functions <- to.functions(GIFTs_elements,GIFT_db)

#Aggregate function-level GIFTs into overall Biosynthesis, Degradation and Structural GIFTs
GIFTs_domains <- to.domains(GIFTs_functions,GIFT_db)

```



```{r comumnity_elem_plot_gut, comment="", message=FALSE, warning=FALSE, fig.height=16, fig.width=14, fig.fullwidth=TRUE}
GIFTs_elements %>%
    as.data.frame() %>%
    rownames_to_column(var="MAG")%>%
    pivot_longer(!MAG,names_to="trait",values_to="gift") %>%
    left_join(metadata_with_cluster, by = join_by(MAG == ID)) %>%
    mutate(functionid = substr(trait, 1, 3)) %>%
    mutate(trait = case_when(
      trait %in% GIFT_db$Code_element ~ GIFT_db$Element[match(trait, GIFT_db$Code_element)],
      TRUE ~ trait
    )) %>%
    mutate(functionid = case_when(
      functionid %in% GIFT_db$Code_function ~ GIFT_db$Function[match(functionid, GIFT_db$Code_function)],
      TRUE ~ functionid
    )) %>%
    mutate(trait=factor(trait,levels=unique(GIFT_db$Element))) %>%
    mutate(functionid=factor(functionid,levels=unique(GIFT_db$Function))) %>%
    ggplot(aes(x=MAG,y=trait,fill=gift)) +
        geom_tile(colour="white", linewidth=0.2)+
        scale_fill_gradientn(colours=rev(c("#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#e6f598", "#abdda4", "#ddf1da")))+
        facet_grid(functionid ~ cluster, scales="free",space="free") +
        theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
              axis.text.y = element_text(size=6),
              strip.text.y = element_text(angle = 0)
              ) +
        labs(y="Traits",x="Samples",fill="GIFT")
```




```{r comumnity_elem_plot_source, comment="", message=FALSE, warning=FALSE, fig.height=16, fig.width=14, fig.fullwidth=TRUE}
GIFTs_elements %>%
    as.data.frame() %>%
    rownames_to_column(var="MAG")%>%
    pivot_longer(!MAG,names_to="trait",values_to="gift") %>%
    left_join(metadata_with_cluster, by = join_by(MAG == ID)) %>%
    mutate(functionid = substr(trait, 1, 3)) %>%
    mutate(trait = case_when(
      trait %in% GIFT_db$Code_element ~ GIFT_db$Element[match(trait, GIFT_db$Code_element)],
      TRUE ~ trait
    )) %>%
    mutate(functionid = case_when(
      functionid %in% GIFT_db$Code_function ~ GIFT_db$Function[match(functionid, GIFT_db$Code_function)],
      TRUE ~ functionid
    )) %>%
    mutate(trait=factor(trait,levels=unique(GIFT_db$Element))) %>%
    mutate(functionid=factor(functionid,levels=unique(GIFT_db$Function))) %>%
    ggplot(aes(x=MAG,y=trait,fill=gift)) +
        geom_tile(colour="white", linewidth=0.2)+
        scale_fill_gradientn(colours=rev(c("#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#e6f598", "#abdda4", "#ddf1da")))+
        facet_grid(functionid ~ source, scales="free",space="free") +
        theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
              axis.text.y = element_text(size=6),
              strip.text.y = element_text(angle = 0)
              ) +
        labs(y="Traits",x="Samples",fill="GIFT")
```





```{r GIFT element plot, fig.height=10, fig.width=8, fig.fullwidth=TRUE}
library(RColorBrewer)
library(reshape2)

GIFTs_elements %>%
  reshape2::melt() %>%
  dplyr::rename(Genome = Var1, Code_element = Var2, GIFT = value) %>%
  inner_join(GIFT_db,by="Code_element") %>%
  ggplot(., aes(x=Code_element, y=Genome, fill=GIFT, group=Code_function))+
    geom_tile()+
    scale_y_discrete(guide = guide_axis(check.overlap = TRUE))+
    scale_x_discrete(guide = guide_axis(check.overlap = TRUE))+
    scale_fill_gradientn(limits = c(0,1), colours=brewer.pal(7, "YlGnBu"))+
    facet_grid(. ~ Code_function, scales = "free", space = "free")+
    theme_grey(base_size=8)+
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),strip.text.x = element_text(angle = 90))
```


```{r checking_which_function_is_d09}
head(GIFT_db)

GIFT_db%>%
  filter(Code_function == "D09")
```


```{r amr_gift_plot, fig.height=10, fig.width=8, fig.fullwidth=TRUE}
library(reshape2)
library(RColorBrewer)

GIFTs_elements %>%
  melt() %>%
  dplyr::rename(Genome = Var1, Code_element = Var2, GIFT = value) %>%
  inner_join(GIFT_db, by = "Code_element") %>%            # Map Code_element -> Element & Function
  filter(str_starts(Code_element, "D09")) %>%            # Only antibiotic degradation
  left_join(metadata_with_cluster, by = join_by(Genome == ID)) %>%
  mutate(cluster = factor(cluster)) %>%
  droplevels() %>%
  arrange(cluster, Genome) %>%
  # Map Code_element IDs to trait names
  mutate(trait = case_when(
    Code_element %in% GIFT_db$Code_element ~ GIFT_db$Element[match(Code_element, GIFT_db$Code_element)],
    TRUE ~ Code_element
  )) %>%
  # Map function IDs for faceting if desired
  mutate(functionid = case_when(
    substr(Code_element,1,3) %in% GIFT_db$Code_function ~ GIFT_db$Function[match(substr(Code_element,1,3), GIFT_db$Code_function)],
    TRUE ~ substr(Code_element,1,3)
  )) %>%
  mutate(trait = factor(trait, levels = unique(GIFT_db$Element))) %>%
  ggplot(aes(x = trait, y = Genome, fill = GIFT)) +
    geom_tile(colour = "white", linewidth = 0.2) +
    scale_y_discrete(guide = guide_axis(check.overlap = TRUE)) +
    scale_x_discrete(guide = guide_axis(check.overlap = TRUE)) +
    scale_fill_gradientn(limits = c(0,1), colours = brewer.pal(7, "YlGnBu")) +
    facet_wrap(~ cluster, scales = "free_y", ncol = 1) +  
    theme_grey(base_size = 8) +
    theme(
      axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
      strip.text.x = element_text(angle = 0)
    ) +
    labs(x = "Trait", fill = "GIFT")
```

```{r horizontal gift plot with antibiotic resistance genes}
GIFTs_elements %>%
  melt() %>%
  dplyr::rename(Genome = Var1, Code_element = Var2, GIFT = value) %>%
  inner_join(GIFT_db, by = "Code_element") %>%
  filter(str_starts(Code_element, "D09")) %>%
  left_join(metadata_with_cluster, by = join_by(Genome == ID)) %>%
  mutate(cluster = factor(cluster)) %>%
  droplevels() %>%
  arrange(cluster, Genome) %>%
  mutate(trait = Element) %>%
  # Ensure trait is a factor to maintain order
  mutate(trait = factor(trait, levels = rev(unique(GIFT_db$Element)))) %>%
  ggplot( aes(x = Genome, y = trait)) +
  # Heatmap
  geom_tile(aes(fill = GIFT), color = "white") +
  scale_fill_gradientn(colours = brewer.pal(7, "YlGnBu"), name = "GIFT Score") +
  
  # Start a new fill scale for the Source bar
  new_scale_fill() +
  
  # Add the source bar at the very top or bottom
  geom_tile(aes(y = -0.5, fill = source), height = 0.5) +
  scale_fill_manual(values = source_colors) +
  
  facet_grid(~ cluster, scales = "free_x", space = "free_x") +
  theme_minimal(base_size = 8) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
```



### Checking difference in GIFTs

#### Cluster-wise
Element GIFTs different between clusters of pcoa
```{r testing gifts between clusters, message = FALSE, warning = FALSE}
# Get only the GIFT columns
gift_cols <- colnames(GIFTs_elements)[!(colnames(GIFTs_elements) %in% c("MAG_ID","cluster","source"))]

gift_dataframe <- GIFTs_elements %>%
  as.data.frame() %>%            
  rownames_to_column(var = "ID") 

gift_df_meta <- gift_dataframe %>%
  left_join(metadata_with_cluster, by = "ID")


# Kruskal-Wallis for 4 groups
kruskal_results <- sapply(gift_cols, function(g) {
  kruskal.test(as.formula(paste(g, "~ cluster")), data = gift_df_meta)$p.value
})

# Adjust for multiple testing
kruskal_results_adj <- p.adjust(kruskal_results, method = "BH")

# Combine into a table
kruskal_table <- data.frame(
  GIFT = gift_cols,
  p_value = kruskal_results,
  p_adj = kruskal_results_adj
)

kruskal_table %>% filter(p_adj<0.05)
```


```{r testing gifts between clusters pairwise, message = FALSE, warning = FALSE}
pairwise_results <- lapply(gift_cols, function(g) {
  pairwise.wilcox.test(
    x = gift_df_meta[[g]],
    g = gift_df_meta$cluster,
    p.adjust.method = "BH"
  )
})

names(pairwise_results) <- gift_cols

pairwise_sig_table <- lapply(names(pairwise_results), function(g) {
  
  # Extract p-value matrix
  pmat <- pairwise_results[[g]]$p.value
  
  # Convert to long format
  pmat_long <- as.data.frame(as.table(pmat)) %>%
    filter(!is.na(Freq)) %>%       # remove NA (diagonal / upper triangle)
    dplyr::rename(group1 = Var1, group2 = Var2, p_adj = Freq) %>%
    filter(p_adj < 0.05) %>%      
    mutate(GIFT = g)
  
  return(pmat_long)
})



# Combine all GIFTs into one table
pairwise_sig_table <- bind_rows(pairwise_sig_table) %>%
  dplyr::select(GIFT, group1, group2, p_adj)

pairwise_sig_table 

```


```{r gifts different between cluster_1}
GIFTs_elements %>%
  melt() %>%
  dplyr::rename(Genome = Var1, Code_element = Var2, GIFT = value) %>%
  inner_join(GIFT_db, by = "Code_element") %>%
  filter(Code_element %in% pairwise_sig_table$GIFT) %>%
  left_join(metadata_with_cluster, by = join_by(Genome == ID)) %>%
  distinct(Genome, Code_element, .keep_all = TRUE) %>%
  mutate(cluster = factor(cluster)) %>%
  droplevels() %>%
  arrange(cluster, Genome) %>%
  mutate(trait = Element) %>%
  ggplot(aes(x = Genome, y = trait, fill = GIFT)) +
    geom_tile(colour = "white", linewidth = 0.2) +
    scale_y_discrete(guide = guide_axis(check.overlap = TRUE)) +
    scale_x_discrete(guide = guide_axis(check.overlap = TRUE)) +
    scale_fill_gradientn(limits = c(0,1), colours = RColorBrewer::brewer.pal(7, "YlGnBu")) +
  new_scale_fill() +
  
  # Add the source bar at the very top or bottom
  geom_tile(aes(y = -0.5, fill = source), height = 0.3) +
  scale_fill_manual(values = source_colors) +
    facet_grid(~ cluster, scales = "free_x", space = "free_x") + 
    theme(
      axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, size = 4),
      strip.text.x = element_text(face = "bold")
    ) +
    labs(y = "Trait", x = "Genome", fill = "GIFT")
```

```{r checking code elements}
GIFT_db%>%
  filter(Code_element %in%  pairwise_sig_table$GIFT)
```


```{r pairwise wilcox cluster with effect size}
library(rstatix)
library(dplyr)
library(purrr)

pairwise_sig_table <- map_df(gift_cols, function(g) {
  
  # Check if there is variation in the GIFT values
  # If all values are the same, skip this GIFT
  if(length(unique(gift_df_meta[[g]])) < 2) return(NULL)
  
  # Run the test safely
  tryCatch({
    results <- gift_df_meta %>%
      wilcox_test(as.formula(paste0("`", g, "` ~ cluster")), p.adjust.method = "BH")
    
    eff <- gift_df_meta %>%
      wilcox_effsize(as.formula(paste0("`", g, "` ~ cluster")))
    
    results %>%
      left_join(eff, by = c("group1", "group2", ".y." = ".y.", "n1", "n2")) %>%
      filter(p.adj < 0.05) %>%
      mutate(GIFT = g)
  }, error = function(e) return(NULL)) # If it still fails, just skip it
})

top_gifts <- pairwise_sig_table %>%
  arrange(desc(effsize))


top_gifts
```




```{r sig_cluster_gift_plot, message = FALSE, warning = FALSE, fig.height=10, fig.width=8, fig.fullwidth=TRUE}
library(reshape2)
library(RColorBrewer)

GIFTs_elements %>%
  melt() %>%
  dplyr::rename(Genome = Var1, Code_element = Var2, GIFT = value) %>%
  inner_join(GIFT_db, by = "Code_element") %>%
  # Only keep significant traits
  filter(Code_element %in% pairwise_sig_table$GIFT) %>%
  left_join(metadata_with_cluster, by = join_by(Genome == ID)) %>%
  distinct(Genome, Code_element, .keep_all = TRUE) %>%
  mutate(cluster = factor(cluster)) %>%
  droplevels() %>%
  arrange(cluster, Genome) %>%
  mutate(trait = Element) %>%          # human-readable trait
  ggplot(aes(x = trait, y = Genome, fill = GIFT)) +
    geom_tile(colour = "white", linewidth = 0.2) +
    scale_y_discrete(guide = guide_axis(check.overlap = TRUE)) +
    scale_x_discrete(guide = guide_axis(check.overlap = TRUE)) +
    scale_fill_gradientn(limits = c(0,1), colours = RColorBrewer::brewer.pal(7, "YlGnBu")) +
    facet_wrap(~ cluster, scales = "free_y", ncol = 1) +
    theme_grey(base_size = 8) +
    theme(
      axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
      strip.text.x = element_text(angle = 0)
    ) +
    labs(x = "Trait", fill = "GIFT")

```

```{r gifts different between cluster}
GIFTs_elements %>%
  melt() %>%
  dplyr::rename(Genome = Var1, Code_element = Var2, GIFT = value) %>%
  inner_join(GIFT_db, by = "Code_element") %>%
  filter(Code_element %in% pairwise_sig_table$GIFT) %>%
  left_join(metadata_with_cluster, by = join_by(Genome == ID)) %>%
  distinct(Genome, Code_element, .keep_all = TRUE) %>%
  mutate(cluster = factor(cluster)) %>%
  droplevels() %>%
  arrange(cluster, Genome) %>%
  mutate(trait = Element) %>%
  ggplot(aes(x = Genome, y = trait, fill = GIFT)) +
    geom_tile(colour = "white", linewidth = 0.2) +
    scale_y_discrete(guide = guide_axis(check.overlap = TRUE)) +
    scale_x_discrete(guide = guide_axis(check.overlap = TRUE)) +
    scale_fill_gradientn(limits = c(0,1), colours = RColorBrewer::brewer.pal(7, "YlGnBu")) +
    facet_grid(~ cluster, scales = "free_x", space = "free_x") + 
    theme_grey(base_size = 8) +
    theme(
      axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),
      strip.text.x = element_text(face = "bold")
    ) +
    labs(y = "Trait", x = "Genome", fill = "GIFT")
```



#### Source-wise
GIFTs that are different between EHI and GTDB
```{r testing gifts between sources pairwise, message = FALSE, warning = FALSE}
wilcox_results <- sapply(gift_cols, function(g) {
  wilcox.test(as.formula(paste(g, "~ source")), data = gift_df_meta)$p.value
})

wilcox_results_adj <- p.adjust(wilcox_results, method = "BH")

data.frame(
  GIFT = gift_cols,
  p_value = wilcox_results,
  p_adj = wilcox_results_adj
)

effect_size <- sapply(gift_cols, function(g) {
  median(gift_df_meta[[g]][gift_df_meta$source=="GTDB"]) -
    median(gift_df_meta[[g]][gift_df_meta$source=="EHI"])
})

wilcox_res_source <- data.frame(
  GIFT = gift_cols,
  p_value = wilcox_results,
  p_adj = wilcox_results_adj,
  effect = effect_size
)


wilcox_res_source %>% dplyr::select(GIFT, p_adj, effect) %>% filter(p_adj<0.05)

```
```{r checking code element B0215}
GIFT_db%>%
  filter(Code_element %in% c("B0215", "B0307", "D0601") )
```
```{r adding effect size wilcox source}

wilcox_res_source <- map_df(gift_cols, function(g) {
  
 
  if(length(unique(gift_df_meta[[g]])) < 2) return(NULL)
  
  tryCatch({
    # Calculate p-value
    res <- gift_df_meta %>%
      wilcox_test(as.formula(paste0("`", g, "` ~ source")))
    
    # Calculate effect size (Rank-Biserial Correlation)
    eff <- gift_df_meta %>%
      wilcox_effsize(as.formula(paste0("`", g, "` ~ source")))
    
    # Combine results
    res %>%
      left_join(eff, by = c("group1", "group2", ".y." = ".y.", "n1", "n2")) %>%
      mutate(GIFT = g)
  }, error = function(e) return(NULL))
})

#  Adjust P-values and filter
wilcox_res_source <- wilcox_res_source %>%
  mutate(p_adj = p.adjust(p, method = "BH")) %>%
  dplyr::select(GIFT, group1, group2, p_adj, effsize, magnitude) %>%
  filter(p_adj < 0.05) %>%
  arrange(desc(abs(effsize))) # Sort by strongest effect

# View the top results
print(wilcox_res_source)
```

```{r gifts different between source plot}
GIFTs_elements %>%
  melt() %>%
  dplyr::rename(Genome = Var1, Code_element = Var2, GIFT = value) %>%
  inner_join(GIFT_db, by = "Code_element") %>%
  filter(Code_element %in% wilcox_res_source$GIFT) %>%
  left_join(metadata_with_cluster, by = join_by(Genome == ID)) %>%
  distinct(Genome, Code_element, .keep_all = TRUE) %>%
  mutate(cluster = factor(cluster)) %>%
  droplevels() %>%
  arrange(cluster, Genome) %>%
  mutate(trait = Element) %>%
  ggplot(aes(x = Genome, y = trait, fill = GIFT)) +
    geom_tile(colour = "white", linewidth = 0.2) +
    scale_y_discrete(guide = guide_axis(check.overlap = TRUE)) +
    scale_x_discrete(guide = guide_axis(check.overlap = TRUE)) +
    scale_fill_gradientn(limits = c(0,1), colours = RColorBrewer::brewer.pal(7, "YlGnBu")) +
  new_scale_fill() +
  
  # Add the source bar at the very top or bottom
  geom_tile(aes(y = -0.5, fill = source), height = 0.5) +
  scale_fill_manual(values = source_colors) +
    facet_grid(~ source, scales = "free_x", space = "free_x") + 
    theme(
      axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),
      strip.text.x = element_text(face = "bold")
    ) +
    labs(y = "Trait", x = "Genome", fill = "GIFT")
```




# Functional Analysis

```{r load_data_mag, message=FALSE, warning=FALSE, echo=FALSE}
load("data/data.Rdata")
```

## Functional overview

```{r genomes annotated}
n_genes <- genome_annotations %>%
  group_by(genome) %>%
  summarize(n_genes = n())

n_genes
```


#### Predicted genes
```{r predicted_stats, message=FALSE, warning=FALSE}
pred_genes <- genome_annotations %>%
  nrow()

cat(pred_genes)
```

#### Number of annotated genes and percentages
```{r annotation_stats, message=FALSE, warning=FALSE, fig.height=10, fig.width=10, fig.fullwidth=TRUE}
#How many genes have at least 1 annotation
genome_annota <- genome_annotations %>%
  filter(if_any(c(kegg, pfam, cazy), ~ !is.na(.))) %>%
  nrow()

cat(genome_annota)

#Percentage of predicted genes with at least 1 annotation
genome_annota*100/pred_genes
```

#### Number of KEGG annotatated genes and percentages
```{r kegg_stats_gut, message=FALSE, warning=FALSE, fig.height=10, fig.width=10, fig.fullwidth=TRUE}
# KEGG annotation
kegg_annota <- genome_annotations %>%
  filter(!is.na(kegg)) %>%
  nrow()
cat(kegg_annota)

# KEGG annotation percentage
kegg_annota*100/genome_annota
```


## KEGG
### Functional Ordination

PCA of KEGG annotations:
```{r pca of kegg}
kegg_counts <- genome_annotations %>%
  filter(mag_id != "GCA_015060925.1")%>% #this is the smaller mag that's weird
  filter(!is.na(kegg)) %>%          
  dplyr::count(mag_id, kegg) %>%           
  pivot_wider(
    names_from = kegg,
    values_from = n,
    values_fill = 0
  )

# Normalization
kegg_rel <- kegg_counts %>%
  column_to_rownames("mag_id")
kegg_rel <- kegg_rel / rowSums(kegg_rel)  # Each row sums to 1

# Remove zero variance
kegg_rel_nz <- kegg_rel[, apply(kegg_rel, 2, sd) > 0]

# PCA with scaling
pca <- prcomp(kegg_rel_nz, scale. = TRUE)

# Check variance explained
summary(pca)$importance[,1:5]
```


```{r plot pca kegg}
scores <- as.data.frame(pca$x)
scores$ID <- rownames(scores)

scores <- scores %>%
  left_join(genome_metadata, by = "ID")

ggplot(scores, aes(PC1, PC2, color = source)) +
  geom_point(size = 2) +
   scale_color_manual(values = source_colors)+
  theme_minimal() +
  labs(
    title = "PCA of KEGG annotations across MAGs",
    x = paste0("PC1 (", round(summary(pca)$importance[2,1] * 100, 1), "%)"),
    y = paste0("PC2 (", round(summary(pca)$importance[2,2] * 100, 1), "%)")
  )

ggplot(scores, aes(PC2, PC3, color = source)) +
   scale_color_manual(values = source_colors)+
  geom_point(size = 2) +
  theme_minimal() +
  labs(
    title = "P2 vs PC3 of KEGG annotations across MAGs",
    x = paste0("PC2 (", round(summary(pca)$importance[2,2] * 100, 1), "%)"),
    y = paste0("PC3 (", round(summary(pca)$importance[2,3] * 100, 1), "%)")
  )

ggplot(scores, aes(PC3, PC4, color = source)) +
   scale_color_manual(values = source_colors)+
  geom_point(size = 2) +
  theme_minimal() +
  labs(
    title = "P3 vs PC4 of KEGG annotations across MAGs",
    x = paste0("PC3 (", round(summary(pca)$importance[2,3] * 100, 1), "%)"),
    y = paste0("PC4 (", round(summary(pca)$importance[2,4] * 100, 1), "%)")
  )


ggplot(scores, aes(PC1, PC2, color = genome_size)) +
  geom_point(size = 2) +
  theme_minimal() +
  labs(
    title = "KEGG PCA colored by genome size",
    x = paste0("PC1 (", round(summary(pca)$importance[2,1] * 100, 1), "%)"),
    y = paste0("PC2 (", round(summary(pca)$importance[2,2] * 100, 1), "%)")
  )

ggplot(scores, aes(PC1, PC2, color = completeness)) +
  geom_point(size = 2) +
  theme_minimal() +
  labs(
    title = "KEGG PCA colored by completeness",
    x = paste0("PC1 (", round(summary(pca)$importance[2,1] * 100, 1), "%)"),
    y = paste0("PC2 (", round(summary(pca)$importance[2,2] * 100, 1), "%)")
  )

ggplot(scores, aes(PC1, PC2, color = host_species)) +
  geom_point(size = 2) +
  theme_minimal() +
  labs(
    title = "KEGG PCA colored by host species ",
    x = paste0("PC1 (", round(summary(pca)$importance[2,1] * 100, 1), "%)"),
    y = paste0("PC2 (", round(summary(pca)$importance[2,2] * 100, 1), "%)")
  )
```
```{r loadings pca total}
loadings <- pca$rotation

abs_loadings <- apply(abs(loadings[, 1:2]), 1, sum)
top_combined <- sort(abs_loadings, decreasing = TRUE)[1:10]
top_combined


```
```{r pca loadings pc1}
library(KEGGREST)

top_loadings <- loadings %>%
  as.data.frame() %>%
  rownames_to_column("KEGG") %>%
  arrange(desc(abs(PC1))) 

head(top_loadings)

top_kos <- head(top_loadings)%>%pull(KEGG)

ko_pathways <- lapply(top_kos, function(k) {
  info <- keggGet(paste0("ko:", k))[[1]]
  pathways <- info$PATHWAY
  if(is.null(pathways)) pathways <- NA
  return(pathways)
})

names(ko_pathways) <- top_kos
ko_pathways
```


### KEGG heatmap
```{r kegg heatmap}
# Relative abundance heatmap
pheatmap(kegg_rel_nz,
  color = viridis(100, option = "viridis"),
  cluster_rows = TRUE,
  cluster_cols = TRUE,
  fontsize = 9,
  border_color = NA
)

# For scaled heatmap -> remove zero variance columns 
col_vars <- apply(kegg_rel_nz, 2, var, na.rm = TRUE)
matrix_filtered <- kegg_rel_nz[, col_vars > 0 & !is.na(col_vars)]

# Scale the filtered matrix
scaled <- scale(matrix_filtered, center = TRUE, scale = TRUE)

# Check for any remaining Inf/NaN values
if(any(!is.finite(scaled))) {
  scaled[!is.finite(scaled)] <- 0  # Replace Inf/NaN with 0
}

# Scaled heatmap
pheatmap(scaled,
  color = viridis(100, option = "viridis"),
  cluster_rows = TRUE,
  cluster_cols = TRUE,
  fontsize = 5,
  border_color = NA
)

```


### Testing the differences in KEGG annotations with PERMANOVA

```{r permanova_kegg}
# Distance matrix from normalized data
kegg_dist <- vegdist(kegg_rel_nz, method = "bray") 

# Add metadata
kegg_rel_nz_meta <- kegg_rel_nz %>%
  rownames_to_column("ID") %>%
  left_join(genome_metadata, by = "ID")

#Beta dispersion test
dispersion <- betadisper(kegg_dist, kegg_rel_nz_meta$source)
anova(dispersion) 


# PERMANOVA test
permanova_result <- adonis2(kegg_dist ~ genome_size + source, 
                            data = kegg_rel_nz_meta, 
                            permutations = 999)
print(permanova_result)

adonis2(
  kegg_dist ~ genome_size + source,
  data = kegg_rel_nz_meta,
  permutations = 999,
  by = "margin"
)
```

### Principal Coordinate Analysis - KEGG

```{r pcoa_kegg_dist}
pcoa_res <- cmdscale(kegg_dist, k = 2, eig = TRUE)

# Calculate variance explained 
variance_explained <- pcoa_res$eig / sum(pcoa_res$eig)

pcoa_df <- data.frame(
  PC1 = pcoa_res$points[,1], 
  PC2 = pcoa_res$points[,2], 
  ID = rownames(kegg_rel_nz)
) %>%
  left_join(genome_metadata, by = "ID")


ggplot(pcoa_df, aes(PC1, PC2, color = source)) +
  scale_color_manual(values = source_colors)+
  geom_point(size = 2) +
  theme_minimal() +
  labs(
    title = "PCoA of KEGG annotations across MAGs",
    x = paste0("PC1 (", round(variance_explained[1] * 100, 1), "%)"),
    y = paste0("PC2 (", round(variance_explained[2] * 100, 1), "%)")
  )


ggplot(pcoa_df, aes(PC1, PC2, color = genome_size)) +
  geom_point(size = 2) +
  theme_minimal() +
  labs(
    title = "PCoA of KEGG annotations across MAGs",
    x = paste0("PC1 (",round(variance_explained[1] * 100, 1), "%)"),
    y = paste0("PC2 (", round(variance_explained[2] * 100, 1), "%)")
  )

ggplot(pcoa_df, aes(PC1, PC2, color = host_species)) +
  geom_point(size = 2) +
  theme_minimal() +
  labs(
    title = "PCoA of KEGG annotations across MAGs (colored by host species)",
    x = paste0("PC1 (",round(variance_explained[1] * 100, 1), "%)"),
    y = paste0("PC2 (", round(variance_explained[2] * 100, 1), "%)")
  )
```

### Differential abundance

Differential expression analysis- trying to find which KEGG orthologs are significantly different between EHI vs GTDB
DESeq2

```{r deseq_kegg}
library(DESeq2)

# Prepare the count matrix (KOs as rows, MAGs as columns)
# Ensure only integer columns are kept
counts_mtx <- kegg_counts %>%
  column_to_rownames("mag_id") %>%
  t() 

# Prepare metadata (Must match column names of counts_mtx)
metadata <- genome_metadata %>%
  filter(ID %in% colnames(counts_mtx)) %>%
  column_to_rownames("ID")

# Ensure order matches exactly
metadata <- metadata[colnames(counts_mtx), , drop = FALSE]

#Create DESeq2 object
dds <- DESeqDataSetFromMatrix(countData = counts_mtx,
                              colData = metadata,
                              design = ~ source)

# Run the differential analysis
dds <- DESeq(dds)

# save results (Wildlife vs Human)
res <- results(dds, contrast=c("source", "EHI", "GTDB"), alpha=0.05)


summary(res)



```



```{r saving res_1}
res_df <-res %>% as.data.frame %>% 
  rownames_to_column("KO") %>% 
  as_tibble
```


```{r plot deseq ma plot}
ggplot(res_df,aes(x=baseMean, y=log2FoldChange)) + 
  geom_point(alpha=0.8) + 
  geom_smooth() + 
  scale_x_log10() + 
  geom_hline(yintercept = 0, alpha = 0.75,
  color="red")+
  theme_bw()+ coord_cartesian(ylim=c(-10, 10))
```
```{r volcano plot}
res_df_2<- res_df%>% 
  mutate(label2= ifelse (abs(log2FoldChange) > 0.58 ,KO, ""))

ggplot(res_df_2, aes(x=baseMean, 
                 y=log2FoldChange, 
                 col=padj<0.05, label=label2)) + 
  geom_point(alpha=0.5) + 
  scale_x_log10() + 
  geom_hline(yintercept = 0, alpha = 0.75,
  color="red")+
  geom_text_repel()+
  theme_bw()+ coord_cartesian(ylim=c(-10, 10))


ggplot(res_df_2, aes(x=log2FoldChange, y=-log10(pvalue), color=padj < 0.05, label=label2)) + 
  geom_point(alpha=0.5) +
  geom_vline(xintercept = 1, alpha = 0.75, 
  linetype="dashed")+
  geom_vline(xintercept = -1, alpha = 0.75, 
  linetype="dashed")+
   geom_text_repel() +
  theme_bw()
```


### Wilcoxon

```{r wilcoxon_keggs, message = FALSE, warning = FALSE}
#Transform to long format and run test for every KO
wilcox_results <- kegg_rel_nz_meta %>%
  pivot_longer(cols = starts_with("K"), 
               names_to = "KO", 
               values_to = "rel_abundance") %>%
  group_by(KO) %>%
  do(tidy(wilcox.test(rel_abundance ~ source, data = .))) %>%
  ungroup()

#  Adjust p-values
wilcox_results <- wilcox_results %>%
  mutate(p.adj = p.adjust(p.value, method = "fdr")) %>%
  filter(p.adj < 0.05) %>%
  arrange(p.adj)

head(wilcox_results)
```

```{r plotting top term, message = FALSE, warning = FALSE}
res_df <- as.data.frame(res) %>%
  rownames_to_column("KO") %>%
  filter(padj < 0.05) %>%
  arrange(padj)

# Find KOs that are significant in BOTH tests
common_KOs <- intersect(res_df$KO, wilcox_results$KO)

# Boxplot of the top hit
top_ko <- common_KOs[1]

ggplot(kegg_rel_nz_meta, aes(x = source, y = .data[[top_ko]], fill = source)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(width = 0.2, alpha = 0.5) +
  theme_minimal() +
  labs(title = paste("Distribution of", top_ko),
       y = "Relative Abundance")
```

```{r plot all, message = FALSE, warning = FALSE}
# Filter data to only include the common KOs
plot_data <- kegg_rel_nz_meta %>%
  dplyr::select(ID, source, all_of(common_KOs)) %>%
  pivot_longer(cols = all_of(common_KOs), 
               names_to = "KO", 
               values_to = "Relative_Abundance")


ggplot(plot_data, aes(x = source, y = Relative_Abundance, fill = source)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(width = 0.2, alpha = 0.4, size = 1) +
  facet_wrap(~KO, scales = "free_y", ncol = 5) + # 'free_y' is important as abundance scales vary
  scale_fill_manual(values = source_colors) +
  theme_minimal() +
  theme(strip.text = element_text(face = "bold"),
        legend.position = "bottom") +
  labs(title = "Relative Abundance of Consensus Significant KOs",
       x = "Host Source",
       y = "Relative Abundance")
```

Check alignment with DESeq:
```{r checking medians, message = FALSE, warning = FALSE} 
# Calculate medians for each group to see direction
direction_check <- kegg_rel_nz_meta %>%
  dplyr::select(source, all_of(common_KOs)) %>%
  pivot_longer(-source, names_to = "KO", values_to = "val") %>%
  group_by(KO, source) %>%
  summarize(median_val = median(val), .groups = 'drop') %>%
  pivot_wider(names_from = source, values_from = median_val) %>%
  mutate(Enriched_In = ifelse(GTDB > EHI, "GTDB", "EHI"))

# Merge with your DESeq2 results to see if they align
final_comparison <- res_df %>%
  filter(KO %in% common_KOs) %>%
  dplyr::select(KO, log2FoldChange, padj) %>%
  left_join(direction_check, by = "KO")

print(final_comparison)
```


```{r get the ko pathways, message = FALSE, warning = FALSE}
target_kos <- common_KOs 

# Function to get info from KEGG
get_kegg_info <- function(ko_id) {
  query <- keggGet(ko_id)[[1]]
  
  # Extract Name and Definition
  name <- ifelse(!is.null(query$NAME), query$NAME, "N/A")
  definition <- ifelse(!is.null(query$DEFINITION), query$DEFINITION, "N/A")
  
  # Extract Pathways (often multiple)
  pathways <- if(!is.null(query$PATHWAY)) {
    paste(names(query$PATHWAY), query$PATHWAY, sep = ": ", collapse = "; ")
  } else {
    "No pathway assigned"
  }
  
  return(c(KO = ko_id, Name = name, Definition = definition, Pathways = pathways))
}


ko_info_list <- lapply(target_kos, get_kegg_info)
ko_summary <- as.data.frame(do.call(rbind, ko_info_list))

print(ko_summary)
```


```{r heatmap ko from wilcoxon and deseq, message = FALSE, warning = FALSE}
#Prepare the matrix (KOs as rows, MAGs as columns)
heatmap_mat <- kegg_rel_nz_meta %>%
  column_to_rownames("ID") %>%
  dplyr::select(all_of(common_KOs)) %>%
  as.matrix() %>%
  t()

#  Prepare the annotation data frame
annotation_col <- data.frame(Source = kegg_rel_nz_meta$source)
rownames(annotation_col) <- kegg_rel_nz_meta$ID

# Check if they match
all(colnames(heatmap_mat) == rownames(annotation_col))

#colors
ann_colors <- list(
  Source = source_colors
)

# Plot
pheatmap(heatmap_mat, 
         annotation_col = annotation_col, 
         annotation_colors = ann_colors,
         scale = "row",          
         show_colnames = TRUE, 
         cluster_cols = TRUE,    
         main = "Consensus KOs: Human vs Wildlife")
```

```{r heatmap with all significant ko from wilcoxon, message = FALSE, warning = FALSE}
#Prepare the matrix (KOs as rows, MAGs as columns)
heatmap_mat <- kegg_rel_nz_meta %>%
  column_to_rownames("ID") %>%
  dplyr::select(all_of(wilcox_results$KO)) %>%
  as.matrix() %>%
  t()

#  Prepare the annotation data frame
annotation_col <- data.frame(Source = kegg_rel_nz_meta$source)
rownames(annotation_col) <- kegg_rel_nz_meta$ID

# Check if they match
all(colnames(heatmap_mat) == rownames(annotation_col))

#colors
ann_colors <- list(
  Source = source_colors
)

# Plot
pheatmap(heatmap_mat, 
         annotation_col = annotation_col, 
         annotation_colors = ann_colors,
         scale = "row",          
         show_colnames = TRUE, 
         cluster_cols = TRUE,    
         main = "Consensus KOs: Human vs Wildlife")
```



### ALDEX2
```{r testing aldex raw, message = FALSE, warning = FALSE}
kegg_raw_mat <- kegg_counts %>%
  column_to_rownames("mag_id") %>%
  as.matrix()

kegg_raw_mat[is.na(kegg_raw_mat)] <- 0


conds <- kegg_rel_nz_meta %>%
  filter(ID %in% rownames(kegg_raw_mat)) %>%
  arrange(match(ID, rownames(kegg_raw_mat))) %>%
  pull(source)

table(conds)  

aldex_clr <- aldex.clr(
  reads = t(kegg_raw_mat),
  conds = conds,
  mc.samples = 128,   # number of Monte Carlo instances
  denom = "all",      
  verbose = TRUE
)

# Welch's t-test and Wilcoxon test
aldex_test   <- aldex.ttest(aldex_clr)
aldex_effect <- aldex.effect(aldex_clr)

# Combine results
aldex_res <- cbind(aldex_test, aldex_effect)

sig_kegg <- aldex_res %>%
  as.data.frame() %>%
  rownames_to_column("KEGG") %>%
  filter(we.eBH < 0.05) %>%  # FDR-corrected
  arrange(we.eBH)

# Add direction of enrichment
sig_kegg <- sig_kegg %>%
  mutate(enriched_in = ifelse(effect > 0, "GTDB", "EHI"))

sig_kegg

```
No significant results...




GENOME SIZE is significantly larger in GTDB MAGs --> correct for genome size

Which functions are enriched per unit genome by source?

```{r adjust kegg matrix by genome size, message = FALSE, warning = FALSE}
genome_sizes <- genome_metadata %>%
  dplyr::select(ID, genome_size)

kegg_counts_gs <- kegg_counts %>%
  left_join(genome_sizes, by = c("mag_id" = "ID")) %>%
  column_to_rownames("mag_id")

# Divide by genome size (in Mb)
kegg_per_mb <- kegg_counts_gs[, -ncol(kegg_counts_gs)] /
  (kegg_counts_gs$genome_size / 1e6)

```



```{r preparation for aldex2, message = FALSE, warning = FALSE}
kegg_mat <- as.matrix(kegg_per_mb)

# Replace any NA
kegg_mat[is.na(kegg_mat)] <- 0

#Filter rare keggs 
keep_kegg <- colSums(kegg_mat > 0) >= 0.1 * nrow(kegg_mat)
kegg_mat <- kegg_mat[, keep_kegg]

#add a pseudocount
kegg_mat <- kegg_mat + 1e-6

conds <- kegg_rel_nz_meta %>%
  filter(ID %in% rownames(kegg_mat)) %>%
  arrange(match(ID, rownames(kegg_mat))) %>%
  pull(source)

table(conds)


scale_factor <- 1e4

kegg_pseudo <- round(kegg_per_mb * scale_factor)

# Replace zeros (ALDEx2 hates structural zeros)
kegg_pseudo[kegg_pseudo == 0] <- 1

```
```{r aldex2, message = FALSE, warning = FALSE}
library(ALDEx2)

aldex_clr <- aldex.clr(
  reads = t(kegg_pseudo),
  conds = conds,
  mc.samples = 128,
  denom = "all",
  verbose = TRUE
)

aldex_test   <- aldex.ttest(aldex_clr)
aldex_effect <- aldex.effect(aldex_clr)

aldex_res <- cbind(aldex_test, aldex_effect)

head(aldex_res)
```



```{r aldex2 significant kegg results}
sig_kegg <- aldex_res %>%
  as.data.frame() %>%
  rownames_to_column("KEGG") %>%
  filter(
    we.eBH < 0.05,
    abs(effect) > 1
  ) %>%
  arrange(desc(abs(effect)))

sig_kegg

```




```{r clr wilcoxon, message = FALSE, warning = FALSE}
library(compositions)

clr_mat <- clr(kegg_per_mb + 1e-6)

res <- apply(clr_mat, 2, function(x) {
  wilcox.test(x ~ conds)$p.value
})

res_adj <- p.adjust(res, method = "BH")

```

```{r check, message = FALSE, warning = FALSE}
clr_res <- data.frame(
  KEGG = names(res),
  p_value = res,
  p_adj = res_adj
) %>%
  arrange(p_adj)

head(clr_res)


sum(clr_res$p_adj < 0.05)


res_lm <- apply(clr_mat, 2, function(x) {
  model <- lm(x ~ conds + kegg_counts_gs$genome_size)
  summary(model)$coefficients["condsGTDB","Pr(>|t|)"]
})

res_lm_adj <- p.adjust(res_lm, method = "BH")
sum(res_lm_adj < 0.05)


```
```{r linear model results, message = FALSE, warning = FALSE}

clr_res_lm <- data.frame(
  KEGG = colnames(clr_mat),
  p_value = res_lm,
  p_adj = res_lm_adj
)

sig_kegg <- clr_res_lm %>%
  filter(p_adj < 0.05) %>%
  arrange(p_adj)


sig_kegg$effect <- sapply(sig_kegg$KEGG, function(k) {
  median(clr_mat[, k][conds == "GTDB"]) -
    median(clr_mat[, k][conds == "EHI"])
})

sig_kegg <- sig_kegg %>%
  arrange(desc(abs(effect)))

sig_kegg
```



## GIFTs

PCoA with Euclidean distances:
```{r pcoa_ordination, message=FALSE, fig.height=8, fig.width=10, fig.fullwidth=TRUE}
# Convert the GIFTs into a matrix of functional elements per genome (row)
gift_pcoa <- genome_gifts %>%
    to.elements(., GIFT_db) %>%
    as.data.frame() %>%
    vegdist(method="euclidean") %>%
    pcoa() #principal component analysis

#Extract eigenvalues (variance explained by first 10 axes)
gift_pcoa_rel_eigen <- gift_pcoa$values$Relative_eig[1:10]


# Get genome positions
gift_pcoa_vectors <- gift_pcoa$vectors %>% #extract vectors
  as.data.frame() %>% 
 dplyr::select(Axis.1,Axis.2) # keep the first 2 axes


gift_pcoa_eigenvalues <- gift_pcoa$values$Eigenvalues[c(1,2)]


#For the black arrows: Functional group loadings
# covariance between each functional trait and pcoa axis scores
#scale with the eigenvectors
gift_pcoa_gifts <- cov(genome_gifts, scale(gift_pcoa_vectors)) %*%
  diag((gift_pcoa_eigenvalues/(nrow(genome_gifts)-1))^(-0.5)) %>%
  as.data.frame() %>% 
  dplyr::rename(Axis.1=1,Axis.2=2) %>% 
  rownames_to_column(var="label") %>% 
  #get function summary vectors
  mutate(func=substr(label,1,3)) %>% 
  group_by(func) %>% #grouping by function
  summarise(Axis.1=mean(Axis.1),
            Axis.2=mean(Axis.2)) %>% 
  dplyr::rename(label=func) %>% 
  filter(!label %in% c("S01","S02","S03"))


```


```{r pcoa_ordination_plot, message=FALSE, fig.height=8, fig.width=10, fig.fullwidth=TRUE}
set.seed(101)
scale <- 20 # scale for vector loadings (to make arrows visible)
gift_pcoa_vectors %>% 
  rownames_to_column(var="ID") %>% 
  left_join(genome_metadata, by="ID") %>%
  ggplot() +
      #genome positions
      scale_color_manual(values=source_colors)+
      geom_point(aes(x=Axis.1,y=Axis.2, color = source), 
                 alpha=0.9, shape=16) +
      scale_size_continuous(range = c(0.1,5)) +
      #loading positions
      geom_segment(data=gift_pcoa_gifts, 
                   aes(x=0, y=0, xend=Axis.1 * scale, yend=Axis.2 * scale),
                    arrow = arrow(length = unit(0.3, "cm"), 
                    type = "open", 
                    angle = 25),
                    linewidth = 0.5, 
                    color = "black") +
     #Primary and secondary scale adjustments
     scale_x_continuous(name = paste0("PCoA1 (",round(gift_pcoa_rel_eigen[1]*100, digits = 2), " %)"),
                      sec.axis = sec_axis(~ . / scale, name = "Loadings on PCoA1")
            ) +
     scale_y_continuous(name = paste0("PCoA2 (",round(gift_pcoa_rel_eigen[2]*100, digits = 2), " %)"),
                      sec.axis = sec_axis(~ . / scale, name = "Loadings on PCoA2")
            ) +
    geom_label_repel(data = gift_pcoa_gifts,
                     aes(label = label, x = Axis.1 * scale, y = Axis.2 * scale),
                     segment.color = 'transparent') +
    xlim(-0.8,1) + 
    ylim(-1,1.5) +
    theme_minimal() + 
  
  labs(
    x = paste0("PCoA1 (", round(gift_pcoa_rel_eigen[1]*100, 2), " %)"),
    y = paste0("PCoA2 (", round(gift_pcoa_rel_eigen[2]*100, 2), " %)")
  )

```




Using k-means to cluster the groups and check which MAGs cluster together:
```{r checking the groups}
coords <- gift_pcoa_vectors %>%
  rownames_to_column("MAG") %>%
  as_tibble()

set.seed(123)
km <- kmeans(coords[, c("Axis.1", "Axis.2")], centers = 4)

coords <- coords %>% mutate(cluster = factor(km$cluster))

```


```{r kmeans plot}
# centroids as a tibble for plotting
centroids <- as_tibble(km$centers) %>% mutate(cluster = factor(1:nrow(km$centers)))

ggplot(coords, aes(x = Axis.1, y = Axis.2, color = cluster)) +
  geom_point(size = 2, alpha = 0.8) +
  geom_point(data = centroids, aes(x = Axis.1, y = Axis.2, color = cluster),
             shape = 4, size = 5, stroke = 1.25) +   # X marks centroids
  theme_minimal() +
  labs(title = paste0("PCoA colored by kmeans (k=4)"),
       color = "cluster")

```

```{r cluster mag lists}
mags_by_cluster <- split(coords$MAG, km$cluster)
mags_by_cluster
```
### Checking each cluster at once
```{r clusters}
cluster1_MAGs <- mags_by_cluster[[1]]
genome_metadata %>% filter(ID %in% cluster1_MAGs)

cluster2_MAGs <- mags_by_cluster[[2]]
genome_metadata %>% filter(ID %in% cluster2_MAGs)

cluster3_MAGs <- mags_by_cluster[[3]]
genome_metadata %>% filter(ID %in% cluster3_MAGs)

cluster4_MAGs <- mags_by_cluster[[4]]
genome_metadata %>% filter(ID %in% cluster4_MAGs)
```


```{r combined table}
metadata_with_cluster <- genome_metadata %>%
  left_join(coords %>% dplyr::select(MAG, cluster), by = c("ID" = "MAG"))

metadata_with_cluster %>%
  group_by(cluster, source) %>%
  summarise(n = n(), .groups = "drop") %>%
  arrange(cluster, desc(n))

# Group summaries
metadata_with_cluster %>%
  group_by(cluster) %>%
  summarise(mean_genome_size = mean(genome_size, na.rm = TRUE),
            median_contamination = median(contamination, na.rm = TRUE),
            .groups = "drop")

```

```{r save the cluster info into rdata}
save(ehi_mags,
     phylum_colors,
     genome_annotations,
     genome_gifts,
     contig_to_genome,
     gtdb_metadata,
     ehi_metadata,
     master_index,
     genome_metadata,
     source_colors,
     getphylo_tree,
     metadata_with_cluster,
     file = "data/data.Rdata")
```




Is the genome size different between clusters?
```{r testing genome size differences}
kruskal.test(genome_size ~ cluster, data = metadata_with_cluster)


pairwise.wilcox.test(
  x = metadata_with_cluster$genome_size,
  g = metadata_with_cluster$cluster,
  p.adjust.method = "BH"   # FDR correction
)
```



Plots
```{r summary plots}
ggplot(metadata_with_cluster, aes(x = genome_size, y = GC, col = cluster))+
  geom_point()+
  theme_bw()

ggplot(metadata_with_cluster, aes(x = assembly_type, y = source, col = cluster))+
  geom_point()+
  theme_bw()

ggplot(metadata_with_cluster, aes(x = cluster, y = genome_size, col = cluster))+
  geom_point()+
  theme_bw()
```
```{r GIFT aggregations}
#Aggregate bundle-level GIFTs into the compound level
GIFTs_elements <- to.elements(genome_gifts,GIFT_db)

#Aggregate element-level GIFTs into the function level
GIFTs_functions <- to.functions(GIFTs_elements,GIFT_db)

#Aggregate function-level GIFTs into overall Biosynthesis, Degradation and Structural GIFTs
GIFTs_domains <- to.domains(GIFTs_functions,GIFT_db)

```



```{r comumnity_elem_plot_gut, comment="", message=FALSE, warning=FALSE, fig.height=16, fig.width=14, fig.fullwidth=TRUE}
GIFTs_elements %>%
    as.data.frame() %>%
    rownames_to_column(var="MAG")%>%
    pivot_longer(!MAG,names_to="trait",values_to="gift") %>%
    left_join(metadata_with_cluster, by = join_by(MAG == ID)) %>%
    mutate(functionid = substr(trait, 1, 3)) %>%
    mutate(trait = case_when(
      trait %in% GIFT_db$Code_element ~ GIFT_db$Element[match(trait, GIFT_db$Code_element)],
      TRUE ~ trait
    )) %>%
    mutate(functionid = case_when(
      functionid %in% GIFT_db$Code_function ~ GIFT_db$Function[match(functionid, GIFT_db$Code_function)],
      TRUE ~ functionid
    )) %>%
    mutate(trait=factor(trait,levels=unique(GIFT_db$Element))) %>%
    mutate(functionid=factor(functionid,levels=unique(GIFT_db$Function))) %>%
    ggplot(aes(x=MAG,y=trait,fill=gift)) +
        geom_tile(colour="white", linewidth=0.2)+
        scale_fill_gradientn(colours=rev(c("#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#e6f598", "#abdda4", "#ddf1da")))+
        facet_grid(functionid ~ cluster, scales="free",space="free") +
        theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
              axis.text.y = element_text(size=6),
              strip.text.y = element_text(angle = 0)
              ) +
        labs(y="Traits",x="Samples",fill="GIFT")
```




```{r comumnity_elem_plot_source, comment="", message=FALSE, warning=FALSE, fig.height=16, fig.width=14, fig.fullwidth=TRUE}
GIFTs_elements %>%
    as.data.frame() %>%
    rownames_to_column(var="MAG")%>%
    pivot_longer(!MAG,names_to="trait",values_to="gift") %>%
    left_join(metadata_with_cluster, by = join_by(MAG == ID)) %>%
    mutate(functionid = substr(trait, 1, 3)) %>%
    mutate(trait = case_when(
      trait %in% GIFT_db$Code_element ~ GIFT_db$Element[match(trait, GIFT_db$Code_element)],
      TRUE ~ trait
    )) %>%
    mutate(functionid = case_when(
      functionid %in% GIFT_db$Code_function ~ GIFT_db$Function[match(functionid, GIFT_db$Code_function)],
      TRUE ~ functionid
    )) %>%
    mutate(trait=factor(trait,levels=unique(GIFT_db$Element))) %>%
    mutate(functionid=factor(functionid,levels=unique(GIFT_db$Function))) %>%
    ggplot(aes(x=MAG,y=trait,fill=gift)) +
        geom_tile(colour="white", linewidth=0.2)+
        scale_fill_gradientn(colours=rev(c("#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#e6f598", "#abdda4", "#ddf1da")))+
        facet_grid(functionid ~ source, scales="free",space="free") +
        theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
              axis.text.y = element_text(size=6),
              strip.text.y = element_text(angle = 0)
              ) +
        labs(y="Traits",x="Samples",fill="GIFT")
```





```{r GIFT element plot, fig.height=10, fig.width=8, fig.fullwidth=TRUE}
library(RColorBrewer)
library(reshape2)

GIFTs_elements %>%
  reshape2::melt() %>%
  dplyr::rename(Genome = Var1, Code_element = Var2, GIFT = value) %>%
  inner_join(GIFT_db,by="Code_element") %>%
  ggplot(., aes(x=Code_element, y=Genome, fill=GIFT, group=Code_function))+
    geom_tile()+
    scale_y_discrete(guide = guide_axis(check.overlap = TRUE))+
    scale_x_discrete(guide = guide_axis(check.overlap = TRUE))+
    scale_fill_gradientn(limits = c(0,1), colours=brewer.pal(7, "YlGnBu"))+
    facet_grid(. ~ Code_function, scales = "free", space = "free")+
    theme_grey(base_size=8)+
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),strip.text.x = element_text(angle = 90))
```


```{r checking_which_function_is_d09}
head(GIFT_db)

GIFT_db%>%
  filter(Code_function == "D09")
```


```{r amr_gift_plot, fig.height=10, fig.width=8, fig.fullwidth=TRUE}
library(reshape2)
library(RColorBrewer)

GIFTs_elements %>%
  melt() %>%
  dplyr::rename(Genome = Var1, Code_element = Var2, GIFT = value) %>%
  inner_join(GIFT_db, by = "Code_element") %>%            # Map Code_element -> Element & Function
  filter(str_starts(Code_element, "D09")) %>%            # Only antibiotic degradation
  left_join(metadata_with_cluster, by = join_by(Genome == ID)) %>%
  mutate(cluster = factor(cluster)) %>%
  droplevels() %>%
  arrange(cluster, Genome) %>%
  # Map Code_element IDs to trait names
  mutate(trait = case_when(
    Code_element %in% GIFT_db$Code_element ~ GIFT_db$Element[match(Code_element, GIFT_db$Code_element)],
    TRUE ~ Code_element
  )) %>%
  # Map function IDs for faceting if desired
  mutate(functionid = case_when(
    substr(Code_element,1,3) %in% GIFT_db$Code_function ~ GIFT_db$Function[match(substr(Code_element,1,3), GIFT_db$Code_function)],
    TRUE ~ substr(Code_element,1,3)
  )) %>%
  mutate(trait = factor(trait, levels = unique(GIFT_db$Element))) %>%
  ggplot(aes(x = trait, y = Genome, fill = GIFT)) +
    geom_tile(colour = "white", linewidth = 0.2) +
    scale_y_discrete(guide = guide_axis(check.overlap = TRUE)) +
    scale_x_discrete(guide = guide_axis(check.overlap = TRUE)) +
    scale_fill_gradientn(limits = c(0,1), colours = brewer.pal(7, "YlGnBu")) +
    facet_wrap(~ cluster, scales = "free_y", ncol = 1) +  
    theme_grey(base_size = 8) +
    theme(
      axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
      strip.text.x = element_text(angle = 0)
    ) +
    labs(x = "Trait", fill = "GIFT")
```


### Checking difference in GIFTs

#### Cluster-wise
Element GIFTs different between clusters of pcoa
```{r testing gifts between clusters, message = FALSE, warning = FALSE}
# Get only the GIFT columns
gift_cols <- colnames(GIFTs_elements)[!(colnames(GIFTs_elements) %in% c("MAG_ID","cluster","source"))]

gift_dataframe <- GIFTs_elements %>%
  as.data.frame() %>%            
  rownames_to_column(var = "ID") 

gift_df_meta <- gift_dataframe %>%
  left_join(metadata_with_cluster, by = "ID")


# Kruskal-Wallis for 4 groups
kruskal_results <- sapply(gift_cols, function(g) {
  kruskal.test(as.formula(paste(g, "~ cluster")), data = gift_df_meta)$p.value
})

# Adjust for multiple testing
kruskal_results_adj <- p.adjust(kruskal_results, method = "BH")

# Combine into a table
kruskal_table <- data.frame(
  GIFT = gift_cols,
  p_value = kruskal_results,
  p_adj = kruskal_results_adj
)

kruskal_table %>% filter(p_adj<0.05)
```


```{r testing gifts between clusters pairwise, message = FALSE, warning = FALSE}
pairwise_results <- lapply(gift_cols, function(g) {
  pairwise.wilcox.test(
    x = gift_df_meta[[g]],
    g = gift_df_meta$cluster,
    p.adjust.method = "BH"
  )
})

names(pairwise_results) <- gift_cols

pairwise_sig_table <- lapply(names(pairwise_results), function(g) {
  
  # Extract p-value matrix
  pmat <- pairwise_results[[g]]$p.value
  
  # Convert to long format
  pmat_long <- as.data.frame(as.table(pmat)) %>%
    filter(!is.na(Freq)) %>%       # remove NA (diagonal / upper triangle)
    dplyr::rename(group1 = Var1, group2 = Var2, p_adj = Freq) %>%
    filter(p_adj < 0.05) %>%      # keep only significant comparisons
    mutate(GIFT = g)
  
  return(pmat_long)
})

# Combine all GIFTs into one table
pairwise_sig_table <- bind_rows(pairwise_sig_table) %>%
  dplyr::select(GIFT, group1, group2, p_adj)

pairwise_sig_table 

```

```{r sig_cluster_gift_plot, message = FALSE, warning = FALSE, fig.height=10, fig.width=8, fig.fullwidth=TRUE}
library(reshape2)
library(RColorBrewer)

GIFTs_elements %>%
  melt() %>%
  dplyr::rename(Genome = Var1, Code_element = Var2, GIFT = value) %>%
  inner_join(GIFT_db, by = "Code_element") %>%
  # Only keep significant traits
  filter(Code_element %in% pairwise_sig_table$GIFT) %>%
  left_join(metadata_with_cluster, by = join_by(Genome == ID)) %>%
  distinct(Genome, Code_element, .keep_all = TRUE) %>%
  mutate(cluster = factor(cluster)) %>%
  droplevels() %>%
  arrange(cluster, Genome) %>%
  mutate(trait = Element) %>%          # human-readable trait
  ggplot(aes(x = trait, y = Genome, fill = GIFT)) +
    geom_tile(colour = "white", linewidth = 0.2) +
    scale_y_discrete(guide = guide_axis(check.overlap = TRUE)) +
    scale_x_discrete(guide = guide_axis(check.overlap = TRUE)) +
    scale_fill_gradientn(limits = c(0,1), colours = RColorBrewer::brewer.pal(7, "YlGnBu")) +
    facet_wrap(~ cluster, scales = "free_y", ncol = 1) +
    theme_grey(base_size = 8) +
    theme(
      axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
      strip.text.x = element_text(angle = 0)
    ) +
    labs(x = "Trait", fill = "GIFT")

```




#### Source-wise
GIFTs that are different between EHI and GTDB
```{r testing gifts between sources pairwise, message = FALSE, warning = FALSE}
wilcox_results <- sapply(gift_cols, function(g) {
  wilcox.test(as.formula(paste(g, "~ source")), data = gift_df_meta)$p.value
})

wilcox_results_adj <- p.adjust(wilcox_results, method = "BH")

data.frame(
  GIFT = gift_cols,
  p_value = wilcox_results,
  p_adj = wilcox_results_adj
)

effect_size <- sapply(gift_cols, function(g) {
  median(gift_df_meta[[g]][gift_df_meta$source=="GTDB"]) -
    median(gift_df_meta[[g]][gift_df_meta$source=="EHI"])
})

wilcox_res_source <- data.frame(
  GIFT = gift_cols,
  p_value = wilcox_results,
  p_adj = wilcox_results_adj,
  effect = effect_size
)


wilcox_res_source %>% filter(p_adj<0.05)

```
```{r checking code element B0215}
GIFT_db%>%
  filter(Code_element == "B0215")
```


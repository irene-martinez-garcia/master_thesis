# Antibiotic resistance analysis

```{r load_data_mag_amr, message=FALSE, warning=FALSE, echo=FALSE}
load("data/data.Rdata")
```


### Nº of MAGs with AMRs
```{r mag counts per AMR}
# AMR presence/absence
amr_presence <- genome_annotations %>%
  filter(mag_id != "GCA_015060925.1") %>%   # remove weird MAG
  filter(resistance_type == "AMR") %>%
  dplyr::select(mag_id, resistance_target) %>%
  distinct() 

#Add the source info
amr_with_source <- amr_presence %>%
  left_join(
    genome_metadata %>% dplyr::select(ID, source),
    by = c("mag_id" = "ID")
  )

# Count how many MAGs in each AMR
amr_mag_counts <- amr_with_source %>%
  group_by(source, resistance_target) %>%
  summarise(
    n_mags = n(),
    .groups = "drop"
  )

#Count total MAGs per source (except the outlier)
total_mags_per_source <- genome_metadata %>%
  filter(ID != "GCA_015060925.1") %>%
  group_by(source) %>%
  summarise(
    total_mags = n_distinct(ID),
    .groups = "drop"
  )

#Calculate proportions of MAGs from each source in each AMR
amr_mag_proportions <- amr_mag_counts %>%
  left_join(total_mags_per_source, by = "source") %>%
  mutate(
    proportion = n_mags / total_mags,
    absent = total_mags - n_mags
  )

```

#### Statistical testing of MAG proportions
```{r statistical testing mag proportions amr}
fisher_results <- amr_mag_proportions %>%
  dplyr::select(resistance_target, source, n_mags, absent) %>%
  pivot_wider(
    names_from = source,
    values_from = c(n_mags, absent),
    values_fill = 0
  ) %>%
  rowwise() %>%
  mutate(
    p_value = fisher.test(
      matrix(
        c(n_mags_EHI,  absent_EHI,
          n_mags_GTDB, absent_GTDB),
        nrow = 2,
        byrow = TRUE
      )
    )$p.value
  ) %>%
  ungroup() %>%
  mutate(p_adj = p.adjust(p_value, method = "BH"))

fisher_results <- fisher_results %>%
  mutate(
    prop_EHI  = n_mags_EHI  / (n_mags_EHI  + absent_EHI),
    prop_GTDB = n_mags_GTDB / (n_mags_GTDB + absent_GTDB),
    diff_prop = prop_GTDB - prop_EHI
  )
```

```{r filtering padj amr}
fisher_results%>% filter(p_adj < 0.05) 
```


## Building an AMR abundance table

```{r amr table}
# select the AMR annotations
amr_abundance <- genome_annotations %>%
  filter(resistance_type == "AMR") %>%
  group_by(mag_id, resistance_target) %>%
  summarise(count = n(), .groups="drop") %>%
  tidyr::pivot_wider(
    names_from = resistance_target,
    values_from = count,
    values_fill = 0
  )

```

```{r join with metadata}
amr_cluster <- amr_abundance %>%
  dplyr::full_join(metadata_with_cluster, by= join_by(mag_id == ID))
```

```{r investigation macrolide and beta_lactam}
amr_cluster %>%
  dplyr::select("BETA-LACTAM", "MACROLIDE", mag_id, cluster) %>%
  group_by( cluster) %>%
  summarise(mean_beta_lactam = mean(`BETA-LACTAM`, na.rm = TRUE),
            mean_macrolide = mean(MACROLIDE, na.rm = TRUE))
```


```{r AMR abundance heatmap,  fig.height=14, fig.width=12, fig.fullwidth=TRUE}
amr_matrix <- amr_abundance %>%
  column_to_rownames("mag_id") %>%
  as.matrix()

# Abundance heatmap
min_val <- min(amr_matrix, na.rm = TRUE)
max_val <- max(amr_matrix, na.rm = TRUE)

colors <- viridis(100, option = "viridis")

breaks <- seq(min_val, max_val, length.out = 101)   

pheatmap( amr_matrix,
  color = colors,
  cluster_rows = FALSE,
  cluster_cols = TRUE,
  fontsize = 9,
  border_color = NA
)


#Scaled abundance heatmap
amr_scaled <- scale(amr_matrix, center = TRUE, scale = TRUE)

min_val <- min(amr_scaled, na.rm = TRUE)
max_val <- max(amr_scaled, na.rm = TRUE)

colors <- viridis(100, option = "viridis")

breaks <- seq(min_val, max_val, length.out = 101)   



pheatmap( amr_scaled,
  color = colors,
  cluster_rows = FALSE,
  cluster_cols = TRUE,
  fontsize = 9,
  border_color = NA
)
```



```{r AMR presence heatmap_1,  fig.height=14, fig.width=12, fig.fullwidth=TRUE}
amr_presence <- amr_abundance %>%
  column_to_rownames("mag_id") %>%   
  mutate(across(everything(), ~ ifelse(. > 0, 1, 0)))%>%
  as.matrix()


pheatmap(
  amr_presence,
  cluster_rows = TRUE,
  cluster_cols = TRUE,
  color = c("white", "darkblue"),     # white = absent, black = present
  legend_breaks = c(0,1),
  legend_labels = c("Absent", "Present"),
  border_color = NA
)

```
```{r heatmap presence absence by ehi vs gtdb,  fig.height=14, fig.width=12, fig.fullwidth=TRUE}
pheatmap(
  amr_presence,
  cluster_rows = FALSE,
  cluster_cols = TRUE,
  color = c("white", "darkblue"),     # white = absent, black = present
  legend_breaks = c(0,1),
  legend_labels = c("Absent", "Present"),
  border_color = NA
)
```

## PERMANOVA

```{r permanova_amr}
amr_counts <- genome_annotations %>%
  filter(mag_id != "GCA_015060925.1") %>%
  filter(resistance_type == "AMR") %>%
  dplyr::count(mag_id, resistance_target) %>%            
  pivot_wider(names_from = resistance_target, values_from = n, values_fill = 0) %>%
  filter(rowSums(dplyr::select(., -mag_id)) > 0) # Removes MAGs with no AMR genes found

# Fixed normalization
amr_rel <- amr_counts %>%
  column_to_rownames("mag_id")
amr_rel <- amr_rel / rowSums(amr_rel)  # Each row sums to 1

# Remove zero variance
amr_rel_nz <- amr_rel[, apply(amr_rel, 2, sd) > 0]

# Distance matrix from normalized data
amr_dist <- vegdist(amr_rel_nz, method = "bray")  # or euclidean

# Add metadata
amr_rel_nz_meta <- amr_rel_nz %>%
  rownames_to_column("ID") %>%
  left_join(genome_metadata, by = "ID")

#Beta dispersion test
dispersion <- betadisper(amr_dist, amr_rel_nz_meta$source)
anova(dispersion) 


# PERMANOVA test
permanova_result <- adonis2(amr_dist ~ source, 
                            data = amr_rel_nz_meta, 
                            permutations = 999)
print(permanova_result)

# PERMANOVA test accounting for genome size
adonis2(
  amr_dist ~ genome_size + source,
  data = amr_rel_nz_meta,
  permutations = 999,
  by = "margin"
)
```

## PCoA
```{r pcoa amr}
pcoa_res <- cmdscale(amr_dist, k = 2, eig = TRUE)

# Calculate variance explained from PCoA eigenvalues
variance_explained <- pcoa_res$eig / sum(pcoa_res$eig)

pcoa_df <- data.frame(
  PC1 = pcoa_res$points[,1], 
  PC2 = pcoa_res$points[,2], 
  ID = rownames(amr_rel_nz)
) %>%
  left_join(metadata_with_cluster, by = "ID")


ggplot(pcoa_df, aes(PC1, PC2, color = source)) +
  geom_point(size = 2) +
  scale_color_manual(values = source_colors) +
  theme_minimal() +
  labs(
    title = "PCoA of AMR annotations across MAGs",
    x = paste0("PCoA1 (", round(variance_explained[1] * 100, 1), "%)"),
    y = paste0("PCoA2 (", round(variance_explained[2] * 100, 1), "%)")
  )

ggplot(pcoa_df, aes(PC1, PC2, color = cluster)) +
  geom_point(size = 2) +
  theme_minimal() +
  labs(
    title = "PCoA of AMR annotations across MAGs colored by GIFT clustering",
    x = paste0("PCoA1 (", round(variance_explained[1] * 100, 1), "%)"),
    y = paste0("PCoA2 (", round(variance_explained[2] * 100, 1), "%)")
  )

ggplot(pcoa_df, aes(PC1, PC2, color = genome_size)) +
  geom_point(size = 2) +
  theme_minimal() +
  labs(
    title = "PCoA of AMR annotations across MAGs",
    x = paste0("PCoA1 (", round(variance_explained[1] * 100, 1), "%)"),
    y = paste0("PCoA2 (", round(variance_explained[2] * 100, 1), "%)")
  )



```
```{r how many mags have amr genes}
cat("MAGs with AMR genes:", nrow(amr_rel_nz), "\n")
cat("Total AMR genes detected:", ncol(amr_rel_nz), "\n")
```

## DESEq2
```{r deseq_amr}
library(DESeq2)

# Prepare the count matrix (AMR_Targets as rows, MAGs as columns)
# Ensure only integer columns are kept
counts_mtx <- amr_counts %>%
  column_to_rownames("mag_id") %>%
  t() 

# Prepare metadata (Must match column names of counts_mtx)
metadata <- genome_metadata %>%
  filter(ID %in% colnames(counts_mtx)) %>%
  column_to_rownames("ID")

# Ensure order matches exactly
metadata <- metadata[colnames(counts_mtx), , drop = FALSE]

#Create DESeq2 object
dds <- DESeqDataSetFromMatrix(countData = counts_mtx,
                              colData = metadata,
                              design = ~ source)

#Run initial steps manually instead of using DESeq()
dds <- estimateSizeFactors(dds)
dds <- estimateDispersionsGeneEst(dds)
dispersions(dds) <- mcols(dds)$dispGeneEst # Force the use of gene-wise estimates

# Run the Wald test
dds <- nbinomWaldTest(dds)

# save results (Wildlife vs Human)
res <- results(dds, contrast=c("source", "EHI", "GTDB"), alpha=0.05)


summary(res)

```
```{r save res amr}
res_df <-res %>% as.data.frame %>% rownames_to_column("AMR_Target") %>% as_tibble

res_df <- filter(res_df, padj<0.05)
```


## Wilcoxon
```{r wilcoxon_amr}
wilcox_amr <- amr_rel_nz_meta %>%
  pivot_longer(
    cols = where(is.numeric),
    names_to = "AMR_Target", 
    values_to = "rel_abundance"
  ) %>%
  group_by(AMR_Target) %>%
  do(broom::tidy(wilcox.test(rel_abundance ~ source, data = .))) %>%
  ungroup()

# Adjust p-values
wilcox_amr_results <- wilcox_amr %>%
  mutate(p.adj = p.adjust(p.value, method = "fdr")) %>%
  filter(p.adj < 0.05) %>%
  arrange(p.adj)

wilcox_amr_results
```

```{r checking frequency, eval = FALSE}
#amr frequency
amr_frequency <- amr_rel_nz_meta %>%
  dplyr::select(source, all_of(wilcox_amr_results$AMR_Target)) %>%
  pivot_longer(-source, names_to = "AMR_Target", values_to = "val") %>%
  group_by(AMR_Target, source) %>%
  summarise(percent_presence = mean(val > 0) * 100, .groups = 'drop')


ggplot(amr_frequency, aes(x = AMR_Target, y = percent_presence, fill = source)) +
  geom_bar(stat = "identity", position = "dodge") +
  coord_flip() 
  scale_fill_manual(values = source_colors) +
  theme_minimal() +
  labs(title = "Prevalence of AMR Genes: Human vs Wildlife",
       y = "% of MAGs carrying the gene", x = "")
```

```{r plot all_amr}
# Filter data to only include the common KOs
common_AMR_Target <- (wilcox_amr_results$AMR_Target)

plot_data <- amr_rel_nz_meta %>%
  dplyr::select(ID, source, all_of(common_AMR_Target)) %>%
  pivot_longer(cols = all_of(common_AMR_Target), 
               names_to = "AMR_Target", 
               values_to = "Relative_Abundance")


ggplot(plot_data, aes(x = source, y = Relative_Abundance, fill = source)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(width = 0.2, alpha = 0.4, size = 1) +
  facet_wrap(~AMR_Target, scales = "free_y", ncol = 5) + # 'free_y' is important as abundance scales vary
  scale_fill_manual(values = source_colors) +
  theme_minimal() +
  theme(strip.text = element_text(face = "bold"),
        legend.position = "bottom") +
  labs(title = "Relative Abundance of Consensus Significant AMR Targets",
       x = "Host Source",
       y = "Relative Abundance")
```


```{r testing prevalence with fischer test}
amr_binary <- amr_counts %>%
  left_join(genome_metadata %>% dplyr::select(ID, source), by = c("mag_id" = "ID")) %>%
  # Convert all numeric columns to 0 or 1
  mutate(across(where(is.numeric), ~ ifelse(.x > 0, 1, 0)))

#Function to run Fischer test for each gene
run_fisher <- function(gene_name, df) {
  tab <- table(df$source, df[[gene_name]])
  
  # Only run if the table is actually 2x2 
  if(ncol(tab) == 2) {
    test <- fisher.test(tab)
    return(tidy(test) %>% mutate(AMR_Target = gene_name))
  } else {
    return(NULL)
  }
}

# Apply the function to all AMR columns
amr_names <- colnames(amr_counts)[-1] # everything except mag_id

fisher_results <- map_df(amr_names, ~ run_fisher(.x, amr_binary))

# Adjust for multiple testing (FDR)
fisher_results <- fisher_results %>%
  mutate(p.adj = p.adjust(p.value, method = "fdr")) %>%
  #filter(p.adj < 0.05) %>%
  arrange(p.adj)

print(fisher_results)
```
```{r aldex2 amr}
library(ALDEx2)
# Prepare count matrix for ALDEx2 (raw counts, not normalized)
amr_counts_aldex <- amr_counts %>%
  column_to_rownames("mag_id")

# Transpose for ALDEx2 (features as rows, samples as columns)
amr_counts_t <- t(amr_counts_aldex)

# Remove features with zero counts across all samples
amr_counts_t <- amr_counts_t[rowSums(amr_counts_t) > 0, ]

# Create conditions vector matching column order
conditions <- genome_metadata %>%
  filter(ID %in% colnames(amr_counts_t)) %>%
  arrange(match(ID, colnames(amr_counts_t))) %>%
  pull(source)

# Run ALDEx2
set.seed(123)
aldex_amr <- aldex.clr(amr_counts_t, conditions, mc.samples = 128, denom = "all")
aldex_amr_test <- aldex.ttest(aldex_amr, paired.test = FALSE)
aldex_amr_effect <- aldex.effect(aldex_amr, CI = TRUE)

# Combine results
aldex_amr_results <- data.frame(aldex_amr_test, aldex_amr_effect) %>%
  rownames_to_column("AMR_gene") %>%
  arrange(wi.eBH)

# Significant AMR genes (FDR < 0.05)
significant_amr <- aldex_amr_results %>%
  filter(wi.eBH < 0.05) %>%
  mutate(enriched_in = ifelse(effect > 0, 
                               levels(factor(conditions))[2],
                               levels(factor(conditions))[1]))

cat("\nSignificant AMR genes:", nrow(significant_amr), "\n")
print(significant_amr)

# Visualization
ggplot(aldex_amr_results, aes(x = effect, y = -log10(wi.eBH))) +
  geom_point(aes(color = wi.eBH < 0.05), alpha = 0.6) +
  scale_color_manual(values = c("grey", "red")) +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed") +
  theme_minimal() +
  labs(
    title = "ALDEx2 results for AMR genes",
    x = "Effect size",
    y = "-log10(BH-adjusted p-value)",
    color = "Significant"
  )
```




# Virulence factors analysis


### Nº of MAGs with VFs
```{r mag counts per VF}
# AMR presence/absence
vf_presence <- genome_annotations %>%
  filter(mag_id != "GCA_015060925.1") %>%   # remove weird MAG
  filter(!is.na(vf)) %>%
  dplyr::select(mag_id, vf) %>%
  distinct() 

#Add the source info
vf_with_source <- vf_presence %>%
  left_join(
    genome_metadata %>% dplyr::select(ID, source),
    by = c("mag_id" = "ID")
  )

# Count how many MAGs in each vf
vf_mag_counts <- vf_with_source %>%
  group_by(source, vf) %>%
  summarise(
    n_mags = n(),
    .groups = "drop"
  )

#Count total MAGs per source (except the outlier)
total_mags_per_source <- genome_metadata %>%
  filter(ID != "GCA_015060925.1") %>%
  group_by(source) %>%
  summarise(
    total_mags = n_distinct(ID),
    .groups = "drop"
  )

#Calculate proportions of MAGs from each source in each vf
vf_mag_proportions <- vf_mag_counts %>%
  left_join(total_mags_per_source, by = "source") %>%
  mutate(
    proportion = n_mags / total_mags,
    absent = total_mags - n_mags
  )

```

#### Statistical testing of MAG proportions
```{r statistical testing mag proportions vf}
fisher_results <- vf_mag_proportions %>%
  dplyr::select(vf, source, n_mags, absent) %>%
  pivot_wider(
    names_from = source,
    values_from = c(n_mags, absent),
    values_fill = 0
  ) %>%
  rowwise() %>%
  mutate(
    p_value = fisher.test(
      matrix(
        c(n_mags_EHI,  absent_EHI,
          n_mags_GTDB, absent_GTDB),
        nrow = 2,
        byrow = TRUE
      )
    )$p.value
  ) %>%
  ungroup() %>%
  mutate(p_adj = p.adjust(p_value, method = "BH"))

fisher_results <- fisher_results %>%
  mutate(
    prop_EHI  = n_mags_EHI  / (n_mags_EHI  + absent_EHI),
    prop_GTDB = n_mags_GTDB / (n_mags_GTDB + absent_GTDB),
    diff_prop = prop_GTDB - prop_EHI
  )
```

```{r filtering padj vf}
fisher_results%>% filter(p_adj < 0.05) 
```




## Building an virulence factor abundance table

```{r select virulence factor data from gene annotations}
vf_data <- genome_annotations %>%
  dplyr::select(mag_id, vf, vf_type) 
```


```{r vf table}
vf_abundance <- genome_annotations %>%
  dplyr::select(mag_id, vf) %>%
  group_by(mag_id, vf) %>%
  summarise(count = n(), .groups="drop") %>%
  tidyr::pivot_wider(
    names_from = vf,
    values_from = count,
    values_fill = 0
  )

dim(vf_abundance)
```

```{r vf join with metadata}
vf_cluster <- vf_abundance %>%
  dplyr::full_join(genome_metadata, by= join_by(mag_id == ID))
```



```{r vf heatmaps}
# make into a matrix
vf_matrix <- vf_abundance %>%
  column_to_rownames("mag_id") %>%
  as.matrix()

# Unscaled abundance heatmap
pheatmap(vf_matrix,
  color = viridis(100, option = "viridis"),
  cluster_rows = FALSE,
  cluster_cols = TRUE,
  fontsize = 9,
  border_color = NA
)

# For scaled heatmap -> remove zero variance columns 
col_vars <- apply(vf_matrix, 2, var, na.rm = TRUE)
vf_matrix_filtered <- vf_matrix[, col_vars > 0 & !is.na(col_vars)]

# Scale the filtered matrix
vf_scaled <- scale(vf_matrix_filtered, center = TRUE, scale = TRUE)

# Check for any remaining Inf/NaN values
if(any(!is.finite(vf_scaled))) {
  vf_scaled[!is.finite(vf_scaled)] <- 0  # Replace Inf/NaN with 0
}

# Scaled heatmap
pheatmap(vf_scaled,
  color = viridis(100, option = "viridis"),
  cluster_rows = FALSE,
  cluster_cols = TRUE,
  fontsize = 5,
  border_color = NA
)
```
## Virulence presence/absence heatmap
```{r VF presence heatmap,  fig.height=14, fig.width=12, fig.fullwidth=TRUE}
vf_presence <- vf_abundance %>%
  column_to_rownames("mag_id") %>%   
  mutate(across(everything(), ~ ifelse(. > 0, 1, 0)))%>%
  as.matrix()


pheatmap(
  vf_presence,
  cluster_rows = FALSE,
  cluster_cols = TRUE,
  color = c("white", "darkblue"),     
  legend_breaks = c(0,1),
  legend_labels = c("Absent", "Present"),
  border_color = NA
)

```



```{r permanova_vf}
vf_counts <- genome_annotations %>%
  filter(mag_id != "GCA_015060925.1") %>%
  filter(!is.na(vf)) %>%
  dplyr::count(mag_id, vf) %>%            
  pivot_wider(names_from = vf, values_from = n, values_fill = 0) %>%
  filter(rowSums(dplyr::select(., -mag_id)) > 0) # Removes MAGs with no vf genes found

# Fixed normalization
vf_rel <- vf_counts %>%
  column_to_rownames("mag_id")
vf_rel <- vf_rel / rowSums(vf_rel)  # Each row sums to 1

# Remove zero variance
vf_rel_nz <- vf_rel[, apply(vf_rel, 2, sd) > 0]

# Distance matrix from normalized data
vf_dist <- vegdist(vf_rel_nz, method = "bray")  # or euclidean

# Add metadata
vf_rel_nz_meta <- vf_rel_nz %>%
  rownames_to_column("ID") %>%
  left_join(genome_metadata, by = "ID")

#Beta dispersion test
dispersion <- betadisper(vf_dist, vf_rel_nz_meta$source)
anova(dispersion) 


# PERMANOVA test
permanova_result <- adonis2(vf_dist ~ source, 
                            data = vf_rel_nz_meta, 
                            permutations = 999)
print(permanova_result)

# PERMANOVA test accounting for genome size
adonis2(
  vf_dist ~ genome_size + source,
  data = vf_rel_nz_meta,
  permutations = 999,
  by = "margin"
)
```


```{r pcoa vf}
pcoa_res <- cmdscale(vf_dist, k = 2, eig = TRUE)

# Calculate variance explained from PCoA eigenvalues
variance_explained <- pcoa_res$eig / sum(pcoa_res$eig)

pcoa_df <- data.frame(
  PC1 = pcoa_res$points[,1], 
  PC2 = pcoa_res$points[,2], 
  ID = rownames(vf_rel_nz)
) %>%
  left_join(metadata_with_cluster, by = "ID")


ggplot(pcoa_df, aes(PC1, PC2, color = source)) +
  scale_color_manual(values = source_colors) +
  geom_point(size = 2) +
  theme_minimal() +
  labs(
    title = "PCoA of VF annotations across MAGs",
    x = paste0("PCoA1 (", round(variance_explained[1] * 100, 1), "%)"),
    y = paste0("PCoA2 (", round(variance_explained[2] * 100, 1), "%)")
  )

ggplot(pcoa_df, aes(PC1, PC2, color = genome_size)) +
  geom_point(size = 2) +
  theme_minimal() +
  labs(
    title = "PCoA of VF annotations across MAGs",
    x = paste0("PCoA1 (", round(variance_explained[1] * 100, 1), "%)"),
    y = paste0("PCoA2 (", round(variance_explained[2] * 100, 1), "%)")
  )

ggplot(pcoa_df, aes(PC1, PC2, color = cluster)) +
  geom_point(size = 2) +
  theme_minimal() +
  labs(
    title = "PCoA of VF annotations across MAGs colored by GIFT cluster",
    x = paste0("PCoA1 (", round(variance_explained[1] * 100, 1), "%)"),
    y = paste0("PCoA2 (", round(variance_explained[2] * 100, 1), "%)")
  )

ggplot(pcoa_df, aes(PC1, PC2, color = completeness)) +
  geom_point(size = 2) +
  theme_minimal() +
  labs(
    title = "PCoA of VF annotations across MAGs colored by GIFT cluster",
    x = paste0("PCoA1 (", round(variance_explained[1] * 100, 1), "%)"),
    y = paste0("PCoA2 (", round(variance_explained[2] * 100, 1), "%)")
  )

```


```{r aldex2 vf}
# Prepare count matrix for ALDEx2 (raw counts, not normalized)
vf_counts_aldex <- vf_counts %>%
  column_to_rownames("mag_id")

# Transpose for ALDEx2 (features as rows, samples as columns)
vf_counts_t <- t(vf_counts_aldex)

# Remove features with zero counts across all samples
vf_counts_t <- vf_counts_t[rowSums(vf_counts_t) > 0, ]

# Create conditions vector matching column order
conditions <- genome_metadata %>%
  filter(ID %in% colnames(vf_counts_t)) %>%
  arrange(match(ID, colnames(vf_counts_t))) %>%
  pull(source)

# Run ALDEx2
set.seed(123)
aldex_vf <- aldex.clr(vf_counts_t, conditions, mc.samples = 128, denom = "all")
aldex_vf_test <- aldex.ttest(aldex_vf, paired.test = FALSE)
aldex_vf_effect <- aldex.effect(aldex_vf, CI = TRUE)

# Combine results
aldex_vf_results <- data.frame(aldex_vf_test, aldex_vf_effect) %>%
  rownames_to_column("vf_gene") %>%
  arrange(wi.eBH)

# Significant vf genes (FDR < 0.05)
significant_vf <- aldex_vf_results %>%
  filter(wi.eBH < 0.05) %>%
  mutate(enriched_in = ifelse(effect > 0, 
                               levels(factor(conditions))[2],
                               levels(factor(conditions))[1]))

cat("\nSignificant vf genes:", nrow(significant_vf), "\n")
print(significant_vf)

# Visualization
ggplot(aldex_vf_results, aes(x = effect, y = -log10(wi.eBH))) +
  geom_point(aes(color = wi.eBH < 0.05), alpha = 0.6) +
  scale_color_manual(values = c("grey", "red")) +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed") +
  theme_minimal() +
  labs(
    title = "ALDEx2 results for vf genes",
    x = "Effect size",
    y = "-log10(BH-adjusted p-value)",
    color = "Significant"
  )
```
# CAZY

```{r cazy annotations}
cazy_genes <- genome_annotations %>%
  filter(!is.na(cazy)) %>%
  nrow()

cazy_genes
```
```{r cazy abundance heatmap,  fig.height=14, fig.width=12, fig.fullwidth=TRUE}
cazy_abundance <- genome_annotations %>%
  filter(!is.na(cazy)) %>%
  group_by(mag_id, cazy) %>%
  summarise(count = n(), .groups="drop") %>%
  tidyr::pivot_wider(
    names_from = cazy,
    values_from = count,
    values_fill = 0
  )

cazy_matrix <- cazy_abundance %>%
  column_to_rownames("mag_id") %>%
  as.matrix()

# Abundance heatmap
min_val <- min(cazy_matrix, na.rm = TRUE)
max_val <- max(cazy_matrix, na.rm = TRUE)

colors <- viridis(100, option = "viridis")

breaks <- seq(min_val, max_val, length.out = 101)   

pheatmap( cazy_matrix,
  color = colors,
  cluster_rows = FALSE,
  cluster_cols = TRUE,
  fontsize = 9,
  border_color = NA
)


#Scaled abundance heatmap
cazy_scaled <- scale(cazy_matrix, center = TRUE, scale = TRUE)

min_val <- min(cazy_scaled, na.rm = TRUE)
max_val <- max(cazy_scaled, na.rm = TRUE)

colors <- viridis(100, option = "viridis")

breaks <- seq(min_val, max_val, length.out = 101)   



```

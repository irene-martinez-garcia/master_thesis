[["index.html", "AlberdiLab | Master Thesis MSc project Chapter 1 Introduction 1.1 Prepare the R environment", " AlberdiLab | Master Thesis MSc project Irene Martínez, M Thomas P Gilbert, Antton Alberdi1 Last update: 2026-02-23 Chapter 1 Introduction This webbook contains all the code used for data analysis for the comparative metagenomics analysis of gut microbiome bacterial species in several vertebrates. 1.1 Prepare the R environment 1.1.1 Environment To reproduce all the analyses locally, clone this repository in your computer using: RStudio &gt; New Project &gt; Version Control &gt; Git And indicating the following git repository: https://github.com/irene-martinez-garcia/master_thesis.git Once the R project has been created, follow the instructions and code chunks shown in this webbook. 1.1.2 Libraries The following R packages are required for the data analysis. # Base library(R.utils) library(knitr) library(tidyverse) #library(devtools) library(tinytable) library(rairtable) library(janitor) library(broom) # For tree handling library(ape) library(phyloseq) library(phytools) # For plotting library(ggplot2) library(ggrepel) library(ggpubr) library(ggnewscale) library(gridExtra) library(ggtreeExtra) library(ggtree) library(ggh4x) library(UpSetR) library(viridis) library(RColorBrewer) library(countrycode) # For statistics library(spaa) library(vegan) library(Rtsne) library(geiger) library(distillR) library(ANCOMBC) library(lme4) library(nlme) library(pairwiseAdonis) library(emmeans) library(pheatmap) library(rstatix) library(uwot) University of Copenhagen, antton.alberdi@sund.ku.dk↩︎ "],["data-preparation.html", "Chapter 2 Data preparation 2.1 Searching for the MAGs 2.2 Downloading the MAGs and generating data", " Chapter 2 Data preparation 2.1 Searching for the MAGs Choose the MAGs For this project, the following bacterial species were selected: Lactococcus lactis, Hafnia paralvei, Enterococcus faecalis, Bacteroides uniformis, Phocaeicola vulgatus, Parabacteroides goldsteinii, Citrobacter braaki, Akkermansia municiphila, Enterococcus hirae and Bacteroides fragilis. EHI MAGs: In the EHI database, select the MAGs with &gt; 90% completeness and &lt; 2.5 contamination for each of the species. GTDB MAGs: (“NCBI Taxonomy” CONTAINS “Lactococcus lactis” AND “CheckM2 Completeness” &gt; “90” AND “CheckM Contamination” &lt; “2.5” AND (“Isolation Source” CONTAINS “feces” OR “Isolation Source” CONTAINS “excrement” OR “Isolation Source” CONTAINS “metagenome” OR “Isolation Source” CONTAINS “microbiome” OR “Isolation Source” CONTAINS “gut” OR “Isolation Source” CONTAINS “faeces” OR “Isolation Source” CONTAINS “fecal”) AND “Isolation Source” IS NOT “N/A”) NCBI MAGs: Refer to 03_downloading_mags.Rmd 2.2 Downloading the MAGs and generating data Download genome indices and metadata Download the EHI_MAG index for each species (in /data/mags_metadata folder) and the curl file and search metadata tsv from the GTDB and place in each species directory in Mjolnir. 2.5) Extract genome metadata - Use the GTDB search tsv to run this script to obtain more metadata. snakemake -s /maps/projects/alberdilab/people/pjq449/comparative_metagenomics/snakefiles/gtdb_metadata_pipeline.smk -j 1 --use-conda --rerun-incomplete METADATA FILES: -The EHI metadata files : data/mags_metadata/lactococcus_lactis_metadata.tsv -The GTDB metadata files: data/mags_metadata/lactococcus_lactis_gtdb_final_metadata.tsv -The NCBI metadata files: lactococcus_lactis_ncbi_metadata.rds Create the master index Run the create_index.R script to create an index of all the MAGs and the download paths (needs a list of species as input and right now it is hardcoded in the script) conda activate r_env Rscript scripts/create_index.R Run the downloading_mags.smk to download all the genomes module load snakemake #testing snakemake -s snakefiles/downloading_and_unzipping.smk \\ --executor slurm \\ --jobs 50 \\ --rerun-incomplete \\ --keep-going \\ --rerun-triggers mtime Download the MAGs from the NCBI ### DOWNLOAD THE MAGS - add this to download and unzip mags?? conda activate drakkar_env #Run this inside the mags folder datasets download genome accession --inputfile ../phocaeicola_vulgatus_ncbi_selected_accessions.txt --include genome --filename phocaeicola_vulgatus_ncbi_selected_genomes.zip #then unzip zip=&quot;phocaeicola_vulgatus_ncbi_selected_genomes.zip&quot; mkdir -p unzipped unzip -Z1 &quot;$zip&quot; | grep &#39;\\.fna$&#39; | while read -r f; do acc=$(basename &quot;$(dirname &quot;$f&quot;)&quot;) echo &quot;Extracting $acc&quot; unzip -p &quot;$zip&quot; &quot;$f&quot; &gt; &quot;unzipped/${acc}.fna&quot; done Run drep sbatch scripts/drep_compare.slurm Remove the MAGs that are &lt;95% ANI (not the same species) python3 scripts/filter_by_cdb.py data data/clusters_to_drop.tsv 6.2) Re-run drep without removed MAGs sbatch --export=SPECIES=&quot;$SPECIES&quot; scripts/rerun_drep_removed.sh Make a screen session for each species. screen -S parabacteroides_distasonis Run drakkar annotating_function.smk to re-annotate all the MAGs: drakkar annotating -b /maps/projects/alberdilab/people/pjq449/comparative_metagenomics/data/phocaeicola_vulgatus/mags/unzipped -o /maps/projects/alberdilab/people/pjq449/comparative_metagenomics/data/phocaeicola_vulgatus --env_path /projects/alberdilab/data/environments/drakkar --annotation-type function 7.1) Run contig to genome mapping bash /maps/projects/alberdilab/people/pjq449/comparative_metagenomics/scripts/build_contig_to_mag_maps_all.sh # though in the end i just ran one in terminal directly Pangenome analysis with ppanggolin snakemake --snakefile Snakefile.pangolin \\ --configfile snakefiles/pangolin_config.yaml \\ --use-conda \\ -j 40 "],["ehi-mags-exploration.html", "Chapter 3 EHI MAGs exploration", " Chapter 3 EHI MAGs exploration 3.0.1 EHI MAGs load(&quot;data/data.Rdata&quot;) library(tidyverse) ehi_mags &lt;- read_csv(&quot;data/ehi_metadata_location.csv&quot;) Rows: 8857 Columns: 54 ── Column specification ──────────────────────────────────────────────────────────────────────────────────────── Delimiter: &quot;,&quot; chr (38): ID, mag_name, link_to_assembly, AB_batch, eha_number, GTDB_version, GTDB_release, domain, phylum, ... dbl (15): fastani_ani, closest_placement_ani, closest_placement_af, completeness, contamination, size, N50, ... lgl (1): annotated ℹ Use `spec()` to retrieve the full column specification for this data. ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. colnames(ehi_mags) [1] &quot;ID&quot; &quot;mag_name&quot; &quot;link_to_assembly&quot; [4] &quot;AB_batch&quot; &quot;eha_number&quot; &quot;GTDB_version&quot; [7] &quot;GTDB_release&quot; &quot;domain&quot; &quot;phylum&quot; [10] &quot;class&quot; &quot;order&quot; &quot;family&quot; [13] &quot;genus&quot; &quot;species&quot; &quot;fastani_ani&quot; [16] &quot;closest_placement_ani&quot; &quot;closest_placement_af&quot; &quot;completeness&quot; [19] &quot;contamination&quot; &quot;size&quot; &quot;GC&quot; [22] &quot;N50&quot; &quot;coding_density&quot; &quot;contigs&quot; [25] &quot;number_genes&quot; &quot;number_unannotated_genes&quot; &quot;DM_batch&quot; [28] &quot;host_species&quot; &quot;host_order&quot; &quot;host_class&quot; [31] &quot;locality&quot; &quot;country&quot; &quot;MAG_url&quot; [34] &quot;anno_url&quot; &quot;kegg_url&quot; &quot;annotated&quot; [37] &quot;taxonomy_level&quot; &quot;assembly_type&quot; &quot;sample_type&quot; [40] &quot;gbk_url&quot; &quot;kegg_hits&quot; &quot;Capture ID&quot; [43] &quot;percent_unannotated_genes&quot; &quot;percent_unannotated_kegg&quot; &quot;dereplicated&quot; [46] &quot;metagenomic source&quot; &quot;completeness software&quot; &quot;binning software&quot; [49] &quot;assembly quality&quot; &quot;binning parameters&quot; &quot;taxonomic identity marker&quot; [52] &quot;isolation_source&quot; &quot;assembly software&quot; &quot;Submission&quot; Check contamination and completeness genome_biplot &lt;- ehi_mags %&gt;% dplyr::select(c(phylum,completeness,contamination,size)) %&gt;% ggplot(aes(x=completeness,y=contamination,size=size,color=phylum)) + geom_point(alpha=0.7) + xlim(c(70,100)) + ylim(c(10,0)) + scale_color_manual(values=phylum_colors) + labs(y= &quot;Contamination&quot;, x = &quot;Completeness&quot;) + theme_classic() + theme(legend.position = &quot;none&quot;) #Generate contamination boxplot genome_contamination &lt;- ehi_mags %&gt;% ggplot(aes(y=contamination)) + ylim(c(10,0)) + geom_boxplot(colour = &quot;#999999&quot;, fill=&quot;#cccccc&quot;) + theme_classic() + theme(legend.position = &quot;none&quot;, axis.line = element_blank(), axis.title = element_blank(), axis.text=element_blank(), axis.ticks=element_blank(), plot.margin = unit(c(0, 0, 0.40, 0),&quot;inches&quot;)) #add bottom-margin (top, right, bottom, left) genome_completeness &lt;- ehi_mags %&gt;% ggplot(aes(x=completeness)) + xlim(c(70,100)) + geom_boxplot(colour = &quot;#999999&quot;, fill=&quot;#cccccc&quot;) + theme_classic() + theme(legend.position = &quot;none&quot;, axis.line = element_blank(), axis.title = element_blank(), axis.text=element_blank(), axis.ticks=element_blank(), plot.margin = unit(c(0, 0, 0, 0.50),&quot;inches&quot;)) #add left-margin (top, right, bottom, left) #Render composite figure #pdf(&quot;figures/completeness_contamination.pdf&quot;,width=10, height=5) grid.arrange(grobs = list(genome_completeness,genome_biplot,genome_contamination), layout_matrix = rbind(c(1,1,1,1,1,1,1,1,1,1,1,4), c(2,2,2,2,2,2,2,2,2,2,2,3), c(2,2,2,2,2,2,2,2,2,2,2,3), c(2,2,2,2,2,2,2,2,2,2,2,3), c(2,2,2,2,2,2,2,2,2,2,2,3), c(2,2,2,2,2,2,2,2,2,2,2,3), c(2,2,2,2,2,2,2,2,2,2,2,3), c(2,2,2,2,2,2,2,2,2,2,2,3), c(2,2,2,2,2,2,2,2,2,2,2,3), c(2,2,2,2,2,2,2,2,2,2,2,3), c(2,2,2,2,2,2,2,2,2,2,2,3), c(2,2,2,2,2,2,2,2,2,2,2,3))) Warning: Removed 1725 rows containing non-finite outside the scale range (`stat_boxplot()`). Warning: No shared levels found between `names(values)` of the manual scale and the data&#39;s colour values. No shared levels found between `names(values)` of the manual scale and the data&#39;s colour values. Warning: Removed 1725 rows containing missing values or values outside the scale range (`geom_point()`). Warning: Removed 1 row containing non-finite outside the scale range (`stat_boxplot()`). Filter by completeness and contamination ehi_mags_filtered &lt;- ehi_mags %&gt;% filter(completeness &gt; 90, contamination &lt; 2.5) 3.0.2 Host classes species_hostclass_counts &lt;- ehi_mags_filtered %&gt;% filter(!is.na(species), species != &quot;&quot;) %&gt;% filter(!is.na(host_class), host_class != &quot;&quot;) %&gt;% group_by(species) %&gt;% summarise( n_mags = n(), n_host_classes = n_distinct(host_class), n_host_species = n_distinct(host_species), host_classes = paste(sort(unique(host_class)), collapse = &quot;, &quot;), host_species = paste(sort(unique(host_species)), collapse = &quot;, &quot;), phylum = paste(unique(phylum), collapse = &quot;, &quot;) ) %&gt;% arrange(desc(n_host_classes)) species_selection_3 &lt;- species_hostclass_counts %&gt;% filter(n_host_classes &gt;= 3) species_selection_2 &lt;- species_hostclass_counts %&gt;% filter(n_host_classes &gt;= 2) species_selection_3 %&gt;% arrange(-n_mags) # A tibble: 14 × 7 species n_mags n_host_classes n_host_species host_classes host_species phylum &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 s__Escherichia coli 64 3 20 Aves, Mammalia, Repti… Apodemus fl… p__Ps… 2 s__Pseudomonas aeruginosa 55 4 25 Amphibia, Aves, Mamma… Chloroceryl… p__Ps… 3 s__Lactococcus lactis 38 3 13 Aves, Mammalia, Repti… Barbastella… p__Ba… 4 s__Hafnia paralvei 25 3 10 Amphibia, Mammalia, R… Anguis frag… p__Ps… 5 s__Parabacteroides distasonis 25 3 10 Aves, Mammalia, Repti… Canis famil… p__Ba… 6 s__Enterococcus faecalis 21 3 11 Aves, Mammalia, Repti… Dasyurus ge… p__Ba… 7 s__Bacteroides uniformis 19 3 5 Aves, Mammalia, Repti… Canis famil… p__Ba… 8 s__Phocaeicola vulgatus 19 3 7 Aves, Mammalia, Repti… Canis famil… p__Ba… 9 s__Citrobacter braakii 16 3 9 Amphibia, Mammalia, R… Chalcides s… p__Ps… 10 s__Moellerella wisconsensis 13 3 5 Amphibia, Aves, Mamma… Geospizopsi… p__Ps… 11 s__Enterococcus_B pernyi 8 3 5 Aves, Mammalia, Repti… Miniopterus… p__Ba… 12 s__Buttiauxella gaviniae 7 3 3 Amphibia, Mammalia, R… Lissotriton… p__Ps… 13 s__Morganella morganii_A 7 3 4 Amphibia, Mammalia, R… Dasyurus ge… p__Ps… 14 s__Aeromonas encheleia 4 3 3 Amphibia, Mammalia, R… Lissotriton… p__Ps… species_selection_2 %&gt;% arrange(-n_mags) # A tibble: 63 × 7 species n_mags n_host_classes n_host_species host_classes host_species phylum &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 s__Escherichia coli 64 3 20 Aves, Mammalia, Rept… Apodemus fl… p__Ps… 2 s__Pseudomonas aeruginosa 55 4 25 Amphibia, Aves, Mamm… Chloroceryl… p__Ps… 3 s__Helicobacter_C marmotae 48 2 3 Aves, Mammalia Falco eleon… p__Ca… 4 s__Lactococcus lactis 38 3 13 Aves, Mammalia, Rept… Barbastella… p__Ba… 5 s__Hafnia paralvei 25 3 10 Amphibia, Mammalia, … Anguis frag… p__Ps… 6 s__Parabacteroides distasonis 25 3 10 Aves, Mammalia, Rept… Canis famil… p__Ba… 7 s__Enterococcus faecalis 21 3 11 Aves, Mammalia, Rept… Dasyurus ge… p__Ba… 8 s__Bacteroides uniformis 19 3 5 Aves, Mammalia, Rept… Canis famil… p__Ba… 9 s__Phocaeicola vulgatus 19 3 7 Aves, Mammalia, Rept… Canis famil… p__Ba… 10 s__Parabacteroides goldsteinii 17 2 8 Mammalia, Reptilia Lepus europ… p__Ba… # ℹ 53 more rows species_selection_2 %&gt;% group_by(phylum)%&gt;% summarize(n_species = n()) # A tibble: 7 × 2 phylum n_species &lt;chr&gt; &lt;int&gt; 1 p__Bacillota 13 2 p__Bacillota_A 8 3 p__Bacteroidota 14 4 p__Campylobacterota 1 5 p__Fusobacteriota 1 6 p__Pseudomonadota 25 7 p__Verrucomicrobiota 1 species_selection_3 %&gt;% group_by(phylum)%&gt;% summarize(n_species = n()) # A tibble: 3 × 2 phylum n_species &lt;chr&gt; &lt;int&gt; 1 p__Bacillota 3 2 p__Bacteroidota 3 3 p__Pseudomonadota 8 3.0.3 Host classes- after filtering species_selection_f &lt;- species_selection_2 %&gt;% dplyr::filter(n_mags &gt; 10) %&gt;% arrange(desc(n_mags)) species_selection_f # A tibble: 22 × 7 species n_mags n_host_classes n_host_species host_classes host_species phylum &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 s__Escherichia coli 64 3 20 Aves, Mammalia, Rept… Apodemus fl… p__Ps… 2 s__Pseudomonas aeruginosa 55 4 25 Amphibia, Aves, Mamm… Chloroceryl… p__Ps… 3 s__Helicobacter_C marmotae 48 2 3 Aves, Mammalia Falco eleon… p__Ca… 4 s__Lactococcus lactis 38 3 13 Aves, Mammalia, Rept… Barbastella… p__Ba… 5 s__Hafnia paralvei 25 3 10 Amphibia, Mammalia, … Anguis frag… p__Ps… 6 s__Parabacteroides distasonis 25 3 10 Aves, Mammalia, Rept… Canis famil… p__Ba… 7 s__Enterococcus faecalis 21 3 11 Aves, Mammalia, Rept… Dasyurus ge… p__Ba… 8 s__Bacteroides uniformis 19 3 5 Aves, Mammalia, Rept… Canis famil… p__Ba… 9 s__Phocaeicola vulgatus 19 3 7 Aves, Mammalia, Rept… Canis famil… p__Ba… 10 s__Parabacteroides goldsteinii 17 2 8 Mammalia, Reptilia Lepus europ… p__Ba… # ℹ 12 more rows species_selection_list&lt;- species_selection_f %&gt;% pull(species) species_selection_f %&gt;% group_by(phylum)%&gt;% summarize(n_species = n()) # A tibble: 7 × 2 phylum n_species &lt;chr&gt; &lt;int&gt; 1 p__Bacillota 4 2 p__Bacillota_A 2 3 p__Bacteroidota 4 4 p__Campylobacterota 1 5 p__Fusobacteriota 1 6 p__Pseudomonadota 9 7 p__Verrucomicrobiota 1 3.0.4 Count host classes per species counts_species_per_class&lt;- species_selection_f %&gt;% group_by(n_host_classes)%&gt;% summarize(n_species = n()) ggplot(counts_species_per_class, aes(x = n_host_classes, y = n_species)) + geom_col() + geom_text( aes(label = n_species), vjust = -0.3, size = 4 ) + labs( title = &quot;Number of Species per Number of Host Classes&quot;, x = &quot;Number of Host Classes&quot;, y = &quot;Number of Species&quot; ) + theme_bw() mags_with_counts &lt;- ehi_mags_filtered %&gt;% left_join(species_hostclass_counts, by = &quot;species&quot;) #filter for mags with &gt;1 host class mags_host2 &lt;- mags_with_counts %&gt;% dplyr::filter(n_host_classes &gt;= 2) n_mags &lt;- mags_host2 %&gt;% group_by(species) %&gt;% summarise(n_mags = n(), .groups = &quot;drop&quot;) We have several MAGs per species, so here we select the “best MAG” (highest completeness and lowest contamination), to have statistics based on the best of each. best_mag_per_species &lt;- mags_host2 %&gt;% filter(species %in% species_selection_list) %&gt;% group_by(species) %&gt;% arrange(desc(completeness), contamination) %&gt;% slice_head(n = 1) %&gt;% ungroup() %&gt;% transmute( species, best_mag_name = mag_name, best_MAG_link = link_to_assembly, best_genome_size = size, best_completeness = completeness, best_contamination = contamination, best_N50 = N50, best_host_classes = host_class, best_assembly_type = assembly_type, best_phylum =str_remove_all(phylum.x, &quot;p__&quot;)) ggplot(best_mag_per_species, aes(x= species, y = best_genome_size, fill = best_phylum))+ scale_color_manual(values=phylum_colors) + scale_fill_manual(values=phylum_colors) + geom_col()+ theme_bw()+ theme(axis.text.x = element_text(angle = 90)) Warning: No shared levels found between `names(values)` of the manual scale and the data&#39;s colour values. Filtering for Parabacteroides distasonis (make into a loop for all the relevant species later) p_dist &lt;- ehi_mags %&gt;% filter(completeness &gt;90, contamination &lt; 2.5, species == &quot;s__Parabacteroides distasonis&quot;) write_tsv(p_dist, &quot;data/mags_metadata/parabacteroides_distasonis_metadata.tsv&quot;) p_dist_index &lt;- p_dist %&gt;% dplyr::select(ID, MAG_url) write_tsv(p_dist_index, &quot;data/mags_metadata/parabacteroides_distasonis_index.tsv&quot;) species_selection_f &lt;- c( &quot;lactococcus_lactis&quot;, &quot;hafnia_paralvei&quot;, &quot;enterococcus_faecalis&quot;, &quot;enterococcus_hirae&quot;, &quot;bacteroides_uniformis&quot;, &quot;phocaeicola_vulgatus&quot;, &quot;parabacteroides_goldsteinii&quot;, &quot;akkermansia_muciniphila&quot;, &quot;bacteroides_fragilis&quot;, &quot;providencia_rettgeri&quot;, &quot;citrobacter_braakii&quot; ) ehi_mags_clean &lt;- ehi_mags %&gt;% mutate( species_clean = species %&gt;% str_replace(&quot;^s__&quot;, &quot;&quot;) %&gt;% str_to_lower() %&gt;% str_replace_all(&quot; &quot;, &quot;_&quot;) ) for (current_species in species_selection_f) { message(&quot;Processing &quot;, current_species) species_data &lt;- ehi_mags_clean %&gt;% filter( completeness &gt; 90, contamination &lt; 2.5, species_clean == current_species ) species_index &lt;- species_data %&gt;% dplyr::select(ID, MAG_url) filename &lt;- current_species %&gt;% str_replace(&quot;s__&quot;, &quot;&quot;) %&gt;% str_replace_all(&quot; &quot;, &quot;_&quot;) %&gt;% tolower() write_tsv( species_data, paste0(&quot;data/mags_metadata/&quot;, filename, &quot;_metadata.tsv&quot;) ) write_tsv( species_index, paste0(&quot;data/mags_metadata/&quot;, filename, &quot;_index.tsv&quot;) ) } ### First only with two: all_mags &lt;- ehi_mags %&gt;% filter(completeness &gt; 90, contamination &lt; 2.5, species %in% c(&quot;s__Parabacteroides distasonis&quot;, &quot;s__Phocaeicola vulgatus&quot;)) %&gt;% mutate(species = str_remove(species, &quot;^s__&quot;) %&gt;% str_to_lower() %&gt;% str_replace(&quot; &quot;, &quot;_&quot;), out_path = paste0(&quot;data/&quot;, species, &quot;/mags/&quot;, basename(MAG_url)) ) %&gt;% dplyr::select(species, ID, MAG_url, out_path) write_tsv(all_mags, &quot;all_mags_index.tsv&quot;) "],["ncbi-mags-exploration.html", "Chapter 4 NCBI MAGs exploration 4.1 NCBI MAGs metadata 4.2 Downloading the MAGs after filtering 4.3 Data preparation", " Chapter 4 NCBI MAGs exploration 4.1 NCBI MAGs metadata gut_keywords &lt;- c(&quot;ceaca&quot;, &quot;caeca&quot;, &quot;excrement&quot;, &quot;excrements&quot;, &quot;rectal&quot;, &quot;feces&quot;, &quot;stool&quot;, &quot;stools&quot;, &quot;gut&quot;, &quot;cloaca&quot;, &quot;cloacal&quot;, &quot;fecal&quot;, &quot;intestines&quot;, &quot;intestine&quot;, &quot;intestinal&quot;, &quot;cecum&quot;, &quot;ileum&quot;, &quot;jejunum&quot;, &quot;colon&quot;, &quot;rectum&quot;, &quot;rumen&quot;, &quot;anal&quot;, &quot;anus&quot;, &quot;manure&quot;, &quot;faeces&quot;) # Wrap each keyword in word boundaries: \\bkeyword\\b --otherwise artisanal passes the filter pattern &lt;- paste0(&quot;\\\\b(&quot;, paste(gut_keywords, collapse = &quot;|&quot;), &quot;)\\\\b&quot;) # Filter the data #gut_samples &lt;- metadata_wide %&gt;% # filter(str_detect(isolation_source, regex(pattern, ignore_case = TRUE))) Download metadata for each taxa # Trying to download ncbi metadata for mags conda activate drakkar_env conda install -c conda-forge ncbi-datasets-cli ## CITROBACTER BRAAKII datasets summary genome taxon 57706 \\ --as-json-lines &gt; genomes.jsonl #filtering by contamination and completeness jq -c &#39; select( .checkm_info.completeness &gt;= 90 and .checkm_info.contamination &lt;= 2.5 ) &#39; genomes.jsonl &gt; high_quality_genomes.jsonl #put metadata in tsv jq -r &#39; .accession as $asm | .checkm_info.completeness as $comp | .checkm_info.contamination as $cont | .assembly_stats.total_sequence_length as $genome_size | .assembly_stats.gc_percent as $gc | .assembly_info.biosample.attributes[]? | [$asm, $comp, $cont, $genome_size, $gc, .name, .value] | @tsv &#39; high_quality_genomes.jsonl &gt; citrobacter_biosample_attributes.tsv 4.1.1 Citrobacter braakii c_braki_metadata &lt;- read_tsv(&quot;data/mags_metadata/citrobacter_braakii_biosample_attributes.tsv&quot;, col_names = c( &quot;accession&quot;, &quot;completeness&quot;, &quot;contamination&quot;, &quot;genome_size&quot;, &quot;gc_percent&quot;, &quot;name&quot;, &quot;value&quot; ) ) wide &lt;- c_braki_metadata %&gt;% pivot_wider( id_cols = c( accession, completeness, contamination, genome_size, gc_percent ), names_from = name, values_from = value ) source_counts &lt;- wide %&gt;% filter(!is.na(isolation_source)) %&gt;% dplyr::count(isolation_source, sort = TRUE) source_counts host_counts &lt;- wide %&gt;% filter(!is.na(host)) %&gt;% dplyr::count(host, sort = TRUE) host_counts wide %&gt;% filter(host == &quot;Homo sapiens&quot;) citrobacter_gut &lt;- wide %&gt;% filter(str_detect(isolation_source, regex(pattern, ignore_case = TRUE))) citrobacter_gut %&gt;%tt() ## HUMAN summary_counts &lt;- citrobacter_gut %&gt;% dplyr::summarize( total_rows = n(), human_samples = sum( host == &quot;Homo sapiens&quot; | stringr::str_detect(isolation_source, stringr::regex(&quot;human&quot;, ignore_case = TRUE)), na.rm = TRUE ) ) print(summary_counts) ## OTHER HOSTS other_hosts &lt;- citrobacter_gut %&gt;% dplyr::filter(host != &quot;Homo sapiens&quot; | is.na(host)) %&gt;% dplyr::count(host, sort = TRUE) print(other_hosts) 4.1.2 Lactococcus lactis ## LACTOCOCCUS LACTIS datasets summary genome taxon 1358 \\ --as-json-lines &gt; lactococcus_genomes.jsonl #filtering by contamination and completeness jq -c &#39; select( .checkm_info.completeness &gt;= 90 and .checkm_info.contamination &lt;= 2.5 ) &#39; lactococcus_genomes.jsonl &gt; lactococcus_high_quality_genomes.jsonl #put metadata in tsv jq -r &#39; .accession as $asm | .checkm_info.completeness as $comp | .checkm_info.contamination as $cont | .assembly_stats.total_sequence_length as $genome_size | .assembly_stats.gc_percent as $gc | .assembly_info.biosample.attributes[]? | [$asm, $comp, $cont, $genome_size, $gc, .name, .value] | @tsv &#39; lactococcus_high_quality_genomes.jsonl &gt; lactococcus_biosample_attributes.tsv lactococcus_metadata &lt;- read_tsv(&quot;data/mags_metadata/lactococcus_lactis_biosample_attributes.tsv&quot;, col_names = c(&quot;assembly&quot;, &quot;attribute&quot;, &quot;value&quot;)) metadata_wide &lt;- lactococcus_metadata %&gt;% filter(attribute != &quot;assembly&quot;) %&gt;% # assembly is in some attribute column, causing issues pivot_wider( id_cols = assembly, names_from = attribute, values_from = value, values_fn = list(value = ~ paste(.x, collapse = &quot;; &quot;)) ) lactococcus_gut &lt;- metadata_wide %&gt;% filter(str_detect(isolation_source, regex(pattern, ignore_case = TRUE))) ## HUMAN summary_counts &lt;- lactococcus_gut %&gt;% dplyr::summarize( total_rows = n(), human_samples = sum( host == &quot;Homo sapiens&quot; | stringr::str_detect(isolation_source, stringr::regex(&quot;human&quot;, ignore_case = TRUE)), na.rm = TRUE ) ) print(summary_counts) ## OTHER HOSTS other_hosts &lt;- lactococcus_gut %&gt;% dplyr::filter(host != &quot;Homo sapiens&quot; | is.na(host)) %&gt;% dplyr::count(host, sort = TRUE) print(other_hosts) 4.1.3 Hafnia paralvei ## HAFNIA PARALVEI datasets summary genome taxon 546367 \\ --as-json-lines &gt; hafnia_genomes.jsonl #filtering by contamination and completeness jq -c &#39; select( .checkm_info.completeness &gt;= 90 and .checkm_info.contamination &lt;= 2.5 ) &#39; hafnia_genomes.jsonl &gt; hafnia_high_quality_genomes.jsonl #put metadata in tsv jq -r &#39; .accession as $asm | .assembly_info.biosample.attributes[]? | [$asm, .name, .value] | @tsv &#39; hafnia_high_quality_genomes.jsonl &gt; hafnia_biosample_attributes.tsv hafnia_metadata &lt;- read_tsv(&quot;data/ncbi/hafnia_paralvei_biosample_attributes.tsv&quot;, col_names = c(&quot;assembly&quot;, &quot;attribute&quot;, &quot;value&quot;)) metadata_wide &lt;- hafnia_metadata %&gt;% pivot_wider( id_cols = assembly, names_from = attribute, values_from = value, values_fn = function(x) x[1] ) hafnia_gut &lt;- metadata_wide %&gt;% filter(str_detect(isolation_source, regex(pattern, ignore_case = TRUE))) ## HUMAN summary_counts &lt;- hafnia_gut %&gt;% dplyr::summarize( total_rows = n(), human_samples = sum( host == &quot;Homo sapiens&quot; | stringr::str_detect(isolation_source, stringr::regex(&quot;human&quot;, ignore_case = TRUE)), na.rm = TRUE ) ) print(summary_counts) ## OTHER HOSTS other_hosts &lt;- hafnia_gut %&gt;% dplyr::filter(host != &quot;Homo sapiens&quot; | is.na(host)) %&gt;% dplyr::count(host, sort = TRUE) print(other_hosts) 4.1.4 Enterococcus faecalis ## ENTEROCOCCUS FAECALIS datasets summary genome taxon 1351 \\ --as-json-lines &gt; enterococcus_faecalis_genomes.jsonl #filtering by contamination and completeness jq -c &#39; select( .checkm_info.completeness &gt;= 90 and .checkm_info.contamination &lt;= 2.5 ) &#39; enterococcus_faecalis_genomes.jsonl &gt; enterococcus_faecalis_high_quality_genomes.jsonl #put metadata in tsv jq -r &#39; .accession as $asm | .assembly_info.biosample.attributes[]? | [$asm, .name, .value] | @tsv &#39; enterococcus_faecalis_high_quality_genomes.jsonl &gt; enterococcus_faecalis_biosample_attributes.tsv enterococcus_faecalis_metadata &lt;- read_tsv(&quot;data/ncbi/enterococcus_faecalis_biosample_attributes.tsv&quot;, col_names = c(&quot;assembly&quot;, &quot;attribute&quot;, &quot;value&quot;)) metadata_wide &lt;- enterococcus_faecalis_metadata %&gt;% pivot_wider( id_cols = assembly, names_from = attribute, values_from = value, values_fn = function(x) x[1] ) enterococcus_faecalis_gut &lt;- metadata_wide %&gt;% filter(str_detect(isolation_source, regex(pattern, ignore_case = TRUE))) ## HUMAN summary_counts &lt;- enterococcus_faecalis_gut %&gt;% dplyr::summarize( total_rows = n(), human_samples = sum( host == &quot;Homo sapiens&quot; | stringr::str_detect(isolation_source, stringr::regex(&quot;human&quot;, ignore_case = TRUE)), na.rm = TRUE ) ) print(summary_counts) ## OTHER HOSTS other_hosts &lt;- enterococcus_faecalis_gut %&gt;% dplyr::filter(host != &quot;Homo sapiens&quot; | is.na(host)) %&gt;% dplyr::count(host, sort = TRUE) print(other_hosts) 4.1.5 Enterococcus hirae ## ENTEROCOCCUS HIRAE datasets summary genome taxon 1354 \\ --as-json-lines &gt; enterococcus_genomes.jsonl #filtering by contamination and completeness jq -c &#39; select( .checkm_info.completeness &gt;= 90 and .checkm_info.contamination &lt;= 2.5 ) &#39; enterococcus_genomes.jsonl &gt; enterococcus_high_quality_genomes.jsonl #put metadata in tsv jq -r &#39; .accession as $asm | .assembly_info.biosample.attributes[]? | [$asm, .name, .value] | @tsv &#39; enterococcus_high_quality_genomes.jsonl &gt; enterococcus_biosample_attributes.tsv enterococcus_metadata &lt;- read_tsv(&quot;data/ncbi/enterococcus_hirae_biosample_attributes.tsv&quot;, col_names = c(&quot;assembly&quot;, &quot;attribute&quot;, &quot;value&quot;)) metadata_wide &lt;- enterococcus_metadata %&gt;% pivot_wider( id_cols = assembly, names_from = attribute, values_from = value, values_fn = function(x) x[1] ) enterococcus_gut &lt;- metadata_wide %&gt;% filter(str_detect(isolation_source, regex(pattern, ignore_case = TRUE))) ## HUMAN summary_counts &lt;- enterococcus_gut %&gt;% dplyr::summarize( total_rows = n(), human_samples = sum( host == &quot;Homo sapiens&quot; | stringr::str_detect(isolation_source, stringr::regex(&quot;human&quot;, ignore_case = TRUE)), na.rm = TRUE ) ) print(summary_counts) ## OTHER HOSTS other_hosts &lt;- enterococcus_gut %&gt;% dplyr::filter(host != &quot;Homo sapiens&quot; | is.na(host)) %&gt;% dplyr::count(host, sort = TRUE) print(other_hosts) 4.1.6 Bacteroides uniformis ## BACTEROIDES UNIFORMIS datasets summary genome taxon 820 \\ --as-json-lines &gt; b_uniformis_genomes.jsonl #filtering by contamination and completeness jq -c &#39; select( .checkm_info.completeness &gt;= 90 and .checkm_info.contamination &lt;= 2.5 ) &#39; b_uniformis_genomes.jsonl &gt; b_uniformis_high_quality_genomes.jsonl #put metadata in tsv jq -r &#39; .accession as $asm | .assembly_info.biosample.attributes[]? | [$asm, .name, .value] | @tsv &#39; b_uniformis_high_quality_genomes.jsonl &gt; b_uniformis_biosample_attributes.tsv b_uniformis_metadata &lt;- read_tsv(&quot;data/ncbi/bacteroides_uniformis_biosample_attributes.tsv&quot;, col_names = c(&quot;assembly&quot;, &quot;attribute&quot;, &quot;value&quot;)) metadata_wide &lt;- b_uniformis_metadata %&gt;% filter(attribute != &quot;assembly&quot;) %&gt;% pivot_wider( id_cols = assembly, names_from = attribute, values_from = value, values_fn = function(x) x[1] ) b_uniformis_gut &lt;- metadata_wide %&gt;% filter(str_detect(isolation_source, regex(pattern, ignore_case = TRUE))) ## HUMAN summary_counts &lt;- b_uniformis_gut %&gt;% dplyr::summarize( total_rows = n(), human_samples = sum( host == &quot;Homo sapiens&quot; | stringr::str_detect(isolation_source, stringr::regex(&quot;human&quot;, ignore_case = TRUE)), na.rm = TRUE ) ) print(summary_counts) ## OTHER HOSTS other_hosts &lt;- b_uniformis_gut %&gt;% dplyr::filter(host != &quot;Homo sapiens&quot; | is.na(host)) %&gt;% dplyr::count(host, sort = TRUE) print(other_hosts) 4.1.7 Phocaeicola vulgatus ## PHOCAEICOLA VULGATUS datasets summary genome taxon 821 \\ --as-json-lines &gt; p_vulgatus_genomes.jsonl #filtering by contamination and completeness jq -c &#39; select( .checkm_info.completeness &gt;= 90 and .checkm_info.contamination &lt;= 2.5 ) &#39; p_vulgatus_genomes.jsonl &gt; p_vulgatus_high_quality_genomes.jsonl #put metadata in tsv jq -r &#39; .accession as $asm | .assembly_info.biosample.attributes[]? | [$asm, .name, .value] | @tsv &#39; p_vulgatus_high_quality_genomes.jsonl &gt; p_vulgatus_biosample_attributes.tsv p_vulgatus_metadata &lt;- read_tsv(&quot;data/ncbi/p_vulgatus_biosample_attributes.tsv&quot;, col_names = c(&quot;assembly&quot;, &quot;attribute&quot;, &quot;value&quot;)) metadata_wide &lt;- p_vulgatus_metadata %&gt;% filter(attribute != &quot;assembly&quot;) %&gt;% pivot_wider( id_cols = assembly, names_from = attribute, values_from = value, values_fn = function(x) x[1] ) p_vulgatus_gut &lt;- metadata_wide %&gt;% filter(str_detect(isolation_source, regex(pattern, ignore_case = TRUE))) ## HUMAN summary_counts &lt;- p_vulgatus_gut %&gt;% dplyr::summarize( total_rows = n(), human_samples = sum( host == &quot;Homo sapiens&quot; | stringr::str_detect(isolation_source, stringr::regex(&quot;human&quot;, ignore_case = TRUE)), na.rm = TRUE ) ) print(summary_counts) ## OTHER HOSTS other_hosts &lt;- p_vulgatus_gut %&gt;% dplyr::filter(host != &quot;Homo sapiens&quot; | is.na(host)) %&gt;% dplyr::count(host, sort = TRUE) print(other_hosts) 4.1.8 Parabacteroides goldsteinii ## PARABACTEROIDES GOLDSTEINII datasets summary genome taxon 328812 \\ --as-json-lines &gt; p_goldsteinii_genomes.jsonl #filtering by contamination and completeness jq -c &#39; select( .checkm_info.completeness &gt;= 90 and .checkm_info.contamination &lt;= 2.5 ) &#39; p_goldsteinii_genomes.jsonl &gt; p_goldsteinii_high_quality_genomes.jsonl #put metadata in tsv jq -r &#39; .accession as $asm | .assembly_info.biosample.attributes[]? | [$asm, .name, .value] | @tsv &#39; p_goldsteinii_high_quality_genomes.jsonl &gt; p_goldsteinii_biosample_attributes.tsv p_goldsteinii_metadata &lt;- read_tsv(&quot;data/ncbi/parabacteroides_goldsteinii_biosample_attributes.tsv&quot;, col_names = c(&quot;assembly&quot;, &quot;attribute&quot;, &quot;value&quot;)) metadata_wide &lt;- p_goldsteinii_metadata %&gt;% filter(attribute != &quot;assembly&quot;) %&gt;% pivot_wider( id_cols = assembly, names_from = attribute, values_from = value, values_fn = function(x) x[1] ) p_goldsteinii_gut &lt;- metadata_wide %&gt;% filter(str_detect(isolation_source, regex(pattern, ignore_case = TRUE))) ## HUMAN summary_counts &lt;- p_goldsteinii_gut %&gt;% dplyr::summarize( total_rows = n(), human_samples = sum( host == &quot;Homo sapiens&quot; | stringr::str_detect(isolation_source, stringr::regex(&quot;human&quot;, ignore_case = TRUE)), na.rm = TRUE ) ) print(summary_counts) ## OTHER HOSTS other_hosts &lt;- p_goldsteinii_gut %&gt;% dplyr::filter(host != &quot;Homo sapiens&quot; | is.na(host)) %&gt;% dplyr::count(host, sort = TRUE) print(other_hosts) 4.1.9 Akkermansia municiphila ## AKKERMANSIA MUNICIPHILA datasets summary genome taxon 239935 \\ --as-json-lines &gt; akkermansia_genomes.jsonl #filtering by contamination and completeness jq -c &#39; select( .checkm_info.completeness &gt;= 90 and .checkm_info.contamination &lt;= 2.5 ) &#39; akkermansia_genomes.jsonl &gt; akkermansia_high_quality_genomes.jsonl #put metadata in tsv jq -r &#39; .accession as $asm | .assembly_info.biosample.attributes[]? | [$asm, .name, .value] | @tsv &#39; akkermansia_high_quality_genomes.jsonl &gt; akkermansia_biosample_attributes.tsv akkermansia_metadata &lt;- read_tsv(&quot;data/ncbi/akkermansia_muciniphila_biosample_attributes.tsv&quot;, col_names = c(&quot;assembly&quot;, &quot;attribute&quot;, &quot;value&quot;)) metadata_wide &lt;- akkermansia_metadata %&gt;% filter(attribute != &quot;assembly&quot;) %&gt;% pivot_wider( id_cols = assembly, names_from = attribute, values_from = value, values_fn = function(x) x[1] ) akkermansia_gut &lt;- metadata_wide %&gt;% filter(str_detect(isolation_source, regex(pattern, ignore_case = TRUE))) ## HUMAN summary_counts &lt;- akkermansia_gut %&gt;% dplyr::summarize( total_rows = n(), human_samples = sum( host == &quot;Homo sapiens&quot; | stringr::str_detect(isolation_source, stringr::regex(&quot;human&quot;, ignore_case = TRUE)), na.rm = TRUE ) ) print(summary_counts) ## OTHER HOSTS other_hosts &lt;- akkermansia_gut %&gt;% dplyr::filter(host != &quot;Homo sapiens&quot; | is.na(host)) %&gt;% dplyr::count(host, sort = TRUE) print(other_hosts) 4.1.10 Bacteroides fragilis ## BACTEROIDES FRAGILIS datasets summary genome taxon 817 \\ --as-json-lines &gt; b_fragilis_genomes.jsonl #filtering by contamination and completeness jq -c &#39; select( .checkm_info.completeness &gt;= 90 and .checkm_info.contamination &lt;= 2.5 ) &#39; b_fragilis_genomes.jsonl &gt; b_fragilis_high_quality_genomes.jsonl #put metadata in tsv jq -r &#39; .accession as $asm | .assembly_info.biosample.attributes[]? | [$asm, .name, .value] | @tsv &#39; b_fragilis_high_quality_genomes.jsonl &gt; b_fragilis_biosample_attributes.tsv b_fragilis_metadata &lt;- read_tsv(&quot;data/ncbi/bacteroides_fragilis_biosample_attributes.tsv&quot;, col_names = c(&quot;assembly&quot;, &quot;attribute&quot;, &quot;value&quot;)) metadata_wide &lt;- b_fragilis_metadata %&gt;% filter(attribute != &quot;assembly&quot;) %&gt;% pivot_wider( id_cols = assembly, names_from = attribute, values_from = value, values_fn = function(x) x[1] ) b_fragilis_gut &lt;- metadata_wide %&gt;% filter(str_detect(isolation_source, regex(pattern, ignore_case = TRUE))) ## HUMAN summary_counts &lt;- b_fragilis_gut %&gt;% dplyr::summarize( total_rows = n(), human_samples = sum( host == &quot;Homo sapiens&quot; | stringr::str_detect(isolation_source, stringr::regex(&quot;human&quot;, ignore_case = TRUE)), na.rm = TRUE ) ) print(summary_counts) ## OTHER HOSTS other_hosts &lt;- b_fragilis_gut %&gt;% dplyr::filter(host != &quot;Homo sapiens&quot; | is.na(host)) %&gt;% dplyr::count(host, sort = TRUE) print(other_hosts) 4.1.11 Providencia rettgeri ## PROVIDENCIA RETTGERI datasets summary genome taxon 587 \\ --as-json-lines &gt; providencia_genomes.jsonl #filtering by contamination and completeness jq -c &#39; select( .checkm_info.completeness &gt;= 90 and .checkm_info.contamination &lt;= 2.5 ) &#39; providencia_genomes.jsonl &gt; providencia_high_quality_genomes.jsonl #put metadata in tsv jq -r &#39; .accession as $asm | .assembly_info.biosample.attributes[]? | [$asm, .name, .value] | @tsv &#39; providencia_high_quality_genomes.jsonl &gt; providencia_biosample_attributes.tsv providencia_metadata &lt;- read_tsv(&quot;data/ncbi/providencia_rettgeri_biosample_attributes.tsv&quot;, col_names = c(&quot;assembly&quot;, &quot;attribute&quot;, &quot;value&quot;)) metadata_wide &lt;- providencia_metadata %&gt;% filter(attribute != &quot;assembly&quot;) %&gt;% pivot_wider( id_cols = assembly, names_from = attribute, values_from = value, values_fn = function(x) x[1] ) providencia_gut &lt;- metadata_wide %&gt;% filter(str_detect(isolation_source, regex(pattern, ignore_case = TRUE))) ## HUMAN summary_counts &lt;- providencia_gut %&gt;% dplyr::summarize( total_rows = n(), human_samples = sum( host == &quot;Homo sapiens&quot; | stringr::str_detect(isolation_source, stringr::regex(&quot;human&quot;, ignore_case = TRUE)), na.rm = TRUE ) ) print(summary_counts) ## OTHER HOSTS other_hosts &lt;- providencia_gut %&gt;% dplyr::filter(host != &quot;Homo sapiens&quot; | is.na(host)) %&gt;% dplyr::count(host, sort = TRUE) print(other_hosts) species &lt;- c( &quot;lactococcus_lactis&quot;, &quot;hafnia_paralvei&quot;, &quot;enterococcus_faecalis&quot;, &quot;enterococcus_hirae&quot;, &quot;bacteroides_uniformis&quot;, &quot;phocaeicola_vulgatus&quot;, &quot;parabacteroides_goldsteinii&quot;, &quot;akkermansia_muciniphila&quot;, &quot;bacteroides_fragilis&quot;, &quot;providencia_rettgeri&quot;, &quot;citrobacter_braakii&quot; ) for (sp in species) { message(&quot;Processing &quot;, sp) infile &lt;- file.path( &quot;data/mags_metadata&quot;, paste0(sp, &quot;_biosample_attributes.tsv&quot;) ) metadata_long &lt;- read_tsv( infile, col_names = c( &quot;accession&quot;, &quot;completeness&quot;, &quot;contamination&quot;, &quot;genome_size&quot;, &quot;gc_percent&quot;, &quot;name&quot;, &quot;value&quot; ), show_col_types = FALSE ) metadata_wide &lt;- metadata_long %&gt;% pivot_wider( id_cols = c( accession, completeness, contamination, genome_size, gc_percent ), names_from = name, values_from = value, values_fn = ~ dplyr::first(na.omit(.x)), names_repair = &quot;unique&quot; ) ## filter gut-associated genomes if (&quot;isolation_source&quot; %in% colnames(metadata_wide)) { gut_metadata &lt;- metadata_wide %&gt;% filter( str_detect( isolation_source, regex(pattern, ignore_case = TRUE) ) ) } else { warning(sp, &quot; has no isolation_source column&quot;) gut_metadata &lt;- metadata_wide[0, ] } ## save ONLY the gut-filtered metadata saveRDS( gut_metadata, file.path( &quot;data/mags_metadata&quot;, paste0(sp, &quot;_ncbi_metadata.rds&quot;) ) ) selected_accessions &lt;- gut_metadata %&gt;% pull(accession) %&gt;% unique() selected_accessions &lt;- selected_accessions[!is.na(selected_accessions)] writeLines( selected_accessions, file.path( &quot;data/mags_metadata&quot;, paste0(sp, &quot;_ncbi_selected_accessions.txt&quot;) ) ) } 4.2 Downloading the MAGs after filtering Download the MAGs when you finish selecting them ### DOWNLOAD THE MAGS datasets download genome accession --inputfile ../bacteroides_unifmormis_ncbi_selected_accessions.txt --include genome --filename hafnia_paralvei_selected_genomes.zip mags_gtdb &lt;- read_tsv(&quot;data/mags_metadata/master_mag_index_lactococcus_lactis.tsv&quot;) %&gt;% pull(ID) intersect(selected, mags_gtdb) # in selected but NOT in mags_gtdb setdiff(selected, mags_gtdb) # in mags_gtdb but NOT in selected setdiff(mags_gtdb, selected) 4.3 Data preparation 4.3.1 EHI MAGs ehi_mags &lt;- read_csv(&quot;data/ehi_mags.csv&quot;) Rows: 8846 Columns: 52 ── Column specification ──────────────────────────────────────────────────────────────────────────────────────── Delimiter: &quot;,&quot; chr (36): ID, mag_name, link_to_assembly, AB_batch, eha_number, GTDB_version, GTDB_release, domain, phylum, ... dbl (15): fastani_ani, closest_placement_ani, closest_placement_af, completeness, contamination, size, N50, ... lgl (1): annotated ℹ Use `spec()` to retrieve the full column specification for this data. ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. 4.3.2 Prepare color scheme AlberdiLab projects use unified color schemes developed for the Earth Hologenome Initiative, to facilitate figure interpretation. ehi_mags_p &lt;- ehi_mags %&gt;% mutate(phylum=str_remove_all(phylum, &quot;p__&quot;)) phylum_colors &lt;- read_tsv(&quot;https://raw.githubusercontent.com/earthhologenome/EHI_taxonomy_colour/main/ehi_phylum_colors.tsv&quot;) %&gt;% mutate(phylum=str_remove_all(phylum, &quot;p__&quot;)) %&gt;% right_join(ehi_mags_p, by=join_by(phylum == phylum)) %&gt;% dplyr::select(phylum, colors) %&gt;% unique() %&gt;% arrange(phylum) %&gt;% pull(colors, name=phylum) source_colors &lt;- c(EHI = &quot;#8BC63F&quot;, GTDB = &quot;#2D522D&quot;, NCBI= &quot;#20558A&quot;) host_type_colors &lt;- c(human = &quot;#A90D00&quot; , animal = &quot;darkgreen&quot;) host_order_colors &lt;- c( &quot;Accipitriformes&quot; = &quot;#143AC2&quot;, # Aves &quot;Carnivora&quot; = &quot;#633C2C&quot;, # Mammalia &quot;Chiroptera&quot; = &quot;#1B2021&quot;, # Mammalia &quot;Primates&quot; = &quot;#CC0000&quot;, # Mammalia &quot;Rodentia&quot; = &quot;#FDA991&quot;, # Mammalia &quot;Diptera&quot; = &quot;#FFAE2B&quot;, # Insecta &quot;Isoptera&quot; = &quot;#E27500&quot;, # Insecta &quot;Lepidoptera&quot; = &quot;#C8591D&quot;, # Insecta &quot;Squamata&quot; = &quot;#1D921B&quot; # Reptilia ) 4.3.3 Sample metadata genome_metadata &lt;- read_tsv(&quot;data/mags_metadata/lactococcus_lactis_FINAL_metadata.tsv&quot;) Rows: 129 Columns: 45 ── Column specification ──────────────────────────────────────────────────────────────────────────────────────── Delimiter: &quot;\\t&quot; chr (28): ID, source, species, gtdb_taxonomy, host_species, host_order, host_class, isolation_source, host, ... dbl (8): completeness, contamination, genome_size, GC, N50, contigs, latitude, longitude lgl (9): host_summary, gtdb_representative, mimag_high_quality, mimag_medium_quality, host_status, disease,... ℹ Use `spec()` to retrieve the full column specification for this data. ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. # Helper across the pipeline is_blank &lt;- function(x) is.na(x) | x == &quot;&quot; # 1) Recreate host_text (as you had) genome_metadata &lt;- genome_metadata %&gt;% mutate( host_text = str_to_lower( str_squish( paste( coalesce(host_species, &quot;&quot;), coalesce(host, &quot;&quot;), coalesce(isolation_source, &quot;&quot;), coalesce(env_broad, &quot;&quot;), coalesce(env_local_context, &quot;&quot;), sep = &quot; ; &quot; ) ) ) ) # 2) Infer host_species ONLY when missing/empty — now with your new species genome_metadata &lt;- genome_metadata %&gt;% mutate( host_species = dplyr::case_when( # keep explicit host_species if present !is_blank(host_species) ~ host_species, # Human str_detect(host_text, &quot;homo sapiens|\\\\bhuman\\\\b|patient|adult|child|infant&quot;) ~ &quot;Homo sapiens&quot;, # Mouse str_detect(host_text, &quot;mus musculus|\\\\bmouse\\\\b|\\\\bmice\\\\b|murine&quot;) ~ &quot;Mus musculus&quot;, # Rat str_detect(host_text, &quot;rattus|\\\\brat\\\\b&quot;) ~ &quot;Rattus norvegicus&quot;, # Pig / swine str_detect(host_text, &quot;sus scrofa|porcine|\\\\bpig\\\\b|swine&quot;) ~ &quot;Sus scrofa&quot;, # Cow / bovine str_detect(host_text, &quot;bos taurus|bovine|\\\\bcow\\\\b|cattle&quot;) ~ &quot;Bos taurus&quot;, # Dog / canine (normalize variants) str_detect(host_text, &quot;canis lupus familiaris|canis familiaris|\\\\bdog\\\\b|canine&quot;) ~ &quot;Canis lupus familiaris&quot;, # Chicken / poultry str_detect(host_text, &quot;gallus gallus|\\\\bchicken\\\\b|poultry&quot;) ~ &quot;Gallus gallus&quot;, # Silkworm str_detect(host_text, &quot;bombyx mori|silkworm&quot;) ~ &quot;Bombyx mori&quot;, # Drosophila / fruit fly str_detect(host_text, &quot;drosophila|fruit fly&quot;) ~ &quot;Drosophila melanogaster&quot;, # Termite str_detect(host_text, &quot;\\\\btermite\\\\b&quot;) ~ &quot;Termite&quot;, # Zebrafish str_detect(host_text, &quot;danio rerio|zebrafish&quot;) ~ &quot;Danio rerio&quot;, # Generic fish (also catch “fishbut”-style glued tokens) str_detect(host_text, &quot;\\\\bfish\\\\w*\\\\b&quot;) ~ &quot;Actinopterygii (fish)&quot;, # Bats and other taxa (from your counts) str_detect(host_text, &quot;barbastella barbastellus&quot;) ~ &quot;Barbastella barbastellus&quot;, str_detect(host_text, &quot;glauconycteris\\\\s*sp\\\\.?&quot;) ~ &quot;Glauconycteris sp&quot;, str_detect(host_text, &quot;hipposideros ruber&quot;) ~ &quot;Hipposideros ruber&quot;, str_detect(host_text, &quot;rhinolophus capensis&quot;) ~ &quot;Rhinolophus capensis&quot;, # Vulture str_detect(host_text, &quot;cathartes aura&quot;) ~ &quot;Cathartes aura&quot;, # Grasshopper str_detect(host_text, &quot;\\\\bgrasshopper\\\\b&quot;) ~ &quot;Grasshopper&quot;, # New primate + fish species from your list str_detect(host_text, &quot;macaca fascicularis&quot;) ~ &quot;Macaca fascicularis&quot;, str_detect(host_text, &quot;oncorhynchus mykiss&quot;) ~ &quot;Oncorhynchus mykiss&quot;, str_detect(host_text, &quot;oreochromis niloticus&quot;) ~ &quot;Oreochromis niloticus&quot;, TRUE ~ host_species ) ) # 3) Normalize existing host_species text so class/order rules match reliably genome_metadata &lt;- genome_metadata %&gt;% mutate( hs_lower = str_to_lower(host_species), host_species = dplyr::case_when( # canonicalize common variants str_detect(hs_lower, &quot;^canis(\\\\s+lupus)?\\\\s+familiaris$&quot;) ~ &quot;Canis lupus familiaris&quot;, str_detect(hs_lower, &quot;^drosophila melanogaster$&quot;) ~ &quot;Drosophila melanogaster&quot;, str_detect(hs_lower, &quot;^bombyx mori$&quot;) ~ &quot;Bombyx mori&quot;, str_detect(hs_lower, &quot;^danio rerio$&quot;) ~ &quot;Danio rerio&quot;, str_detect(hs_lower, &quot;^homo sapiens$&quot;) ~ &quot;Homo sapiens&quot;, # catch glued fish tokens (e.g., &quot;fishbut&quot;, &quot;fishsomething&quot;) str_detect(hs_lower, &quot;^fish\\\\w*$&quot;) ~ &quot;Actinopterygii (fish)&quot;, TRUE ~ host_species ) ) %&gt;% dplyr::select(-hs_lower) # 4) Fill host_class / host_order ONLY when missing — extended with your species genome_metadata &lt;- genome_metadata %&gt;% mutate( # CLASS host_class = dplyr::case_when( !is_blank(host_class) ~ host_class, str_detect(coalesce(host_species, &quot;&quot;), &quot;Homo sapiens|Mus musculus|Rattus norvegicus|Sus scrofa|Bos taurus|Canis lupus familiaris|Barbastella barbastellus|Glauconycteris sp|Hipposideros ruber|Rhinolophus capensis|Macaca fascicularis&quot;) ~ &quot;Mammalia&quot;, str_detect(coalesce(host_species, &quot;&quot;), &quot;Gallus gallus|Cathartes aura&quot;) ~ &quot;Aves&quot;, str_detect(coalesce(host_species, &quot;&quot;), &quot;Drosophila melanogaster|Bombyx mori|Termite|Grasshopper&quot;) ~ &quot;Insecta&quot;, str_detect(coalesce(host_species, &quot;&quot;), &quot;Danio rerio|Oncorhynchus mykiss|Oreochromis niloticus|Actinopterygii&quot;) ~ &quot;Actinopterygii&quot;, TRUE ~ host_class ), # ORDER host_order = dplyr::case_when( !is_blank(host_order) ~ host_order, # Mammals str_detect(coalesce(host_species, &quot;&quot;), &quot;Homo sapiens|Macaca fascicularis&quot;) ~ &quot;Primates&quot;, str_detect(coalesce(host_species, &quot;&quot;), &quot;Mus musculus|Rattus norvegicus&quot;) ~ &quot;Rodentia&quot;, str_detect(coalesce(host_species, &quot;&quot;), &quot;Sus scrofa|Bos taurus&quot;) ~ &quot;Artiodactyla&quot;, str_detect(coalesce(host_species, &quot;&quot;), &quot;Canis lupus familiaris&quot;) ~ &quot;Carnivora&quot;, str_detect(coalesce(host_species, &quot;&quot;), &quot;Barbastella barbastellus|Glauconycteris sp|Hipposideros ruber|Rhinolophus capensis&quot;) ~ &quot;Chiroptera&quot;, # Birds str_detect(coalesce(host_species, &quot;&quot;), &quot;Gallus gallus&quot;) ~ &quot;Galliformes&quot;, # Choose one scheme and be consistent; using Accipitriformes here str_detect(coalesce(host_species, &quot;&quot;), &quot;Cathartes aura&quot;) ~ &quot;Accipitriformes&quot;, # Insects str_detect(coalesce(host_species, &quot;&quot;), &quot;Drosophila melanogaster&quot;) ~ &quot;Diptera&quot;, str_detect(coalesce(host_species, &quot;&quot;), &quot;Bombyx mori&quot;) ~ &quot;Lepidoptera&quot;, str_detect(coalesce(host_species, &quot;&quot;), &quot;Termite&quot;) ~ &quot;Isoptera&quot;, str_detect(coalesce(host_species, &quot;&quot;), &quot;Grasshopper&quot;) ~ &quot;Orthoptera&quot;, # Fish (species-level) str_detect(coalesce(host_species, &quot;&quot;), &quot;Danio rerio&quot;) ~ &quot;Cypriniformes&quot;, str_detect(coalesce(host_species, &quot;&quot;), &quot;Oncorhynchus mykiss&quot;) ~ &quot;Salmoniformes&quot;, str_detect(coalesce(host_species, &quot;&quot;), &quot;Oreochromis niloticus&quot;) ~ &quot;Cichliformes&quot;, # Generic fish remains NA (unknown order) str_detect(coalesce(host_species, &quot;&quot;), &quot;Actinopterygii \\\\(fish\\\\)&quot;) ~ NA_character_, TRUE ~ host_order ) ) %&gt;% # Drop helper column dplyr::select(-host_text) genome_metadata %&gt;% filter(is.na(host_class) | is.na(host_order) | host_class == &quot;&quot; | host_order == &quot;&quot;) %&gt;% dplyr::count(host_species, sort = TRUE) # A tibble: 3 × 2 host_species n &lt;chr&gt; &lt;int&gt; 1 Actinopterygii (fish) 3 2 Cabbage kimchi 1 3 &lt;NA&gt; 1 genome_metadata %&gt;% filter(host_species %in% c(&quot;Barbastella barbastellus&quot;, &quot;Hipposideros ruber&quot;, &quot;Glauconycteris sp&quot;, &quot;Cathartes aura&quot;, &quot;Actinopterygii (fish)&quot;, &quot;Grasshopper&quot;)) %&gt;% dplyr::count(host_species, host_class, host_order, sort = TRUE) # A tibble: 5 × 4 host_species host_class host_order n &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; 1 Cathartes aura Aves Accipitriformes 4 2 Actinopterygii (fish) Actinopterygii &lt;NA&gt; 3 3 Hipposideros ruber Mammalia Chiroptera 2 4 Barbastella barbastellus Mammalia Chiroptera 1 5 Grasshopper Insecta Orthoptera 1 library(countrycode) # 1) Simplify country strings like &quot;Country: Region&quot; genome_metadata &lt;- genome_metadata %&gt;% mutate( country_simple = str_trim(str_split_fixed(coalesce(country, &quot;&quot;), &quot;:&quot;, 2)[, 1]), country_simple = na_if(country_simple, &quot;&quot;) ) # 2) Normalization map for common ENA/NCBI variants .country_map &lt;- c( # US variants &quot;usa&quot; = &quot;United States&quot;, &quot;u\\\\.s\\\\.&quot; = &quot;United States&quot;, &quot;u\\\\.s\\\\.a\\\\.&quot; = &quot;United States&quot;, &quot;united states of america&quot; = &quot;United States&quot;, # UK variants &quot;uk&quot; = &quot;United Kingdom&quot;, &quot;u\\\\.k\\\\.&quot; = &quot;United Kingdom&quot;, &quot;great britain&quot; = &quot;United Kingdom&quot;, &quot;england&quot; = &quot;United Kingdom&quot;, &quot;scotland&quot; = &quot;United Kingdom&quot;, &quot;wales&quot; = &quot;United Kingdom&quot;, &quot;northern ireland&quot; = &quot;United Kingdom&quot;, # Korea variants &quot;korea,? republic of&quot; = &quot;South Korea&quot;, &quot;republic of korea&quot; = &quot;South Korea&quot;, &quot;south korea&quot; = &quot;South Korea&quot;, &quot;korea,? \\\\(south\\\\)&quot; = &quot;South Korea&quot;, # China variants &quot;pr china&quot; = &quot;China&quot;, &quot;p\\\\.r\\\\. china&quot; = &quot;China&quot;, # Russia variants &quot;russian federation&quot; = &quot;Russia&quot;, # Czech variants &quot;czech republic&quot; = &quot;Czechia&quot;, # Eswatini / Swaziland; Côte d’Ivoire; DRC &quot;swaziland&quot; = &quot;Eswatini&quot;, &quot;cote d[&#39;’]ivoire&quot; = &quot;Côte d’Ivoire&quot;, &quot;democratic republic of the congo&quot; = &quot;DR Congo&quot;, # Others commonly seen in ENA &quot;viet nam&quot; = &quot;Vietnam&quot;, &quot;myanmar \\\\(burma\\\\)&quot; = &quot;Myanmar&quot;, &quot;bolivia \\\\(plurinational state of\\\\)&quot; = &quot;Bolivia&quot;, &quot;iran,? islamic republic of&quot; = &quot;Iran&quot;, &quot;syrian arab republic&quot; = &quot;Syria&quot;, &quot;moldova,? republic of&quot; = &quot;Moldova&quot;, &quot;lao people&#39;?s democratic republic&quot; = &quot;Laos&quot;, &quot;macedonia,? the former yugoslav republic of&quot; = &quot;North Macedonia&quot;, &quot;palestine,? state of&quot; = &quot;Palestine&quot;, &quot;hong kong&quot; = &quot;Hong Kong&quot;, &quot;macau|macao&quot; = &quot;Macau&quot; ) # 3) Apply normalization: lowercase → map → title‑case fallback normalize_country &lt;- function(x) { y &lt;- str_trim(tolower(coalesce(x, &quot;&quot;))) y[y == &quot;&quot;] &lt;- NA_character_ # Apply regex replacements from the map (left to right) for (pat in names(.country_map)) { repl &lt;- .country_map[[pat]] y &lt;- ifelse(!is.na(y), str_replace_all(y, paste0(&quot;^&quot;, pat, &quot;$&quot;), repl), y) } # General cleanups for accents/spacing variants y &lt;- ifelse(!is.na(y), str_replace_all(y, &quot;\\\\s+&quot;, &quot; &quot;), y) y &lt;- ifelse(!is.na(y), str_replace_all(y, &quot;^people&#39;s republic of china$&quot;, &quot;China&quot;), y) # If still lowercased plain words (no mapping hit), title‑case them # (won’t fix every case, but keeps things readable) y &lt;- ifelse(!is.na(y), str_to_title(y), y) # Final tidy: replace common leftover patterns y &lt;- ifelse(!is.na(y), str_replace_all(y, &quot; And &quot;, &quot; and &quot;), y) # cosmetic y } genome_metadata &lt;- genome_metadata %&gt;% dplyr::mutate( country_normalized = normalize_country(country_simple), continent = countrycode::countrycode( sourcevar = country_normalized, origin = &quot;country.name&quot;, destination = &quot;continent&quot;, warn = TRUE ) ) Warning: There was 1 warning in `dplyr::mutate()`. ℹ In argument: `continent = countrycode::countrycode(...)`. Caused by warning: ! Some values were not matched unambiguously: None genome_metadata &lt;- genome_metadata %&gt;% # Normalize casing/whitespace for host_species mutate( host_species_norm = str_squish(host_species), host_species_norm = if_else( str_detect(str_to_lower(coalesce(host_species_norm, &quot;&quot;)), &quot;^homo\\\\s+sapiens$&quot;), &quot;Homo sapiens&quot;, # Title-case other species names to keep them tidy (optional) str_to_title(host_species_norm) ) ) %&gt;% # Human vs animal classification mutate( host_type = case_when( host_species_norm == &quot;Homo sapiens&quot; ~ &quot;human&quot;, !is.na(host_species_norm) &amp; host_species_norm != &quot;&quot; ~ &quot;animal&quot;, TRUE ~ NA_character_ ) ) %&gt;% # Keep your normalized species as the main column (optional) mutate(host_species = host_species_norm) %&gt;% dplyr::select(-host_species_norm) # Read master index master_index &lt;- read_tsv(&quot;data/mags_metadata/master_mag_index_lactococcus_lactis.tsv&quot;) %&gt;% mutate( # Extract the actual genome identifier from out_path genome_identifier = case_when( # For EHI: extract EHA00531_bin.1 from the filename str_detect(out_path, &quot;EHA&quot;) ~ str_extract(out_path, &quot;EHA[0-9]+_bin\\\\.[0-9]+&quot;), # For NCBI: use the ID as is (GCA/GCF number) TRUE ~ ID ) ) Rows: 116 Columns: 4 ── Column specification ──────────────────────────────────────────────────────────────────────────────────────── Delimiter: &quot;\\t&quot; chr (4): species, ID, MAG_url, out_path ℹ Use `spec()` to retrieve the full column specification for this data. ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. # Check the mapping print(&quot;Master index mapping:&quot;) [1] &quot;Master index mapping:&quot; master_index %&gt;% dplyr::select(ID, genome_identifier, out_path) %&gt;% head(10) %&gt;% print() # A tibble: 10 × 3 ID genome_identifier out_path &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 EHM013277 EHA00364_bin.25 data/lactococcus_lactis/mags/EHA00364_bin.25.fa.gz 2 EHM015868 EHA00350_bin.27 data/lactococcus_lactis/mags/EHA00350_bin.27.fa.gz 3 EHM016594 EHA00567_bin.9 data/lactococcus_lactis/mags/EHA00567_bin.9.fa.gz 4 EHM017294 EHA00776_bin.9 data/lactococcus_lactis/mags/EHA00776_bin.9.fa.gz 5 EHM019886 EHA00211_bin.10 data/lactococcus_lactis/mags/EHA00211_bin.10.fa.gz 6 EHM020035 EHA00169_bin.40 data/lactococcus_lactis/mags/EHA00169_bin.40.fa.gz 7 EHM025059 EHA01453_bin.48 data/lactococcus_lactis/mags/EHA01453_bin.48.fa.gz 8 EHM025679 EHA01477_bin.63 data/lactococcus_lactis/mags/EHA01477_bin.63.fa.gz 9 EHM027656 EHA01634_bin.31 data/lactococcus_lactis/mags/EHA01634_bin.31.fa.gz 10 EHM028200 EHA01709_bin.8 data/lactococcus_lactis/mags/EHA01709_bin.8.fa.gz # Read contig-to-genome mapping contig_to_genome &lt;- read_tsv(&quot;data/mags_metadata/lactococcus_lactis_contig_to_mag.tsv&quot;, col_names = c(&quot;contig&quot;, &quot;genome_filename&quot;)) Rows: 10206 Columns: 2 ── Column specification ──────────────────────────────────────────────────────────────────────────────────────── Delimiter: &quot;\\t&quot; chr (2): contig, genome_filename ℹ Use `spec()` to retrieve the full column specification for this data. ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. 4.3.4 Genome annotations # Read annotations and add IDs genome_annotations &lt;- read_tsv(&quot;data/mags_metadata/lactococcus_lactis_gene_annotations.tsv.xz&quot;) %&gt;% mutate(contig = sub(&quot;_[^_]*$&quot;, &quot;&quot;, gene)) %&gt;% left_join(contig_to_genome, by = &quot;contig&quot;) %&gt;% mutate(genome= genome_filename)%&gt;% filter(!is.na(genome)) Warning: One or more parsing issues, call `problems()` on your data frame for details, e.g.: dat &lt;- vroom(...) problems(dat) Rows: 365396 Columns: 17 ── Column specification ──────────────────────────────────────────────────────────────────────────────────────── Delimiter: &quot;\\t&quot; chr (13): gene, strand, kegg, ec, pfam, cazy, resistance_type, resistance_target, vf, vf_type, signalp, defe... dbl (2): start, end lgl (2): antidefense, antidefense_type ℹ Use `spec()` to retrieve the full column specification for this data. ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. 4.3.4.1 REMOVE MAGs that do NOT belong to the species!! (specific lactococcus, rest should be fine) # Cleaner to normalize identifiers clean_label &lt;- function(x) { x &lt;- basename(x) sub(&quot;\\\\.(fna|fa|fasta)(\\\\.gz)?$&quot;, &quot;&quot;, x, ignore.case = TRUE) } # List to remove (MAGs that belong to other species &lt;95% ANI) mags_to_remove &lt;- c( &quot;GCA_018369575.1.fna&quot;,&quot;GCA_947063445.1.fna&quot;,&quot;GCA_947101685.1.fna&quot;,&quot;GCA_948698275.1.fna&quot;, &quot;GCA_937910935.1.fna&quot;,&quot;GCA_947072755.1.fna&quot;,&quot;GCA_948655095.1.fna&quot;,&quot;GCA_948703095.1.fna&quot;, &quot;GCA_947041925.1.fna&quot;,&quot;GCA_947073355.1.fna&quot;,&quot;GCA_948675165.1.fna&quot;,&quot;GCA_948718815.1.fna&quot; ) mags_to_remove_clean &lt;- clean_label(mags_to_remove) # ---------- genome_metadata: remove + dedup (keep best per ID) ---------- stopifnot(&quot;ID&quot; %in% names(genome_metadata)) gm0 &lt;- genome_metadata %&gt;% mutate(ID_clean = clean_label(ID)) n_before_meta &lt;- nrow(gm0) n_to_remove_meta &lt;- sum(gm0$ID_clean %in% mags_to_remove_clean) genome_metadata_filtered &lt;- gm0 %&gt;% filter(!ID_clean %in% mags_to_remove_clean) has_comp &lt;- &quot;completeness&quot; %in% names(genome_metadata_filtered) has_cont &lt;- &quot;contamination&quot; %in% names(genome_metadata_filtered) has_contigs &lt;- &quot;contigs&quot; %in% names(genome_metadata_filtered) if (has_comp || has_cont || has_contigs) { genome_metadata_dedup &lt;- genome_metadata_filtered %&gt;% mutate( completeness = if (has_comp) as.numeric(completeness) else NA_real_, contamination = if (has_cont) as.numeric(contamination) else NA_real_, contigs = if (has_contigs) as.numeric(contigs) else NA_real_ ) %&gt;% arrange( ID_clean, desc(if (has_comp) completeness else 0), (if (has_cont) contamination else 0), (if (has_contigs) contigs else Inf) ) %&gt;% distinct(ID_clean, .keep_all = TRUE) } else { genome_metadata_dedup &lt;- genome_metadata_filtered %&gt;% distinct(ID_clean, .keep_all = TRUE) } genome_metadata_dedup &lt;- genome_metadata_dedup %&gt;% select(-ID_clean) # ---------- genome_annotations: ONLY filter (NO dedup) ---------- stopifnot(&quot;genome&quot; %in% names(genome_annotations)) ga0 &lt;- genome_annotations %&gt;% mutate(genome_clean = clean_label(genome)) n_before_ann &lt;- nrow(ga0) n_to_remove_ann &lt;- sum(ga0$genome_clean %in% mags_to_remove_clean) # Remove problematic genomes; keep all remaining genes genome_annotations_filtered &lt;- ga0 %&gt;% filter(!genome_clean %in% mags_to_remove_clean) %&gt;% select(-genome_clean) # ---------- report ---------- cat(&quot;genome_metadata:\\n&quot;) genome_metadata: cat(&quot; - rows before:&quot;, n_before_meta, &quot;\\n&quot;) - rows before: 129 cat(&quot; - removed by species list:&quot;, n_to_remove_meta, &quot;\\n&quot;) - removed by species list: 0 cat(&quot; - rows after remove:&quot;, nrow(genome_metadata_filtered), &quot;\\n&quot;) - rows after remove: 129 cat(&quot; - rows after dedup:&quot;, nrow(genome_metadata_dedup), &quot;\\n\\n&quot;) - rows after dedup: 129 cat(&quot;genome_annotations:\\n&quot;) genome_annotations: cat(&quot; - rows before:&quot;, n_before_ann, &quot;\\n&quot;) - rows before: 335828 cat(&quot; - removed by species list:&quot;, n_to_remove_ann, &quot;\\n&quot;) - removed by species list: 0 cat(&quot; - rows after remove:&quot;, nrow(genome_annotations_filtered), &quot;\\n&quot;) - rows after remove: 335828 # (optional) assign back genome_metadata &lt;- genome_metadata_dedup genome_annotations &lt;- genome_annotations_filtered 4.3.5 Distill annotations into GIFTs genome_gifts &lt;- distill(genome_annotations,GIFT_db,genomecol= 19, annotcol=c(5,6,7,8), verbosity = F) Identifiers in the annotation table: 1293 Identifiers in the database: 1547 Identifiers in both: 148 Percentage of annotation table identifiers used for distillation: 11.45% Percentage of database identifiers used for distillation: 9.57% 4.3.6 Load trees genome_metadata$mag_name &lt;- sub(&quot;\\\\.fa$&quot;, &quot;&quot;, genome_metadata$mag_name)#remove .fa from the mag names so that they match the tree ids "],["data-statistics.html", "Chapter 5 Data Statistics", " Chapter 5 Data Statistics Total number of MAGs genome_metadata %&gt;% dplyr::count(source) # A tibble: 3 × 2 source n &lt;chr&gt; &lt;int&gt; 1 EHI 38 2 GTDB 78 3 NCBI 13 genome_metadata %&gt;% dplyr::count(host_species) # A tibble: 25 × 2 host_species n &lt;chr&gt; &lt;int&gt; 1 Actinopterygii (Fish) 3 2 Barbastella Barbastellus 1 3 Bombyx Mori 1 4 Cabbage Kimchi 1 5 Canis Lupus 4 6 Cathartes Aura 4 7 Drosophila Melanogaster 1 8 Grasshopper 1 9 Hipposideros Ruber 2 10 Homo sapiens 42 # ℹ 15 more rows genome_metadata %&gt;% dplyr::count(host_order) # A tibble: 13 × 2 host_order n &lt;chr&gt; &lt;int&gt; 1 Accipitriformes 4 2 Blattodea 1 3 Carnivora 4 4 Chiroptera 26 5 Cichliformes 1 6 Diptera 1 7 Lepidoptera 1 8 Orthoptera 1 9 Primates 43 10 Rodentia 36 11 Salmoniformes 1 12 Squamata 5 13 &lt;NA&gt; 5 genome_metadata %&gt;% dplyr::count(host_class) # A tibble: 6 × 2 host_class n &lt;chr&gt; &lt;int&gt; 1 Actinopterygii 5 2 Aves 4 3 Insecta 4 4 Mammalia 109 5 Reptilia 5 6 &lt;NA&gt; 2 5.0.1 Remove the MAGs with no host metadata genome_metadata &lt;- genome_metadata %&gt;% filter(!is.na(host_class)) 5.0.2 Mean completeness and contamination genome_metadata %&gt;% summarise( mean_c = mean(completeness, na.rm = TRUE) %&gt;% round(2), sd_c = sd(completeness, na.rm = TRUE) %&gt;% round(2), mean_con = mean(contamination, na.rm = TRUE) %&gt;% round(2), sd_con = sd(contamination, na.rm = TRUE) %&gt;% round(2) ) %&gt;% unite(&quot;Completeness&quot;, mean_c, sd_c, sep = &quot; ± &quot;) %&gt;% unite(&quot;Contamination&quot;, mean_con, sd_con, sep = &quot; ± &quot;) %&gt;% tt() .table td.tinytable_css_lanisen8rgqtpzriz846, .table th.tinytable_css_lanisen8rgqtpzriz846 { border-bottom: solid #d3d8dc 0.1em; } .table td.tinytable_css_xb91g8im5t6g24ax6noq, .table th.tinytable_css_xb91g8im5t6g24ax6noq { border-top: solid #d3d8dc 0.1em; border-bottom: solid #d3d8dc 0.05em; } Completeness Contamination 99.12 ± 2.05 0.64 ± 0.61 #Generate quality biplot genome_biplot &lt;- genome_metadata %&gt;% dplyr::select(c(ID,completeness,contamination, host_order)) %&gt;% ggplot(aes(x=completeness,y=contamination, color = host_order)) + scale_color_manual(values = host_order_colors, name = &quot;Host Order&quot;)+ geom_point(alpha=0.7, size = 4) + xlim(c(90,100)) + ylim(c(2.5,0)) + labs(y= &quot;Contamination&quot;, x = &quot;Completeness&quot;) + theme_classic() + theme(legend.position = &quot;left&quot;, axis.text.y = element_text(size=12), axis.text.x = element_text(size=12), axis.title.x = element_text(size = 16, face = &quot;bold&quot;), axis.title.y = element_text(size = 16, face = &quot;bold&quot;)) #Generate contamination boxplot genome_contamination &lt;- genome_metadata %&gt;% ggplot(aes(y=contamination)) + ylim(c(2.5,0)) + geom_boxplot(colour = &quot;#999999&quot;, fill=&quot;#cccccc&quot;) + theme_classic() + theme(legend.position = &quot;none&quot;, axis.line = element_blank(), axis.title = element_blank(), axis.text=element_blank(), axis.ticks=element_blank(), plot.margin = unit(c(0, 0, 0.40, 0),&quot;inches&quot;)) #add bottom-margin (top, right, bottom, left) #Generate completeness boxplot genome_completeness &lt;- genome_metadata %&gt;% ggplot(aes(x=completeness)) + xlim(c(90,100)) + geom_boxplot(colour = &quot;#999999&quot;, fill=&quot;#cccccc&quot;) + theme_classic() + theme(legend.position = &quot;none&quot;, axis.line = element_blank(), axis.title = element_blank(), axis.text=element_blank(), axis.ticks=element_blank(), plot.margin = unit(c(0, 0, 0, 0.50),&quot;inches&quot;)) #add left-margin (top, right, bottom, left) #Render composite figure #pdf(&quot;figures/completeness_contamination.pdf&quot;,width=10, height=5) grid.arrange(grobs = list(genome_completeness,genome_biplot,genome_contamination), layout_matrix = rbind(c(1,1,1,1,1,1,1,1,1,1,1,4), c(2,2,2,2,2,2,2,2,2,2,2,3), c(2,2,2,2,2,2,2,2,2,2,2,3), c(2,2,2,2,2,2,2,2,2,2,2,3), c(2,2,2,2,2,2,2,2,2,2,2,3), c(2,2,2,2,2,2,2,2,2,2,2,3), c(2,2,2,2,2,2,2,2,2,2,2,3), c(2,2,2,2,2,2,2,2,2,2,2,3), c(2,2,2,2,2,2,2,2,2,2,2,3), c(2,2,2,2,2,2,2,2,2,2,2,3), c(2,2,2,2,2,2,2,2,2,2,2,3), c(2,2,2,2,2,2,2,2,2,2,2,3))) #dev.off() ggplot(genome_metadata, aes(x= ID, y = genome_size, fill = host_order))+ scale_fill_manual(values = host_order_colors)+ geom_col()+ theme_classic() ggplot(genome_metadata, aes(x= source, y = genome_size, fill = source))+ scale_fill_manual(values = source_colors)+ geom_violin()+ geom_point()+ theme_classic()+ labs(y = &quot;Genome Size&quot;, x = &quot;Source&quot;) genome_metadata %&gt;% filter(!is.na(host_class)) %&gt;% ggplot(aes(x= host_type, y = genome_size, fill = host_type))+ scale_fill_manual(values = host_type_colors)+ geom_violin()+ geom_point()+ theme_classic()+ labs(y = &quot;Genome Size&quot;, x = &quot;Host Type&quot;) Warning: Groups with fewer than two datapoints have been dropped. ℹ Set `drop = FALSE` to consider such groups for position adjustment purposes. genome_metadata%&gt;% filter(genome_size == min(genome_size)) # A tibble: 1 × 45 ID source species gtdb_taxonomy host_species host_order host_class isolation_source host host_summary &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; 1 EHM066683 EHI s__Lact… &lt;NA&gt; Plecotus Au… Chiroptera Mammalia host-associated &lt;NA&gt; NA # ℹ 35 more variables: country &lt;chr&gt;, locality &lt;chr&gt;, completeness &lt;dbl&gt;, contamination &lt;dbl&gt;, # genome_size &lt;dbl&gt;, GC &lt;dbl&gt;, N50 &lt;dbl&gt;, contigs &lt;dbl&gt;, collection_date &lt;chr&gt;, ncbi_biosample &lt;chr&gt;, # mag_name &lt;chr&gt;, eha_number &lt;chr&gt;, gtdb_representative &lt;lgl&gt;, mimag_high_quality &lt;lgl&gt;, # mimag_medium_quality &lt;lgl&gt;, common_name &lt;chr&gt;, sample_name &lt;chr&gt;, external_id &lt;chr&gt;, submitter_id &lt;chr&gt;, # env_broad &lt;chr&gt;, env_medium &lt;chr&gt;, env_local &lt;chr&gt;, env_local_context &lt;chr&gt;, host_status &lt;lgl&gt;, # disease &lt;lgl&gt;, diagnosis &lt;lgl&gt;, latitude &lt;dbl&gt;, longitude &lt;dbl&gt;, accession &lt;chr&gt;, host_disease &lt;lgl&gt;, # host_age &lt;lgl&gt;, host_type &lt;chr&gt;, country_simple &lt;chr&gt;, country_normalized &lt;chr&gt;, continent &lt;chr&gt; ggplot(genome_metadata, aes(x= ID, y = contamination, fill = source))+ scale_fill_manual(values = source_colors)+ geom_col()+ theme_classic() ggplot(genome_metadata, aes(x= source, y = contamination, fill = source))+ scale_fill_manual(values = source_colors)+ geom_boxplot()+ theme_classic()+ labs(y = &quot;Contamination&quot;, x = &quot;Source&quot;) ggplot(genome_metadata, aes(x= ID, y = completeness, fill = source))+ scale_fill_manual(values = source_colors)+ geom_col()+ theme_classic() ggplot(genome_metadata, aes(x= source, y = completeness, fill = source))+ scale_fill_manual(values = source_colors)+ geom_violin()+ geom_point()+ theme_classic()+ labs(y = &quot;Completeness&quot;, x = &quot;Source&quot;) ggplot(genome_metadata, aes(x= host_type, y = completeness, fill = host_type))+ scale_fill_manual(values = host_type_colors)+ geom_violin()+ geom_point()+ theme_classic()+ labs(y = &quot;Completeness&quot;, x = &quot;Host Type&quot;) Warning: Groups with fewer than two datapoints have been dropped. ℹ Set `drop = FALSE` to consider such groups for position adjustment purposes. genome_metadata_long &lt;- genome_metadata %&gt;% filter(!is.na(host_class))%&gt;% mutate(genome_size_mb = genome_size/10^6)%&gt;% pivot_longer( cols = c(genome_size_mb, contamination, completeness), names_to = &quot;metric&quot;, values_to = &quot;value&quot; ) %&gt;% mutate( metric = factor(metric, levels = c(&quot;genome_size_mb&quot;,&quot;contamination&quot; , &quot;completeness&quot;), labels = c(&quot;Genome Size (Mb)&quot;, &quot;Contamination (%)&quot; , &quot;Completeness (%)&quot;)) ) faceted_plot &lt;- ggplot(genome_metadata_long, aes(x = source, y = value, fill = source)) + scale_fill_manual(values = source_colors) + geom_violin() + geom_point() + facet_wrap(~ metric, scales = &quot;free_y&quot;, ncol = 2) + theme_classic() + theme( strip.background = element_rect(fill = &quot;white&quot;, color = &quot;black&quot;), strip.text = element_text(face = &quot;bold&quot;, size = 11) ) + labs(y = &quot;Value&quot;, x = &quot;Source&quot;, fill = &quot;Source&quot;) print(faceted_plot) faceted_plot &lt;- ggplot(genome_metadata_long, aes(x = host_type, y = value, fill = host_type)) + scale_fill_manual(values = host_type_colors) + geom_violin() + geom_point() + facet_wrap(~ metric, scales = &quot;free_y&quot;, ncol = 2) + theme_classic() + theme( strip.background = element_rect(fill = &quot;white&quot;, color = &quot;black&quot;), strip.text = element_text(face = &quot;bold&quot;, size = 11) ) + labs(y = &quot;Value&quot;, x = &quot;Source&quot;, fill = &quot;Host Type&quot;) print(faceted_plot) Warning: Groups with fewer than two datapoints have been dropped. ℹ Set `drop = FALSE` to consider such groups for position adjustment purposes. Groups with fewer than two datapoints have been dropped. ℹ Set `drop = FALSE` to consider such groups for position adjustment purposes. Groups with fewer than two datapoints have been dropped. ℹ Set `drop = FALSE` to consider such groups for position adjustment purposes. #Comparing animal vs human wilcox.test(contamination ~ host_type, data=genome_metadata) %&gt;% tidy() # A tibble: 1 × 4 statistic p.value method alternative &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 1 1738 0.895 Wilcoxon rank sum test with continuity correction two.sided wilcox.test(completeness ~ host_type, data=genome_metadata) %&gt;% tidy() # A tibble: 1 × 4 statistic p.value method alternative &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 1 1207 0.00207 Wilcoxon rank sum test with continuity correction two.sided wilcox.test(genome_size ~ host_type, data=genome_metadata) %&gt;% tidy() # A tibble: 1 × 4 statistic p.value method alternative &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 1 1042 0.000189 Wilcoxon rank sum test with continuity correction two.sided #Comparing sources kruskal.test(contamination ~ source, data=genome_metadata) %&gt;% tidy() # A tibble: 1 × 4 statistic p.value parameter method &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;chr&gt; 1 3.92 0.141 2 Kruskal-Wallis rank sum test kruskal.test(completeness ~ source, data=genome_metadata) %&gt;% tidy() # A tibble: 1 × 4 statistic p.value parameter method &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;chr&gt; 1 16.1 0.000314 2 Kruskal-Wallis rank sum test kruskal.test(genome_size ~ source, data=genome_metadata) %&gt;% tidy() # A tibble: 1 × 4 statistic p.value parameter method &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;chr&gt; 1 5.75 0.0563 2 Kruskal-Wallis rank sum test # Combine the summaries ehi_stats &lt;- genome_metadata %&gt;% filter(host_type == &quot;animal&quot;) %&gt;% mutate(genome_size_mb = genome_size/1000000) %&gt;% summarise( m_gs = round(mean(genome_size_mb), 2), sd_gs = round(sd(genome_size_mb), 2), m_cont = round(mean(contamination), 2), sd_cont = round(sd(contamination), 2), m_comp = round(mean(completeness), 2), sd_comp = round(sd(completeness), 2) ) %&gt;% unite(&quot;Mean genome size&quot;,m_gs, sd_gs, sep = &quot; ± &quot;, remove = TRUE) %&gt;% unite(&quot;Mean completeness&quot;,m_comp, sd_comp, sep = &quot; ± &quot;, remove = TRUE) %&gt;% unite(&quot;Mean contamination&quot;,m_cont, sd_cont, sep = &quot; ± &quot;, remove = TRUE) %&gt;% mutate(Host_type = &quot;animal&quot;) %&gt;% dplyr::select(Host_type, everything()) gtdb_stats &lt;- genome_metadata %&gt;% filter(host_type == &quot;human&quot;) %&gt;% filter(!is.na(genome_size)) %&gt;% mutate(genome_size_mb = genome_size/1000000) %&gt;% summarise( m_gs = round(mean(genome_size_mb), 2), sd_gs = round(sd(genome_size_mb), 2), m_cont = round(mean(contamination), 2), sd_cont = round(sd(contamination), 2), m_comp = round(mean(completeness), 2), sd_comp = round(sd(completeness), 2) ) %&gt;% unite(&quot;Mean genome size&quot;,m_gs, sd_gs, sep = &quot; ± &quot;, remove = TRUE) %&gt;% unite(&quot;Mean completeness&quot;,m_comp, sd_comp, sep = &quot; ± &quot;, remove = TRUE) %&gt;% unite(&quot;Mean contamination&quot;,m_cont, sd_cont, sep = &quot; ± &quot;, remove = TRUE) %&gt;% mutate(Host_type = &quot;human&quot;) %&gt;% dplyr::select(Host_type, everything()) # Combine into one table summary_table &lt;- bind_rows(ehi_stats, gtdb_stats) summary_table # A tibble: 2 × 4 Host_type `Mean genome size` `Mean contamination` `Mean completeness` &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 animal 2.37 ± 0.24 0.66 ± 0.65 98.84 ± 2.37 2 human 2.46 ± 0.11 0.57 ± 0.5 99.66 ± 1 5.0.3 Country library(rnaturalearth) Warning: package &#39;rnaturalearth&#39; was built under R version 4.4.3 library(rnaturalearthdata) Warning: package &#39;rnaturalearthdata&#39; was built under R version 4.4.3 Adjuntando el paquete: &#39;rnaturalearthdata&#39; The following object is masked from &#39;package:rnaturalearth&#39;: countries110 library(sf) Warning: package &#39;sf&#39; was built under R version 4.4.3 Linking to GEOS 3.13.0, GDAL 3.10.1, PROJ 9.5.1; sf_use_s2() is TRUE world &lt;- ne_countries(scale = &quot;medium&quot;, returnclass = &quot;sf&quot;) mag_locations &lt;- genome_metadata %&gt;% filter(!is.na(country)) %&gt;% left_join( world %&gt;% dplyr::select(name, geometry) %&gt;% st_centroid() %&gt;% st_coordinates() %&gt;% as_tibble() %&gt;% bind_cols(world %&gt;% dplyr::select(name)) , by = c(&quot;country&quot; = &quot;name&quot;) ) Warning: st_centroid assumes attributes are constant over geometries mag_locations%&gt;% dplyr::select(ID, host_type, country) # A tibble: 127 × 3 ID host_type country &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 EHM013277 animal France 2 EHM015868 animal France 3 EHM016594 animal Equatorial Guinea 4 EHM017294 animal Spain 5 EHM019886 animal Norway 6 EHM020035 animal Germany 7 EHM025059 animal France 8 EHM025679 animal France 9 EHM027656 animal United States 10 EHM028200 animal United States # ℹ 117 more rows ggplot(world) + geom_sf(fill = &quot;gray95&quot;, color = &quot;gray80&quot;) + geom_point( data = mag_locations, aes(x = X, y = Y, color = host_type), size = 2.5, alpha = 0.5 ) + scale_color_manual(values = host_type_colors) + theme_minimal() + labs(color = &quot;Host Type&quot;) Warning: Removed 95 rows containing missing values or values outside the scale range (`geom_point()`). plot_df &lt;- genome_metadata %&gt;% dplyr::filter(!is.na(host_species), !is.na(host_class)) species_plot &lt;- ggplot(plot_df, aes(x = host_species, fill = source)) + geom_bar(position = &quot;stack&quot;) + facet_wrap(~ host_class, scales = &quot;free_x&quot;) + scale_fill_manual(values = source_colors, name = &quot;Source&quot;) + theme_bw(base_size = 14) + theme( axis.text.x = element_text(angle = 45, hjust = 1), axis.title.x = element_text(size = 16), axis.title.y = element_text(size = 16), strip.text = element_text(size = 14, face = &quot;bold&quot;) ) + labs( x = &quot;Host species&quot;, y = &quot;Number of MAGs&quot; ) species_plot #ggsave(&quot;./plots/species_plot.png&quot;, species_plot, dpi = 300, units = &quot;cm&quot;, width = 18, height = 10) plot_df &lt;- genome_metadata %&gt;% dplyr::filter(!is.na(country_normalized))%&gt;% dplyr::filter(country_normalized != &quot;none&quot;) library(stringr) dist_plot &lt;- ggplot(plot_df, aes(x = country_normalized, fill = host_order)) + geom_bar(position = &quot;stack&quot;) + facet_grid( ~ continent, scales = &quot;free_x&quot;, space = &quot;free_x&quot;, labeller = labeller( continent = function(x) str_wrap(x, width = 10) ) ) + scale_fill_manual(values = host_order_colors, name = &quot;Host order&quot;) + theme_bw(base_size = 14) + theme( axis.text.x = element_text(angle = 45, hjust = 1), axis.title.x = element_text(size = 16), axis.title.y = element_text(size = 16), strip.text = element_text(size = 12, face = &quot;bold&quot;) ) + labs( x = &quot;Country&quot;, y = &quot;Number of MAGs&quot; ) dist_plot #ggsave(&quot;./plots/dist_plot.png&quot;, dist_plot, dpi = 300, units = &quot;cm&quot;, width = 30, height = 12) "],["phylogenetic-analysis.html", "Chapter 6 Phylogenetic analysis 6.1 dRep tree", " Chapter 6 Phylogenetic analysis 6.1 dRep tree fastani_comparisons &lt;- read_csv(&quot;data/mags_metadata/lactococcus_lactis_Ndb.csv&quot;) #Secondary comparison results Rows: 19600 Columns: 5 ── Column specification ──────────────────────────────────────────────────────────────────────────────────────── Delimiter: &quot;,&quot; chr (2): reference, querry dbl (3): ani, alignment_coverage, primary_cluster ℹ Use `spec()` to retrieve the full column specification for this data. ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. genomes &lt;- unique(c(fastani_comparisons$reference, fastani_comparisons$querry)) # Create empty matrix ani_matrix &lt;- matrix(0, nrow = length(genomes), ncol = length(genomes)) rownames(ani_matrix) &lt;- genomes colnames(ani_matrix) &lt;- genomes # Fill the matrix for(i in 1:nrow(fastani_comparisons)) { ref &lt;- fastani_comparisons$reference[i] qry &lt;- fastani_comparisons$querry[i] ani_val &lt;- fastani_comparisons$ani[i] ani_matrix[ref, qry] &lt;- ani_val ani_matrix[qry, ref] &lt;- ani_val # Make symmetric } # Set diagonal to 100 diag(ani_matrix) &lt;- 100 # Convert to distance matrix (for tree building) dist_matrix &lt;- as.dist(1 - ani_matrix) # Build tree hc &lt;- hclust(dist_matrix, method = &quot;average&quot;) #drep uses hierarchical clustering tree &lt;- as.phylo(hc) ggtree(tree) + geom_tiplab(size = 2) + theme_tree2() Warning in fortify(data, ...): Arguments in `...` must be used. ✖ Problematic arguments: • as.Date = as.Date • yscale_mapping = yscale_mapping • hang = hang ℹ Did you misspell an argument name? Found more than one class &quot;phylo&quot; in cache; using the first, from namespace &#39;phyloseq&#39; Also defined by &#39;tidytree&#39; fastani_path &lt;- &quot;data/mags_metadata/lactococcus_lactis_Ndb.csv&quot; metadata &lt;- genome_metadata id_col &lt;- &quot;ID&quot; # Drop any outliers or specific IDs (use IDs without file suffix) drop_ids &lt;- character(0) # Impute missing ANI pairs # &quot;max_distance&quot; (most conservative), &quot;min_ani&quot;, or a fixed numeric between 0 and 1 impute_mode &lt;- &quot;max_distance&quot; # helper: strip file extensions so IDs match metadata clean_label &lt;- function(x) { x &lt;- basename(x) sub(&quot;\\\\.(fna|fa|fasta)(\\\\.gz)?$&quot;, &quot;&quot;, x, ignore.case = TRUE) } # Load &amp; normalize fastani table fastani_raw &lt;- readr::read_csv(fastani_path, show_col_types = FALSE) fastani &lt;- fastani_raw %&gt;% dplyr::rename( reference = dplyr::any_of(c(&quot;reference&quot;, &quot;ref&quot;, &quot;Reference&quot;)), query = dplyr::any_of(c(&quot;query&quot;, &quot;querry&quot;, &quot;Qry&quot;, &quot;Query&quot;)), ani = dplyr::any_of(c(&quot;ani&quot;, &quot;ANI&quot;, &quot;ani_1&quot;, &quot;ANI_1&quot;)) ) %&gt;% dplyr::select(reference, query, ani) %&gt;% dplyr::filter(!is.na(reference), !is.na(query), reference != query) # Normalize ANI to [0,1] if needed ani_max &lt;- max(fastani$ani, na.rm = TRUE) if (is.finite(ani_max) &amp;&amp; ani_max &gt; 1) { fastani &lt;- fastani %&gt;% dplyr::mutate(ani = ani / 100) } # Clean IDs to remove extensions fastani &lt;- fastani %&gt;% dplyr::mutate( reference = clean_label(reference), query = clean_label(query) ) %&gt;% dplyr::filter(reference != query) # Remove duplicate pairs (keep the max ANI per pair) fastani &lt;- fastani %&gt;% dplyr::group_by(reference, query) %&gt;% dplyr::summarise(ani = max(ani), .groups = &quot;drop&quot;) # Optionally drop genomes (IDs without suffix) if (length(drop_ids) &gt; 0) { fastani &lt;- fastani %&gt;% dplyr::filter(!reference %in% drop_ids, !query %in% drop_ids) } # Build a symmetric ANI matrix with diag = 1 (dedup-safe) build_ani_matrix &lt;- function(df) { genomes &lt;- sort(unique(c(df$reference, df$query))) both &lt;- dplyr::bind_rows( df %&gt;% dplyr::transmute(reference, query, ani), df %&gt;% dplyr::transmute(reference = query, query = reference, ani) ) %&gt;% dplyr::distinct(reference, query, .keep_all = TRUE) ani_mat &lt;- both %&gt;% tidyr::complete(reference = genomes, query = genomes) %&gt;% tidyr::pivot_wider( names_from = query, values_from = ani, values_fn = max # &lt;-- ensure no duplicate cells cause errors ) %&gt;% tibble::column_to_rownames(&quot;reference&quot;) %&gt;% as.matrix() diag(ani_mat) &lt;- 1 # Impute missing if any if (anyNA(ani_mat)) { if (impute_mode == &quot;max_distance&quot;) { fill_val &lt;- min(ani_mat, na.rm = TRUE) } else if (impute_mode == &quot;min_ani&quot;) { fill_val &lt;- min(ani_mat, na.rm = TRUE) } else if (is.numeric(impute_mode) &amp;&amp; impute_mode &gt;= 0 &amp;&amp; impute_mode &lt;= 1) { fill_val &lt;- impute_mode } else { fill_val &lt;- min(ani_mat, na.rm = TRUE) } ani_mat[is.na(ani_mat)] &lt;- fill_val } ani_mat } ani_mat &lt;- build_ani_matrix(fastani) # Build the tree (UPGMA/average as in dRep) build_tree_from_ani &lt;- function(ani_mat, method = &quot;average&quot;) { dist_mat &lt;- 1 - ani_mat hc &lt;- hclust(as.dist(dist_mat), method = method) ape::as.phylo(hc) } tree &lt;- build_tree_from_ani(ani_mat) # De-duplicate metadata by ID and clean ID if needed metadata_dedup &lt;- metadata %&gt;% dplyr::mutate(!!id_col := clean_label(.data[[id_col]])) %&gt;% # safe if already clean dplyr::distinct(.data[[id_col]], .keep_all = TRUE) # Add metadata to tips (tree labels are already clean IDs) make_tip_df &lt;- function(tree, metadata_dedup, id_col) { stopifnot(id_col %in% names(metadata_dedup)) tibble::tibble(label = tree$tip.label) %&gt;% dplyr::left_join(metadata_dedup, by = setNames(id_col, &quot;label&quot;)) %&gt;% dplyr::mutate(label_clean = label) # keep a consistent column if you use it in labels } tip_df &lt;- make_tip_df(tree, metadata_dedup, id_col = id_col) # Helper for ANI axis labels (unchanged) ani_axis &lt;- function(p, tree, show_threshold = NULL) { df &lt;- ggtree::fortify(tree) max_x &lt;- max(df$x[df$isTip]) p &lt;- p + scale_x_continuous( labels = function(x) round(100 * (1 - (max_x - x)), 1) ) + coord_cartesian(xlim = c(0, max_x + 0.005)) + labs(x = &quot;Average Nucleotide Identity (ANI, %)&quot;) + theme_tree2() if (!is.null(show_threshold)) { thr_delta &lt;- 1 - (show_threshold / 100) p &lt;- p + geom_vline(xintercept = max_x - thr_delta, linetype = &quot;dashed&quot;, color = &quot;red&quot;, size = 0.8) } p } # - BASIC PLOT -- plot_tree_basic &lt;- function(tree, tip_df, color_by = NULL, label_tips = TRUE, point_size = 2.5, show_threshold = NULL) { # ensure completeness numeric for continuous gradients if (&quot;completeness&quot; %in% names(tip_df)) { tip_df &lt;- tip_df %&gt;% dplyr::mutate(completeness = as.numeric(completeness)) } p &lt;- ggtree(tree, size = 0.8) p &lt;- p %&lt;+% tip_df if (!is.null(color_by) &amp;&amp; color_by %in% names(tip_df)) { p &lt;- p + geom_tippoint(aes(color = !!rlang::sym(color_by)), size = point_size) # Palette/scale logic if (identical(color_by, &quot;source&quot;) &amp;&amp; exists(&quot;source_colors&quot;)) { p &lt;- p + scale_color_manual(values = source_colors, name = &quot;Source&quot;, drop = FALSE) } else if (identical(color_by, &quot;host_order&quot;) &amp;&amp; exists(&quot;host_order_colors&quot;)) { p &lt;- p + scale_color_manual(values = host_order_colors, name = &quot;Host order&quot;, drop = FALSE) } else if (is.numeric(tip_df[[color_by]])) { p &lt;- p + scale_color_gradient(low = &quot;white&quot;, high = &quot;#08306B&quot;, name = paste0(color_by, &quot; (%)&quot;)) } } else { p &lt;- p + geom_tippoint(size = point_size) } if (label_tips) { lab_col &lt;- if (&quot;label_clean&quot; %in% names(tip_df)) &quot;label_clean&quot; else &quot;label&quot; p &lt;- p + geom_tiplab(size = 3, hjust = -0.1, aes(label = .data[[lab_col]])) } ani_axis(p, tree, show_threshold = show_threshold) } # - MULTI-AESTHETIC PLOT -- plot_tree_multi &lt;- function(tree, tip_df, color_by = NULL, shape_by = NULL, size_by = NULL, label_tips = TRUE, show_threshold = NULL) { if (&quot;completeness&quot; %in% names(tip_df)) { tip_df &lt;- tip_df %&gt;% dplyr::mutate(completeness = as.numeric(completeness)) } p &lt;- ggtree(tree, size = 0.8) p &lt;- p %&lt;+% tip_df aes_map &lt;- aes() if (!is.null(color_by) &amp;&amp; color_by %in% names(tip_df)) aes_map &lt;- modifyList(aes_map, aes(color = !!rlang::sym(color_by))) if (!is.null(shape_by) &amp;&amp; shape_by %in% names(tip_df)) aes_map &lt;- modifyList(aes_map, aes(shape = !!rlang::sym(shape_by))) if (!is.null(size_by) &amp;&amp; size_by %in% names(tip_df)) aes_map &lt;- modifyList(aes_map, aes(size = !!rlang::sym(size_by))) p &lt;- p + geom_tippoint(aes_map, stroke = 0.3) if (!is.null(color_by) &amp;&amp; color_by %in% names(tip_df)) { if (identical(color_by, &quot;source&quot;) &amp;&amp; exists(&quot;source_colors&quot;)) { p &lt;- p + scale_color_manual(values = source_colors, name = &quot;Source&quot;, drop = FALSE) } else if (identical(color_by, &quot;host_order&quot;) &amp;&amp; exists(&quot;host_order_colors&quot;)) { p &lt;- p + scale_color_manual(values = host_order_colors, name = &quot;Host order&quot;, drop = FALSE) } else if (is.numeric(tip_df[[color_by]])) { p &lt;- p + scale_color_gradient(low = &quot;white&quot;, high = &quot;#08306B&quot;, name = paste0(color_by, &quot; (%)&quot;)) } } if (label_tips) { lab_col &lt;- if (&quot;label_clean&quot; %in% names(tip_df)) &quot;label_clean&quot; else &quot;label&quot; p &lt;- p + geom_tiplab(size = 3, hjust = -0.1, aes(label = .data[[lab_col]])) } ani_axis(p, tree, show_threshold = show_threshold) } p_source &lt;- plot_tree_basic(tree, tip_df, color_by = &quot;source&quot;, label_tips = TRUE, show_threshold = 99.5) Warning in fortify(data, ...): Arguments in `...` must be used. ✖ Problematic arguments: • as.Date = as.Date • yscale_mapping = yscale_mapping • hang = hang • size = 0.8 ℹ Did you misspell an argument name? Found more than one class &quot;phylo&quot; in cache; using the first, from namespace &#39;phyloseq&#39; Also defined by &#39;tidytree&#39; p_source p_host &lt;- plot_tree_basic(tree, tip_df, color_by = &quot;host_species&quot;, label_tips = TRUE, show_threshold = 99.5) Warning in fortify(data, ...): Arguments in `...` must be used. ✖ Problematic arguments: • as.Date = as.Date • yscale_mapping = yscale_mapping • hang = hang • size = 0.8 ℹ Did you misspell an argument name? Found more than one class &quot;phylo&quot; in cache; using the first, from namespace &#39;phyloseq&#39; Also defined by &#39;tidytree&#39; p_host p_host_order &lt;- plot_tree_basic(tree, tip_df, color_by = &quot;host_order&quot;, label_tips = TRUE, show_threshold = 99.5) Warning in fortify(data, ...): Arguments in `...` must be used. ✖ Problematic arguments: • as.Date = as.Date • yscale_mapping = yscale_mapping • hang = hang • size = 0.8 ℹ Did you misspell an argument name? Found more than one class &quot;phylo&quot; in cache; using the first, from namespace &#39;phyloseq&#39; Also defined by &#39;tidytree&#39; p_host_order p_continent &lt;- plot_tree_basic(tree, tip_df, color_by = &quot;continent&quot;, label_tips = TRUE, show_threshold = 99.5) Warning in fortify(data, ...): Arguments in `...` must be used. ✖ Problematic arguments: • as.Date = as.Date • yscale_mapping = yscale_mapping • hang = hang • size = 0.8 ℹ Did you misspell an argument name? Found more than one class &quot;phylo&quot; in cache; using the first, from namespace &#39;phyloseq&#39; Also defined by &#39;tidytree&#39; p_continent # Color tips by completeness (0–100; 100 = dark blue, 0 = white) p_comp &lt;- plot_tree_basic(tree, tip_df, color_by = &quot;completeness&quot;, label_tips = TRUE, show_threshold = 99.5) Warning in fortify(data, ...): Arguments in `...` must be used. ✖ Problematic arguments: • as.Date = as.Date • yscale_mapping = yscale_mapping • hang = hang • size = 0.8 ℹ Did you misspell an argument name? Found more than one class &quot;phylo&quot; in cache; using the first, from namespace &#39;phyloseq&#39; Also defined by &#39;tidytree&#39; p_comp p_multi &lt;- plot_tree_multi( tree, tip_df, color_by = &quot;host_order&quot;, size_by = &quot;completeness&quot;, label_tips = TRUE, show_threshold = 99.5 ) Warning in fortify(data, ...): Arguments in `...` must be used. ✖ Problematic arguments: • as.Date = as.Date • yscale_mapping = yscale_mapping • hang = hang • size = 0.8 ℹ Did you misspell an argument name? Found more than one class &quot;phylo&quot; in cache; using the first, from namespace &#39;phyloseq&#39; Also defined by &#39;tidytree&#39; p_multi Warning: Removed 90 rows containing missing values or values outside the scale range (`geom_point_g_gtree()`). ggsave(&quot;plots/tree_by_source.png&quot;, p_source, width = 10, height = 8, dpi = 300) ggsave(&quot;plots/tree_by_host.png&quot;, p_host, width = 10, height = 8, dpi = 300) ggsave(&quot;plots/tree_combo.png&quot;, p_combo, width = 12, height = 9, dpi = 300) ggsave(&quot;plots/tree_full_heatmap.png&quot;, p_full, width = 12, height = 10, dpi = 300) "],["functional-analysis.html", "Chapter 7 Functional Analysis 7.1 Functional overview 7.2 KEGG 7.3 GIFTs", " Chapter 7 Functional Analysis 7.1 Functional overview n_genes &lt;- genome_annotations %&gt;% group_by(genome) %&gt;% summarize(n_genes = n()) head(n_genes) # A tibble: 6 × 2 genome n_genes &lt;chr&gt; &lt;int&gt; 1 EHM013277 2223 2 EHM015868 2322 3 EHM016594 2131 4 EHM017294 2516 5 EHM019886 2410 6 EHM020035 2296 7.1.0.1 Predicted genes pred_genes &lt;- genome_annotations %&gt;% nrow() cat(pred_genes) 335828 7.1.0.2 Number of annotated genes and percentages #How many genes have at least 1 annotation genome_annota &lt;- genome_annotations %&gt;% filter(if_any(c(kegg, pfam, cazy), ~ !is.na(.))) %&gt;% nrow() cat(genome_annota) 281627 #Percentage of predicted genes with at least 1 annotation genome_annota*100/pred_genes [1] 83.86049 7.1.0.3 Number of KEGG annotatated genes and percentages # KEGG annotation kegg_annota &lt;- genome_annotations %&gt;% filter(!is.na(kegg)) %&gt;% nrow() cat(kegg_annota) 235205 # KEGG annotation percentage kegg_annota*100/genome_annota [1] 83.5165 # AMR annotation amr_annota &lt;- genome_annotations %&gt;% filter(resistance_type == &quot;AMR&quot;) %&gt;% nrow() cat(amr_annota) 24377 # AMR annotation percentage amr_annota*100/genome_annota [1] 8.655775 # VF annotation vf_annota &lt;- genome_annotations %&gt;% filter(!is.na(vf)) %&gt;% nrow() cat(vf_annota) 62759 # VF annotation percentage vf_annota*100/genome_annota [1] 22.28444 n_pred_genes &lt;- genome_annotations %&gt;% group_by(genome) %&gt;% summarize(n_genes = n()) %&gt;% left_join( genome_metadata %&gt;% dplyr::select(ID, host_type), by = c(&quot;genome&quot; = &quot;ID&quot;) ) annotated_genes &lt;- genome_annotations %&gt;% filter(if_any(c(kegg, pfam, cazy), ~ !is.na(.))) %&gt;% group_by(genome) %&gt;% summarize(n_annotated_genes = n()) %&gt;% left_join( genome_metadata %&gt;% dplyr::select(ID, host_type), by = c(&quot;genome&quot; = &quot;ID&quot;) ) ggplot(n_pred_genes, aes(x= host_type, y = n_genes, fill = host_type))+ scale_fill_manual(values = host_type_colors)+ geom_boxplot()+ geom_point()+ theme_classic()+ labs(y = &quot;Gene Number&quot;, x = &quot;Host Type&quot;) ggplot(annotated_genes, aes(x= host_type, y = n_annotated_genes, fill = host_type))+ scale_fill_manual(values = host_type_colors)+ geom_boxplot()+ geom_point()+ theme_classic()+ labs(y = &quot;Annotated Gene Number&quot;, x = &quot;Host Type&quot;) wilcox.test(n_genes ~ host_type, data=n_pred_genes) %&gt;% tidy() Warning in wilcox.test.default(x = DATA[[1L]], y = DATA[[2L]], ...): cannot compute exact p-value with ties # A tibble: 1 × 4 statistic p.value method alternative &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 1 111 0.156 Wilcoxon rank sum test with continuity correction two.sided wilcox.test(n_annotated_genes ~ host_type, data=annotated_genes) %&gt;% tidy() Warning in wilcox.test.default(x = DATA[[1L]], y = DATA[[2L]], ...): cannot compute exact p-value with ties # A tibble: 1 × 4 statistic p.value method alternative &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 1 97 0.0720 Wilcoxon rank sum test with continuity correction two.sided 7.2 KEGG 7.2.1 Nº of MAGs with KOs #Proportion of MAGs belonging to each group per KEGG #I want to know for example 5% of MAGs from anials have this KEGG, but 40 % of MAGs from humans have it # KEGG presence/absence kegg_presence &lt;- genome_annotations %&gt;% filter(!is.na(kegg)) %&gt;% dplyr::select(genome, kegg) %&gt;% distinct() #Add the host_type info kegg_with_host_type &lt;- kegg_presence %&gt;% left_join( genome_metadata %&gt;% dplyr::select(ID, host_type), by = c(&quot;genome&quot; = &quot;ID&quot;) ) # Count how many MAGs in each KEGG kegg_mag_counts &lt;- kegg_with_host_type %&gt;% group_by(host_type, kegg) %&gt;% summarise( n_mags = n(), .groups = &quot;drop&quot; ) #Count total MAGs per host_type (except the outlier) total_mags_per_host_type &lt;- genome_metadata %&gt;% group_by(host_type) %&gt;% summarise( total_mags = n_distinct(ID), .groups = &quot;drop&quot; ) #Calculate proportions of MAGs from each host_type in each KEGG kegg_mag_proportions &lt;- kegg_mag_counts %&gt;% left_join(total_mags_per_host_type, by = &quot;host_type&quot;) %&gt;% mutate( proportion = n_mags / total_mags, absent = total_mags - n_mags ) 7.2.1.1 Plotting KEGG MAG proportions kegg_mag_proportions %&gt;% filter(n_mags &gt;= 20) # A tibble: 2,692 × 6 host_type kegg n_mags total_mags proportion absent &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; 1 animal K00003 40 84 0.476 44 2 animal K00004 38 84 0.452 46 3 animal K00009 39 84 0.464 45 4 animal K00013 41 84 0.488 43 5 animal K00014 41 84 0.488 43 6 animal K00016 41 84 0.488 43 7 animal K00020 41 84 0.488 43 8 animal K00030 41 84 0.488 43 9 animal K00033 41 84 0.488 43 10 animal K00036 41 84 0.488 43 # ℹ 2,682 more rows 7.2.1.2 Statistical testing of MAG proportions fisher_results &lt;- kegg_mag_proportions %&gt;% dplyr::select(kegg, host_type, n_mags, absent) %&gt;% pivot_wider( names_from = host_type, values_from = c(n_mags, absent), values_fill = 0 ) %&gt;% rowwise() %&gt;% mutate( p_value = fisher.test( matrix( c(n_mags_animal, absent_animal, n_mags_human, absent_human), nrow = 2, byrow = TRUE ) )$p.value ) %&gt;% ungroup() %&gt;% mutate(p_adj = p.adjust(p_value, method = &quot;BH&quot;)) fisher_results &lt;- fisher_results %&gt;% mutate( prop_animal = n_mags_animal / (n_mags_animal + absent_animal), prop_human = n_mags_human / (n_mags_human + absent_human), diff_prop = prop_human - prop_animal ) volcano_df &lt;- fisher_results %&gt;% # Keep rows with non-missing p_adj and diff_prop filter(!is.na(p_adj), !is.na(diff_prop)) %&gt;% # Avoid Inf y-values if p_adj == 0 by flooring at 1e-300 (or your choice) mutate( p_adj_capped = pmax(p_adj, 1e-300), nl10 = -log10(p_adj_capped), sig = p_adj &lt; 0.05 ) to_label &lt;- volcano_df %&gt;% filter(sig) %&gt;% arrange(desc(nl10)) %&gt;% dplyr::slice(1:10) ggplot(volcano_df, aes(x = diff_prop, y = nl10)) + geom_point(aes(color = sig), alpha = 0.8, size = 2) + geom_text_repel( data = to_label, aes(label = kegg), # or `Name` max.overlaps = 20, size = 3, segment.color = &quot;grey70&quot; ) + scale_color_manual(values = c(`TRUE` = &quot;#1f77b4&quot;, `FALSE` = &quot;grey70&quot;), name =&quot;p_adj &lt; 0.05&quot;) + geom_hline(yintercept = -log10(0.05), linetype = &quot;dashed&quot;, color = &quot;grey50&quot;) + theme_minimal() + labs( x = &quot;Effect size (diff_prop)&quot;, y = expression(-log[10](p[adj])), title = &quot;Volcano plot: differential KEGG presence&quot; ) # Ensure host_type has the intended order genome_metadata &lt;- genome_metadata %&gt;% mutate(host_type = factor(host_type, levels = c(&quot;animal&quot;, &quot;human&quot;))) # 1) KEGG presence (unique genome–kegg) kegg_presence &lt;- genome_annotations %&gt;% dplyr::select(genome, kegg) %&gt;% distinct() %&gt;% filter(!is.na(kegg)) # 2) Add host type kegg_with_host &lt;- kegg_presence %&gt;% left_join( genome_metadata %&gt;% dplyr::select(ID, host_type), by = c(&quot;genome&quot; = &quot;ID&quot;) ) # 3) Count present per (kegg, host_type) kegg_counts &lt;- kegg_with_host %&gt;% group_by(kegg, host_type) %&gt;% summarise(n_present = n_distinct(genome), .groups = &quot;drop&quot;) # 4) Totals per host_type totals &lt;- genome_metadata %&gt;% group_by(host_type) %&gt;% summarise(total_mags = n_distinct(ID), .groups = &quot;drop&quot;) # 5) Complete grid and compute absent correctly kegg_counts_complete &lt;- kegg_counts %&gt;% tidyr::complete(kegg, host_type, fill = list(n_present = 0)) %&gt;% left_join(totals, by = &quot;host_type&quot;) %&gt;% mutate(n_absent = total_mags - n_present) # 6) Pivot to 2×2 format wide &lt;- kegg_counts_complete %&gt;% dplyr::select(kegg, host_type, n_present, n_absent) %&gt;% pivot_wider( id_cols = kegg, names_from = host_type, values_from = c(n_present, n_absent), values_fill = 0 ) # Sanity: ensure expected columns exist (adjust names if your levels differ) stopifnot(all(c(&quot;n_present_animal&quot;,&quot;n_absent_animal&quot;,&quot;n_present_human&quot;,&quot;n_absent_human&quot;) %in% names(wide))) wide &lt;- wide %&gt;% mutate( n_animal = n_present_animal, a_animal = n_absent_animal, n_human = n_present_human, a_human = n_absent_human ) # 7) SAFE P-VALUE: robust computation avoiding FEXACT 40 safe_fisher_p &lt;- function(n_animal, a_animal, n_human, a_human) { m &lt;- matrix(c(n_animal, a_animal, n_human, a_human), nrow = 2, byrow = TRUE) # If any row or column sums to zero, Fisher is fine (returns 1) or undefined; # handle degenerate cases: if all zero or all present, return p=1 if (any(rowSums(m) == 0) || any(colSums(m) == 0)) { return(1.0) } # 1) Try exact Fisher with large workspace p1 &lt;- tryCatch( fisher.test(m, workspace = 2e8)$p.value, error = function(e) NA_real_ ) if (!is.na(p1)) return(p1) # 2) Fall back to simulated Fisher p2 &lt;- tryCatch( fisher.test(m, simulate.p.value = TRUE, B = 1e6)$p.value, error = function(e) NA_real_ ) if (!is.na(p2)) return(p2) # 3) Last resort: chi-square with Yates correction p3 &lt;- tryCatch( suppressWarnings(chisq.test(m, correct = TRUE)$p.value), error = function(e) NA_real_ ) if (!is.na(p3)) return(p3) # If everything fails, return NA return(NA_real_) } # 8) Compute stats rowwise with robust p-values fisher_df &lt;- wide %&gt;% rowwise() %&gt;% mutate( # p-value p_value = safe_fisher_p(n_animal, a_animal, n_human, a_human), # proportions and difference prop_animal = ifelse((n_animal + a_animal) &gt; 0, n_animal / (n_animal + a_animal), NA_real_), prop_human = ifelse((n_human + a_human) &gt; 0, n_human / (n_human + a_human), NA_real_), diff_prop = prop_human - prop_animal, # Haldane–Anscombe for OR if any zero cell (effect size only) needs_ha = (n_animal == 0L) | (a_animal == 0L) | (n_human == 0L) | (a_human == 0L), n_animal_ha = ifelse(needs_ha, n_animal + 0.5, n_animal), a_animal_ha = ifelse(needs_ha, a_animal + 0.5, a_animal), n_human_ha = ifelse(needs_ha, n_human + 0.5, n_human), a_human_ha = ifelse(needs_ha, a_human + 0.5, a_human), or = (n_human_ha * a_animal_ha) / (a_human_ha * n_animal_ha), log2_or = log2(or), # Relative risk with light Laplace smoothing (fold-change of proportions) rr = ((n_human + 0.5) / (n_human + a_human + 1)) / ((n_animal + 0.5) / (n_animal + a_animal + 1)), log2_rr = log2(rr) ) %&gt;% ungroup() %&gt;% mutate(p_adj = p.adjust(p_value, method = &quot;BH&quot;)) # 9) Optional prevalence filter to stabilize estimates fisher_df &lt;- fisher_df %&gt;% mutate(total_present = n_animal + n_human) %&gt;% filter( total_present &gt;= 5 | prop_animal &gt;= 0.03 | prop_human &gt;= 0.03 ) # 10) Volcano (log2 OR) volcano_df &lt;- fisher_df %&gt;% filter(!is.na(p_adj), !is.na(log2_or)) %&gt;% mutate( p_adj_capped = pmax(p_adj, 1e-300), nl10 = -log10(p_adj_capped), sig = p_adj &lt; 0.05 ) to_label &lt;- volcano_df %&gt;% filter(sig) %&gt;% arrange(desc(nl10)) %&gt;% dplyr::slice(1:10) ggplot(volcano_df, aes(x = log2_or, y = nl10)) + geom_point(aes(color = sig), alpha = 0.8, size = 2) + geom_text_repel( data = to_label, aes(label = kegg), max.overlaps = 20, size = 3, segment.color = &quot;grey70&quot; ) + scale_color_manual(values = c(`TRUE` = &quot;#1f77b4&quot;, `FALSE` = &quot;grey70&quot;), name = &quot;FDR &lt; 0.05&quot;) + geom_hline(yintercept = -log10(0.05), linetype = &quot;dashed&quot;, color = &quot;grey50&quot;) + geom_vline(xintercept = c(-1, 1), linetype = &quot;dotted&quot;, color = &quot;grey60&quot;) + # OR ~0.5 and ~2 theme_minimal() + labs( x = &quot;Effect size (log2 odds ratio, human vs animal)&quot;, y = expression(-log[10](FDR)), title = &quot;Volcano plot: differential KEGG presence (human vs animal)&quot; ) # 11) Top 20 by significance then effect size top20 &lt;- fisher_df %&gt;% arrange(p_adj, desc(abs(log2_or))) %&gt;% dplyr::select( kegg, n_human, a_human, prop_human, n_animal, a_animal, prop_animal, diff_prop, log2_rr, log2_or, p_value, p_adj ) %&gt;% dplyr::slice(1:20) top20 # A tibble: 20 × 12 kegg n_human a_human prop_human n_animal a_animal prop_animal diff_prop log2_rr log2_or p_value p_adj &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 K12268 0 42 0 19 65 0.226 -0.226 -4.30 -4.66 0.000323 0.00356 2 K12270 0 42 0 19 65 0.226 -0.226 -4.30 -4.66 0.000323 0.00356 3 K18967 1 41 0.0238 20 64 0.238 -0.214 -2.79 -3.68 0.00179 0.00356 4 K20485 3 39 0.0714 33 51 0.393 -0.321 -2.28 -3.07 0.000119 0.00356 5 K07114 4 38 0.0952 39 45 0.464 -0.369 -2.15 -3.04 0.0000222 0.00356 6 K10242 3 39 0.0714 30 54 0.357 -0.286 -2.14 -2.85 0.000467 0.00356 7 K13789 4 38 0.0952 34 50 0.405 -0.310 -1.96 -2.69 0.000363 0.00356 8 K06075 5 37 0.119 39 45 0.464 -0.345 -1.86 -2.68 0.000127 0.00356 9 K13730 4 38 0.0952 33 51 0.393 -0.298 -1.91 -2.62 0.000398 0.00356 10 K07001 5 37 0.119 38 46 0.452 -0.333 -1.82 -2.61 0.000145 0.00356 11 K01235 4 38 0.0952 32 52 0.381 -0.286 -1.87 -2.55 0.000712 0.00356 12 K08217 4 38 0.0952 32 52 0.381 -0.286 -1.87 -2.55 0.000712 0.00356 13 K15531 4 38 0.0952 32 52 0.381 -0.286 -1.87 -2.55 0.000712 0.00356 14 K01854 5 37 0.119 36 48 0.429 -0.310 -1.75 -2.47 0.000502 0.00356 15 K09155 5 37 0.119 36 48 0.429 -0.310 -1.75 -2.47 0.000502 0.00356 16 K16028 5 37 0.119 36 48 0.429 -0.310 -1.75 -2.47 0.000502 0.00356 17 K07005 6 36 0.143 40 44 0.476 -0.333 -1.66 -2.45 0.000196 0.00356 18 K21739 6 36 0.143 40 44 0.476 -0.333 -1.66 -2.45 0.000196 0.00356 19 K22980 6 36 0.143 39 45 0.464 -0.321 -1.62 -2.38 0.000351 0.00356 20 K20374 5 37 0.119 34 50 0.405 -0.286 -1.67 -2.33 0.000993 0.00356 library(KEGGREST) # Function to get info from KEGG get_kegg_info &lt;- function(ko_id) { query &lt;- keggGet(ko_id)[[1]] # Extract Name and Definition name &lt;- ifelse(!is.null(query$NAME), query$NAME, &quot;N/A&quot;) definition &lt;- ifelse(!is.null(query$DEFINITION), query$DEFINITION, &quot;N/A&quot;) # Extract Pathways (often multiple) pathways &lt;- if(!is.null(query$PATHWAY)) { paste(names(query$PATHWAY), query$PATHWAY, sep = &quot;: &quot;, collapse = &quot;; &quot;) } else { &quot;No pathway assigned&quot; } return(c(KO = ko_id, Name = name, Definition = definition, Pathways = pathways)) } ko_list &lt;- lapply(top20$kegg, get_kegg_info) ko_summary &lt;- as.data.frame(do.call(rbind, ko_list)) print(ko_summary) KO Name Definition 1 K12268 accessory secretory protein Asp1 N/A 2 K12270 accessory secretory protein Asp3 N/A 3 K18967 diguanylate cyclase [EC:2.7.7.65] N/A 4 K20485 ATP-binding cassette, subfamily B, bacterial NisT/SpaT N/A 5 K07114 Ca-activated chloride channel homolog N/A 6 K10242 cellobiose transport system permease protein N/A 7 K13789 geranylgeranyl diphosphate synthase, type II [EC:2.5.1.1 2.5.1.10 2.5.1.29] N/A 8 K06075 MarR family transcriptional regulator, transcriptional regulator for hemolysin N/A 9 K13730 internalin A N/A 10 K07001 NTE family protein N/A 11 K01235 alpha-glucuronidase [EC:3.2.1.139] N/A 12 K08217 MFS transporter, DHA3 family, macrolide efflux protein N/A 13 K15531 oligosaccharide reducing-end xylanase [EC:3.2.1.156] N/A 14 K01854 UDP-galactopyranose mutase [EC:5.4.99.9] N/A 15 K09155 uncharacterized protein N/A 16 K16028 O-methyltransferase N/A 17 K07005 uncharacterized protein N/A 18 K21739 probable pyridine nucleotide-disulfide oxidoreductase N/A 19 K22980 capsule synthesis positive regulator AcpB N/A 20 K20374 HTH-type transcriptional regulator, SHP3-responsive repressor N/A Pathways 1 No pathway assigned 2 No pathway assigned 3 No pathway assigned 4 map02020: Two-component system; map02024: Quorum sensing 5 No pathway assigned 6 map02010: ABC transporters 7 map00900: Terpenoid backbone biosynthesis; map01100: Metabolic pathways; map01110: Biosynthesis of secondary metabolites 8 No pathway assigned 9 map05100: Bacterial invasion of epithelial cells 10 No pathway assigned 11 No pathway assigned 12 No pathway assigned 13 No pathway assigned 14 map00052: Galactose metabolism; map00520: Amino sugar and nucleotide sugar metabolism; map01100: Metabolic pathways; map01250: Biosynthesis of nucleotide sugars 15 No pathway assigned 16 map01051: Biosynthesis of ansamycins; map01052: Type I polyketide structures 17 No pathway assigned 18 No pathway assigned 19 No pathway assigned 20 map02024: Quorum sensing fish_results_names &lt;- left_join(top20, ko_summary, join_by(kegg== KO)) heatmap_data &lt;- fish_results_names %&gt;% dplyr::select(Name, prop_animal, prop_human)%&gt;% pivot_longer(!Name, names_to = &quot;host_type&quot;, values_to= &quot;proportion&quot; ) %&gt;% mutate( host_type = case_when( host_type == &quot;prop_animal&quot; ~ &quot;animal&quot;, host_type == &quot;prop_human&quot; ~ &quot;human&quot;, TRUE ~ host_type ) ) # 1) Reduce to one row per Name × host_type heatmap_summary &lt;- heatmap_data %&gt;% group_by(Name, host_type) %&gt;% summarise( proportion = mean(proportion, na.rm = TRUE), # or median(), max(), first() .groups = &quot;drop&quot; ) # 2) Compute diff = animal - human in wide form heatmap_wide &lt;- heatmap_summary %&gt;% filter(host_type %in% c(&quot;animal&quot;, &quot;human&quot;)) %&gt;% # just in case there are other types tidyr::pivot_wider( names_from = host_type, values_from = proportion ) %&gt;% mutate( diff = animal - human ) # 3) Reorder Name by diff and bring back to long for plotting heatmap_plot &lt;- heatmap_wide %&gt;% mutate(Name = forcats::fct_reorder(Name, diff)) %&gt;% tidyr::pivot_longer( cols = c(animal, human), names_to = &quot;host_type&quot;, values_to = &quot;proportion&quot; ) # 4) Plot — heatmap ggplot(heatmap_plot, aes(x = host_type, y = Name, fill = proportion)) + geom_tile() + geom_text(aes(label = scales::number(proportion, accuracy = 0.01)), size = 6) + scale_fill_viridis_c( name = &quot;Proportion of MAGs&quot;, limits = c(0, 1) ) + theme_minimal() + labs( x = &quot;host_type&quot;, y = &quot;KEGG ortholog&quot;, title = &quot;Differential KEGG presence between animal and human&quot; ) table_data &lt;- fish_results_names %&gt;% transmute( `KEGG ortholog` = Name, `Proportion in animal` = prop_animal, `Proportion in human` = prop_human, `Δ (human - animal)` = prop_human - prop_animal , `Log2(Odds Ratio)` = log2_or , `Fisher p-value` = p_adj ) %&gt;% arrange(desc(abs(`Δ (human - animal)`))) table_data # A tibble: 20 × 6 `KEGG ortholog` `Proportion in animal` `Proportion in human` `Δ (human - animal)` `Log2(Odds Ratio)` &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Ca-activated chloride c… 0.464 0.0952 -0.369 -3.04 2 MarR family transcripti… 0.464 0.119 -0.345 -2.68 3 NTE family protein 0.452 0.119 -0.333 -2.61 4 uncharacterized protein 0.476 0.143 -0.333 -2.45 5 probable pyridine nucle… 0.476 0.143 -0.333 -2.45 6 capsule synthesis posit… 0.464 0.143 -0.321 -2.38 7 ATP-binding cassette, s… 0.393 0.0714 -0.321 -3.07 8 geranylgeranyl diphosph… 0.405 0.0952 -0.310 -2.69 9 UDP-galactopyranose mut… 0.429 0.119 -0.310 -2.47 10 uncharacterized protein 0.429 0.119 -0.310 -2.47 11 O-methyltransferase 0.429 0.119 -0.310 -2.47 12 internalin A 0.393 0.0952 -0.298 -2.62 13 cellobiose transport sy… 0.357 0.0714 -0.286 -2.85 14 alpha-glucuronidase [EC… 0.381 0.0952 -0.286 -2.55 15 MFS transporter, DHA3 f… 0.381 0.0952 -0.286 -2.55 16 oligosaccharide reducin… 0.381 0.0952 -0.286 -2.55 17 HTH-type transcriptiona… 0.405 0.119 -0.286 -2.33 18 accessory secretory pro… 0.226 0 -0.226 -4.66 19 accessory secretory pro… 0.226 0 -0.226 -4.66 20 diguanylate cyclase [EC… 0.238 0.0238 -0.214 -3.68 # ℹ 1 more variable: `Fisher p-value` &lt;dbl&gt; library(gt) Warning: package &#39;gt&#39; was built under R version 4.4.3 Adjuntando el paquete: &#39;gt&#39; The following object is masked from &#39;package:ape&#39;: where table_data %&gt;% gt() %&gt;% fmt_number( columns = c(`Proportion in animal`, `Proportion in human`, `Δ (human - animal)`, `Log2(Odds Ratio)` ), decimals = 2 ) %&gt;% fmt_scientific( columns = `Fisher p-value`, decimals = 2 ) %&gt;% tab_header( title = &quot;KEGG orthologs differing between animal and human MAGs&quot; ) %&gt;% cols_align( align = &quot;center&quot;, everything() )%&gt;% tab_style( style = cell_text(weight = &quot;bold&quot;), locations = cells_column_labels(everything()) ) #lnepuvyocc table { font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } #lnepuvyocc thead, #lnepuvyocc tbody, #lnepuvyocc tfoot, #lnepuvyocc tr, #lnepuvyocc td, #lnepuvyocc th { border-style: none; } #lnepuvyocc p { margin: 0; padding: 0; } #lnepuvyocc .gt_table { display: table; border-collapse: collapse; line-height: normal; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #lnepuvyocc .gt_caption { padding-top: 4px; padding-bottom: 4px; } #lnepuvyocc .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #lnepuvyocc .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 3px; padding-bottom: 5px; padding-left: 5px; padding-right: 5px; border-top-color: #FFFFFF; border-top-width: 0; } #lnepuvyocc .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #lnepuvyocc .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #lnepuvyocc .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #lnepuvyocc .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #lnepuvyocc .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #lnepuvyocc .gt_column_spanner_outer:first-child { padding-left: 0; } #lnepuvyocc .gt_column_spanner_outer:last-child { padding-right: 0; } #lnepuvyocc .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #lnepuvyocc .gt_spanner_row { border-bottom-style: hidden; } #lnepuvyocc .gt_group_heading { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; text-align: left; } #lnepuvyocc .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #lnepuvyocc .gt_from_md > :first-child { margin-top: 0; } #lnepuvyocc .gt_from_md > :last-child { margin-bottom: 0; } #lnepuvyocc .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #lnepuvyocc .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; } #lnepuvyocc .gt_stub_row_group { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; vertical-align: top; } #lnepuvyocc .gt_row_group_first td { border-top-width: 2px; } #lnepuvyocc .gt_row_group_first th { border-top-width: 2px; } #lnepuvyocc .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #lnepuvyocc .gt_first_summary_row { border-top-style: solid; border-top-color: #D3D3D3; } #lnepuvyocc .gt_first_summary_row.thick { border-top-width: 2px; } #lnepuvyocc .gt_last_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #lnepuvyocc .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #lnepuvyocc .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #lnepuvyocc .gt_last_grand_summary_row_top { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: double; border-bottom-width: 6px; border-bottom-color: #D3D3D3; } #lnepuvyocc .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #lnepuvyocc .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #lnepuvyocc .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #lnepuvyocc .gt_footnote { margin: 0px; font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #lnepuvyocc .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #lnepuvyocc .gt_sourcenote { font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #lnepuvyocc .gt_left { text-align: left; } #lnepuvyocc .gt_center { text-align: center; } #lnepuvyocc .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #lnepuvyocc .gt_font_normal { font-weight: normal; } #lnepuvyocc .gt_font_bold { font-weight: bold; } #lnepuvyocc .gt_font_italic { font-style: italic; } #lnepuvyocc .gt_super { font-size: 65%; } #lnepuvyocc .gt_footnote_marks { font-size: 75%; vertical-align: 0.4em; position: initial; } #lnepuvyocc .gt_asterisk { font-size: 100%; vertical-align: 0; } #lnepuvyocc .gt_indent_1 { text-indent: 5px; } #lnepuvyocc .gt_indent_2 { text-indent: 10px; } #lnepuvyocc .gt_indent_3 { text-indent: 15px; } #lnepuvyocc .gt_indent_4 { text-indent: 20px; } #lnepuvyocc .gt_indent_5 { text-indent: 25px; } #lnepuvyocc .katex-display { display: inline-flex !important; margin-bottom: 0.75em !important; } #lnepuvyocc div.Reactable > div.rt-table > div.rt-thead > div.rt-tr.rt-tr-group-header > div.rt-th-group:after { height: 0px !important; } KEGG orthologs differing between animal and human MAGs KEGG ortholog Proportion in animal Proportion in human Δ (human - animal) Log2(Odds Ratio) Fisher p-value Ca-activated chloride channel homolog 0.46 0.10 −0.37 −3.04 3.56 × 10−3 MarR family transcriptional regulator, transcriptional regulator for hemolysin 0.46 0.12 −0.35 −2.68 3.56 × 10−3 NTE family protein 0.45 0.12 −0.33 −2.61 3.56 × 10−3 uncharacterized protein 0.48 0.14 −0.33 −2.45 3.56 × 10−3 probable pyridine nucleotide-disulfide oxidoreductase 0.48 0.14 −0.33 −2.45 3.56 × 10−3 capsule synthesis positive regulator AcpB 0.46 0.14 −0.32 −2.38 3.56 × 10−3 ATP-binding cassette, subfamily B, bacterial NisT/SpaT 0.39 0.07 −0.32 −3.07 3.56 × 10−3 geranylgeranyl diphosphate synthase, type II [EC:2.5.1.1 2.5.1.10 2.5.1.29] 0.40 0.10 −0.31 −2.69 3.56 × 10−3 UDP-galactopyranose mutase [EC:5.4.99.9] 0.43 0.12 −0.31 −2.47 3.56 × 10−3 uncharacterized protein 0.43 0.12 −0.31 −2.47 3.56 × 10−3 O-methyltransferase 0.43 0.12 −0.31 −2.47 3.56 × 10−3 internalin A 0.39 0.10 −0.30 −2.62 3.56 × 10−3 cellobiose transport system permease protein 0.36 0.07 −0.29 −2.85 3.56 × 10−3 alpha-glucuronidase [EC:3.2.1.139] 0.38 0.10 −0.29 −2.55 3.56 × 10−3 MFS transporter, DHA3 family, macrolide efflux protein 0.38 0.10 −0.29 −2.55 3.56 × 10−3 oligosaccharide reducing-end xylanase [EC:3.2.1.156] 0.38 0.10 −0.29 −2.55 3.56 × 10−3 HTH-type transcriptional regulator, SHP3-responsive repressor 0.40 0.12 −0.29 −2.33 3.56 × 10−3 accessory secretory protein Asp1 0.23 0.00 −0.23 −4.66 3.56 × 10−3 accessory secretory protein Asp3 0.23 0.00 −0.23 −4.66 3.56 × 10−3 diguanylate cyclase [EC:2.7.7.65] 0.24 0.02 −0.21 −3.68 3.56 × 10−3 7.2.2 Functional Ordination PCA of KEGG annotations: kegg_counts &lt;- genome_annotations %&gt;% filter(!is.na(kegg)) %&gt;% dplyr::count(genome, kegg) %&gt;% pivot_wider( names_from = kegg, values_from = n, values_fill = 0 ) # Normalization kegg_rel &lt;- kegg_counts %&gt;% column_to_rownames(&quot;genome&quot;) kegg_rel &lt;- kegg_rel / rowSums(kegg_rel) # Each row sums to 1 # Remove zero variance kegg_rel_nz &lt;- kegg_rel[, apply(kegg_rel, 2, sd) &gt; 0] # PCA with scaling pca &lt;- prcomp(kegg_rel_nz, scale. = TRUE) # Check variance explained summary(pca)$importance[,1:5] PC1 PC2 PC3 PC4 PC5 Standard deviation 19.10047 11.37402 8.655536 7.950973 7.575608 Proportion of Variance 0.16977 0.06020 0.034860 0.029420 0.026710 Cumulative Proportion 0.16977 0.22997 0.264830 0.294250 0.320950 country_palette &lt;- c( # Southern Europe &quot;Spain&quot; = &quot;#1B9E77&quot;, &quot;Italy&quot; = &quot;#33A02C&quot;, &quot;Greece&quot; = &quot;#66C2A5&quot;, &quot;Portugal&quot; = &quot;#2CA25F&quot;, &quot;Malta&quot; = &quot;#99D8C9&quot;, # Northern/Central Europe &quot;Germany&quot; = &quot;#1F78B4&quot;, &quot;United Kingdom&quot; = &quot;#4A90E2&quot;, &quot;Ireland&quot; = &quot;#6BAED6&quot;, # East Asia &quot;Japan&quot; = &quot;#E31A1C&quot;, &quot;South Korea&quot; = &quot;#FB6A4A&quot;, &quot;China&quot; = &quot;#CB181D&quot;, # North America &quot;USA&quot; = &quot;#756BB1&quot;, &quot;Canada&quot; = &quot;#9E9AC8&quot;, # Distinct &quot;Australia&quot; = &quot;#FFD92F&quot;, &quot;Greenland&quot; = &quot;#A6CEE3&quot;, &quot;none&quot; = &quot;grey70&quot; ) scores &lt;- as.data.frame(pca$x) scores$ID &lt;- rownames(scores) scores &lt;- scores %&gt;% left_join(genome_metadata, by = &quot;ID&quot;) ggplot(scores, aes(PC1, PC2, color = host_type, label = ID)) + geom_point(size = 2) + scale_color_manual(values = host_type_colors)+ theme_minimal() + labs( title = &quot;PCA of KEGG annotations across MAGs&quot;, x = paste0(&quot;PC1 (&quot;, round(summary(pca)$importance[2,1] * 100, 1), &quot;%)&quot;), y = paste0(&quot;PC2 (&quot;, round(summary(pca)$importance[2,2] * 100, 1), &quot;%)&quot;) ) + geom_text_repel() Warning: ggrepel: 139 unlabeled data points (too many overlaps). Consider increasing max.overlaps ##PCA again without outlier kegg_counts &lt;- genome_annotations %&gt;% filter(genome != &quot;EHM071389&quot;) %&gt;% filter(!is.na(kegg)) %&gt;% dplyr::count(genome, kegg) %&gt;% pivot_wider( names_from = kegg, values_from = n, values_fill = 0 ) # Normalization kegg_rel &lt;- kegg_counts %&gt;% column_to_rownames(&quot;genome&quot;) kegg_rel &lt;- kegg_rel / rowSums(kegg_rel) # Each row sums to 1 # Remove zero variance kegg_rel_nz &lt;- kegg_rel[, apply(kegg_rel, 2, sd) &gt; 0] # PCA with scaling pca &lt;- prcomp(kegg_rel_nz, scale. = TRUE) # Check variance explained summary(pca)$importance[,1:5] PC1 PC2 PC3 PC4 PC5 Standard deviation 19.54513 8.762091 8.060842 7.660639 7.307655 Proportion of Variance 0.18384 0.036950 0.031270 0.028240 0.025700 Cumulative Proportion 0.18384 0.220780 0.252050 0.280290 0.305990 scores_filtered &lt;- scores %&gt;% filter(ID != &quot;EHM071389&quot;) ggplot(scores_filtered, aes(PC1, PC2, color = host_type)) + geom_point(size = 2) + scale_color_manual(values = host_type_colors)+ theme_minimal() + labs( title = &quot;PCA of KEGG annotations across MAGs&quot;, x = paste0(&quot;PC1 (&quot;, round(summary(pca)$importance[2,1] * 100, 1), &quot;%)&quot;), y = paste0(&quot;PC2 (&quot;, round(summary(pca)$importance[2,2] * 100, 1), &quot;%)&quot;) ) ggplot(scores_filtered, aes(PC2, PC3, color = host_type)) + scale_color_manual(values = host_type_colors)+ geom_point(size = 2) + theme_minimal() + labs( title = &quot;P2 vs PC3 of KEGG annotations across MAGs&quot;, x = paste0(&quot;PC2 (&quot;, round(summary(pca)$importance[2,2] * 100, 1), &quot;%)&quot;), y = paste0(&quot;PC3 (&quot;, round(summary(pca)$importance[2,3] * 100, 1), &quot;%)&quot;) ) ggplot(scores_filtered, aes(PC3, PC4, color = host_type)) + scale_color_manual(values = host_type_colors)+ geom_point(size = 2) + theme_minimal() + labs( title = &quot;P3 vs PC4 of KEGG annotations across MAGs&quot;, x = paste0(&quot;PC3 (&quot;, round(summary(pca)$importance[2,3] * 100, 1), &quot;%)&quot;), y = paste0(&quot;PC4 (&quot;, round(summary(pca)$importance[2,4] * 100, 1), &quot;%)&quot;) ) ggplot(scores_filtered, aes(PC1, PC2, color = genome_size)) + geom_point(size = 2) + theme_minimal() + labs( title = &quot;KEGG PCA colored by genome size&quot;, x = paste0(&quot;PC1 (&quot;, round(summary(pca)$importance[2,1] * 100, 1), &quot;%)&quot;), y = paste0(&quot;PC2 (&quot;, round(summary(pca)$importance[2,2] * 100, 1), &quot;%)&quot;) ) ggplot(scores_filtered, aes(PC1, PC2, color = completeness)) + geom_point(size = 2) + theme_minimal() + labs( title = &quot;KEGG PCA colored by completeness&quot;, x = paste0(&quot;PC1 (&quot;, round(summary(pca)$importance[2,1] * 100, 1), &quot;%)&quot;), y = paste0(&quot;PC2 (&quot;, round(summary(pca)$importance[2,2] * 100, 1), &quot;%)&quot;) ) ggplot(scores_filtered, aes(PC1, PC2, color = host_order)) + scale_color_manual(values = host_order_colors)+ geom_point(size = 2) + theme_minimal() + labs( title = &quot;KEGG PCA colored by host order &quot;, x = paste0(&quot;PC1 (&quot;, round(summary(pca)$importance[2,1] * 100, 1), &quot;%)&quot;), y = paste0(&quot;PC2 (&quot;, round(summary(pca)$importance[2,2] * 100, 1), &quot;%)&quot;) ) ggplot(scores_filtered, aes(PC1, PC2, color = country_normalized)) + geom_point(size = 2) + theme_minimal() + scale_color_manual(values = country_palette, na.value = &quot;grey70&quot;)+ labs( title = &quot;KEGG PCA colored by country &quot;, x = paste0(&quot;PC1 (&quot;, round(summary(pca)$importance[2,1] * 100, 1), &quot;%)&quot;), y = paste0(&quot;PC2 (&quot;, round(summary(pca)$importance[2,2] * 100, 1), &quot;%)&quot;) ) ggplot(scores_filtered, aes(PC1, PC2, color = continent)) + geom_point(size = 2) + theme_minimal() + labs( title = &quot;KEGG PCA colored by continent&quot;, x = paste0(&quot;PC1 (&quot;, round(summary(pca)$importance[2,1] * 100, 1), &quot;%)&quot;), y = paste0(&quot;PC2 (&quot;, round(summary(pca)$importance[2,2] * 100, 1), &quot;%)&quot;) ) loadings &lt;- pca$rotation abs_loadings &lt;- apply(abs(loadings[, 1:2]), 1, sum) top_combined &lt;- sort(abs_loadings, decreasing = TRUE)[1:10] top_combined K01811 K21712 K20485 K25670 K00390 K02049 K15269 K06123 K21713 K25089 0.09747308 0.09689785 0.09352428 0.09181942 0.09112710 0.09036799 0.09021472 0.09020442 0.08818284 0.08645722 library(KEGGREST) top_loadings &lt;- loadings %&gt;% as.data.frame() %&gt;% rownames_to_column(&quot;KEGG&quot;) %&gt;% arrange(desc(abs(PC1))) head(top_loadings) KEGG PC1 PC2 PC3 PC4 PC5 PC6 PC7 PC8 1 K00079 -0.05079409 -0.009946912 0.00248532 0.003276063 -0.001132451 -0.002808841 -0.003852092 -0.002341786 2 K00036 -0.05079409 -0.009946912 0.00248532 0.003276063 -0.001132451 -0.002808841 -0.003852092 -0.002341786 3 K00133 -0.05079409 -0.009946912 0.00248532 0.003276063 -0.001132451 -0.002808841 -0.003852092 -0.002341786 4 K00215 -0.05079409 -0.009946912 0.00248532 0.003276063 -0.001132451 -0.002808841 -0.003852092 -0.002341786 5 K00243 -0.05079409 -0.009946912 0.00248532 0.003276063 -0.001132451 -0.002808841 -0.003852092 -0.002341786 6 K00567 -0.05079409 -0.009946912 0.00248532 0.003276063 -0.001132451 -0.002808841 -0.003852092 -0.002341786 PC9 PC10 PC11 PC12 PC13 PC14 PC15 PC16 1 0.0004521665 -0.002392353 -0.002480668 0.0009913822 -0.003778335 -0.0006078069 -0.002528725 0.001592632 2 0.0004521665 -0.002392353 -0.002480668 0.0009913822 -0.003778335 -0.0006078069 -0.002528725 0.001592632 3 0.0004521665 -0.002392353 -0.002480668 0.0009913822 -0.003778335 -0.0006078069 -0.002528725 0.001592632 4 0.0004521665 -0.002392353 -0.002480668 0.0009913822 -0.003778335 -0.0006078069 -0.002528725 0.001592632 5 0.0004521665 -0.002392353 -0.002480668 0.0009913822 -0.003778335 -0.0006078069 -0.002528725 0.001592632 6 0.0004521665 -0.002392353 -0.002480668 0.0009913822 -0.003778335 -0.0006078069 -0.002528725 0.001592632 PC17 PC18 PC19 PC20 PC21 PC22 PC23 PC24 1 -0.003360407 0.001340981 -0.0002272723 -0.003768608 -0.002291973 9.500263e-05 0.002216337 -0.004224191 2 -0.003360407 0.001340981 -0.0002272723 -0.003768608 -0.002291973 9.500263e-05 0.002216337 -0.004224191 3 -0.003360407 0.001340981 -0.0002272723 -0.003768608 -0.002291973 9.500263e-05 0.002216337 -0.004224191 4 -0.003360407 0.001340981 -0.0002272723 -0.003768608 -0.002291973 9.500263e-05 0.002216337 -0.004224191 5 -0.003360407 0.001340981 -0.0002272723 -0.003768608 -0.002291973 9.500263e-05 0.002216337 -0.004224191 6 -0.003360407 0.001340981 -0.0002272723 -0.003768608 -0.002291973 9.500263e-05 0.002216337 -0.004224191 PC25 PC26 PC27 PC28 PC29 PC30 PC31 PC32 1 -0.0001631202 0.0002876036 0.003178559 -0.003037596 -0.0001121851 0.0009708875 -0.00193514 0.0004799773 2 -0.0001631202 0.0002876036 0.003178559 -0.003037596 -0.0001121851 0.0009708875 -0.00193514 0.0004799773 3 -0.0001631202 0.0002876036 0.003178559 -0.003037596 -0.0001121851 0.0009708875 -0.00193514 0.0004799773 4 -0.0001631202 0.0002876036 0.003178559 -0.003037596 -0.0001121851 0.0009708875 -0.00193514 0.0004799773 5 -0.0001631202 0.0002876036 0.003178559 -0.003037596 -0.0001121851 0.0009708875 -0.00193514 0.0004799773 6 -0.0001631202 0.0002876036 0.003178559 -0.003037596 -0.0001121851 0.0009708875 -0.00193514 0.0004799773 PC33 PC34 PC35 PC36 PC37 PC38 PC39 PC40 1 0.00219996 -0.0003941481 0.000202696 0.001647772 0.0001366408 -0.0007984333 0.001261048 0.0009959284 2 0.00219996 -0.0003941481 0.000202696 0.001647772 0.0001366408 -0.0007984333 0.001261048 0.0009959284 3 0.00219996 -0.0003941481 0.000202696 0.001647772 0.0001366408 -0.0007984333 0.001261048 0.0009959284 4 0.00219996 -0.0003941481 0.000202696 0.001647772 0.0001366408 -0.0007984333 0.001261048 0.0009959284 5 0.00219996 -0.0003941481 0.000202696 0.001647772 0.0001366408 -0.0007984333 0.001261048 0.0009959284 6 0.00219996 -0.0003941481 0.000202696 0.001647772 0.0001366408 -0.0007984333 0.001261048 0.0009959284 PC41 PC42 PC43 PC44 PC45 PC46 PC47 PC48 1 0.00029952 -0.002102056 0.000196593 -0.001264468 0.0006562265 0.001189624 -0.001023567 0.0006217118 2 0.00029952 -0.002102056 0.000196593 -0.001264468 0.0006562265 0.001189624 -0.001023567 0.0006217118 3 0.00029952 -0.002102056 0.000196593 -0.001264468 0.0006562265 0.001189624 -0.001023567 0.0006217118 4 0.00029952 -0.002102056 0.000196593 -0.001264468 0.0006562265 0.001189624 -0.001023567 0.0006217118 5 0.00029952 -0.002102056 0.000196593 -0.001264468 0.0006562265 0.001189624 -0.001023567 0.0006217118 6 0.00029952 -0.002102056 0.000196593 -0.001264468 0.0006562265 0.001189624 -0.001023567 0.0006217118 PC49 PC50 PC51 PC52 PC53 PC54 PC55 PC56 1 -0.00137164 -0.0007412628 0.0001437467 0.0009806099 0.001945774 0.0001546252 0.001761751 -0.0005399553 2 -0.00137164 -0.0007412628 0.0001437467 0.0009806099 0.001945774 0.0001546252 0.001761751 -0.0005399553 3 -0.00137164 -0.0007412628 0.0001437467 0.0009806099 0.001945774 0.0001546252 0.001761751 -0.0005399553 4 -0.00137164 -0.0007412628 0.0001437467 0.0009806099 0.001945774 0.0001546252 0.001761751 -0.0005399553 5 -0.00137164 -0.0007412628 0.0001437467 0.0009806099 0.001945774 0.0001546252 0.001761751 -0.0005399553 6 -0.00137164 -0.0007412628 0.0001437467 0.0009806099 0.001945774 0.0001546252 0.001761751 -0.0005399553 PC57 PC58 PC59 PC60 PC61 PC62 PC63 PC64 1 -0.0006939236 -0.0008296102 0.0007104475 0.0005156834 5.873391e-05 0.002228717 0.001405275 -0.003018754 2 -0.0006939236 -0.0008296102 0.0007104475 0.0005156834 5.873391e-05 0.002228717 0.001405275 -0.003018754 3 -0.0006939236 -0.0008296102 0.0007104475 0.0005156834 5.873391e-05 0.002228717 0.001405275 -0.003018754 4 -0.0006939236 -0.0008296102 0.0007104475 0.0005156834 5.873391e-05 0.002228717 0.001405275 -0.003018754 5 -0.0006939236 -0.0008296102 0.0007104475 0.0005156834 5.873391e-05 0.002228717 0.001405275 -0.003018754 6 -0.0006939236 -0.0008296102 0.0007104475 0.0005156834 5.873391e-05 0.002228717 0.001405275 -0.003018754 PC65 PC66 PC67 PC68 PC69 PC70 PC71 PC72 1 -0.001450016 0.001010715 0.0007081953 9.925565e-05 -0.0003884143 -0.001329291 -0.0005705215 0.0001924911 2 -0.001450016 0.001010715 0.0007081953 9.925565e-05 -0.0003884143 -0.001329291 -0.0005705215 0.0001924911 3 -0.001450016 0.001010715 0.0007081953 9.925565e-05 -0.0003884143 -0.001329291 -0.0005705215 0.0001924911 4 -0.001450016 0.001010715 0.0007081953 9.925565e-05 -0.0003884143 -0.001329291 -0.0005705215 0.0001924911 5 -0.001450016 0.001010715 0.0007081953 9.925565e-05 -0.0003884143 -0.001329291 -0.0005705215 0.0001924911 6 -0.001450016 0.001010715 0.0007081953 9.925565e-05 -0.0003884143 -0.001329291 -0.0005705215 0.0001924911 PC73 PC74 PC75 PC76 PC77 PC78 PC79 PC80 1 0.0009102062 -0.0008839761 0.003878626 0.0005542666 -0.0004380038 0.0005507793 0.001078171 0.0005159429 2 0.0009102062 -0.0008839761 0.003878626 0.0005542666 -0.0004380038 0.0005507793 0.001078171 0.0005159429 3 0.0009102062 -0.0008839761 0.003878626 0.0005542666 -0.0004380038 0.0005507793 0.001078171 0.0005159429 4 0.0009102062 -0.0008839761 0.003878626 0.0005542666 -0.0004380038 0.0005507793 0.001078171 0.0005159429 5 0.0009102062 -0.0008839761 0.003878626 0.0005542666 -0.0004380038 0.0005507793 0.001078171 0.0005159429 6 0.0009102062 -0.0008839761 0.003878626 0.0005542666 -0.0004380038 0.0005507793 0.001078171 0.0005159429 PC81 PC82 PC83 PC84 PC85 PC86 PC87 PC88 1 -0.0004333185 0.00128074 0.0006903886 -0.001080251 0.001396304 -0.001135049 -0.0001929594 5.368472e-05 2 -0.0004333185 0.00128074 0.0006903886 -0.001080251 0.001396304 -0.001135049 -0.0001929594 5.368472e-05 3 -0.0004333185 0.00128074 0.0006903886 -0.001080251 0.001396304 -0.001135049 -0.0001929594 5.368472e-05 4 -0.0004333185 0.00128074 0.0006903886 -0.001080251 0.001396304 -0.001135049 -0.0001929594 5.368472e-05 5 -0.0004333185 0.00128074 0.0006903886 -0.001080251 0.001396304 -0.001135049 -0.0001929594 5.368472e-05 6 -0.0004333185 0.00128074 0.0006903886 -0.001080251 0.001396304 -0.001135049 -0.0001929594 5.368472e-05 PC89 PC90 PC91 PC92 PC93 PC94 PC95 PC96 1 -0.0008440112 0.001382843 0.0001964582 0.0004420025 3.101101e-05 0.0008610302 0.000197127 -0.000367249 2 -0.0008440112 0.001382843 0.0001964582 0.0004420025 3.101101e-05 0.0008610302 0.000197127 -0.000367249 3 -0.0008440112 0.001382843 0.0001964582 0.0004420025 3.101101e-05 0.0008610302 0.000197127 -0.000367249 4 -0.0008440112 0.001382843 0.0001964582 0.0004420025 3.101101e-05 0.0008610302 0.000197127 -0.000367249 5 -0.0008440112 0.001382843 0.0001964582 0.0004420025 3.101101e-05 0.0008610302 0.000197127 -0.000367249 6 -0.0008440112 0.001382843 0.0001964582 0.0004420025 3.101101e-05 0.0008610302 0.000197127 -0.000367249 PC97 PC98 PC99 PC100 PC101 PC102 PC103 PC104 1 0.00019808 -0.0008727388 0.001128832 -0.0003967602 -0.0007866373 0.0006909247 0.0003198017 0.0002666803 2 0.00019808 -0.0008727388 0.001128832 -0.0003967602 -0.0007866373 0.0006909247 0.0003198017 0.0002666803 3 0.00019808 -0.0008727388 0.001128832 -0.0003967602 -0.0007866373 0.0006909247 0.0003198017 0.0002666803 4 0.00019808 -0.0008727388 0.001128832 -0.0003967602 -0.0007866373 0.0006909247 0.0003198017 0.0002666803 5 0.00019808 -0.0008727388 0.001128832 -0.0003967602 -0.0007866373 0.0006909247 0.0003198017 0.0002666803 6 0.00019808 -0.0008727388 0.001128832 -0.0003967602 -0.0007866373 0.0006909247 0.0003198017 0.0002666803 PC105 PC106 PC107 PC108 PC109 PC110 PC111 PC112 1 -0.0005473746 0.0002778072 0.0009608736 0.0003987572 -0.0001615991 -0.0006887918 0.0001626152 -0.0004177167 2 -0.0005473746 0.0002778072 0.0009608736 0.0003987572 -0.0001615991 -0.0006887918 0.0001626152 -0.0004177167 3 -0.0005473746 0.0002778072 0.0009608736 0.0003987572 -0.0001615991 -0.0006887918 0.0001626152 -0.0004177167 4 -0.0005473746 0.0002778072 0.0009608736 0.0003987572 -0.0001615991 -0.0006887918 0.0001626152 -0.0004177167 5 -0.0005473746 0.0002778072 0.0009608736 0.0003987572 -0.0001615991 -0.0006887918 0.0001626152 -0.0004177167 6 -0.0005473746 0.0002778072 0.0009608736 0.0003987572 -0.0001615991 -0.0006887918 0.0001626152 -0.0004177167 PC113 PC114 PC115 PC116 PC117 PC118 PC119 PC120 1 1.899141e-05 -0.0008511757 0.06010329 -0.002962319 0.016043795 -8.409942e-03 0.0037907507 0.000645923 2 1.899141e-05 -0.0008511757 -0.20640265 0.020078124 -0.015956337 -1.380522e-03 0.0065767892 -0.005709369 3 1.899141e-05 -0.0008511757 -0.07341287 0.015173034 -0.005053505 -3.825393e-04 0.0034825175 0.007271212 4 1.899141e-05 -0.0008511757 -0.20753487 0.022067260 -0.006439269 -2.867193e-03 0.0051834304 0.008300492 5 1.899141e-05 -0.0008511757 0.02580746 -0.009882745 0.006425397 -7.474454e-03 0.0025719783 -0.002264049 6 1.899141e-05 -0.0008511757 0.02770028 0.001502385 0.003978823 1.216774e-05 -0.0002001145 -0.001348026 PC121 PC122 PC123 PC124 PC125 PC126 PC127 PC128 1 0.0090693245 0.0028720788 -0.009482343 0.0020125342 0.003163279 7.754879e-03 -0.001428513 -0.013186625 2 -0.0471299972 -0.0008244673 -0.002573394 0.0042153069 0.019226739 9.021912e-05 0.016527766 0.038475110 3 -0.0174921198 0.0027971131 -0.006183392 0.0056262818 0.002260204 -7.543715e-04 0.009455457 0.018688058 4 -0.0383829844 -0.0059104017 -0.004231240 0.0070146526 0.022775278 7.154643e-03 0.020359758 0.039121884 5 -0.0009289484 -0.0047524705 -0.003141514 -0.0020352140 0.006428257 6.725003e-03 -0.003371201 -0.003652185 6 0.0049073681 0.0005776272 -0.006805929 0.0009515351 -0.005996603 5.281924e-03 -0.002810729 -0.004653305 PC129 PC130 PC131 PC132 PC133 PC134 PC135 PC136 1 0.0006466979 -7.079282e-05 -4.975959e-03 0.0001613765 -0.001505083 -0.020088846 -0.003996740 0.01430148 2 -0.0185976919 4.344553e-03 2.780033e-02 0.0101618662 0.017873468 0.008430215 -0.017623681 -0.01308025 3 0.0139939392 6.666773e-03 -6.742321e-05 -0.0034306545 0.022551929 -0.020373142 0.009075277 0.02991347 4 0.0071775061 -9.405859e-04 2.100842e-02 0.0449713216 0.047790991 -0.038150897 0.003659293 0.03408021 5 -0.0128980913 -3.651087e-02 1.142903e-02 0.0383076302 -0.056153130 0.070196385 -0.038312636 -0.06343444 6 0.0163624973 -9.080050e-03 3.849744e-02 0.0041563346 0.047051444 -0.071112250 0.791279027 -0.58917909 PC137 PC138 PC139 1 0.005103517 0.0107920497 -0.005259204 2 0.013994051 -0.0083018677 -0.003754833 3 -0.014973659 0.0002958576 -0.005487010 4 -0.066239694 -0.0059026199 -0.012544125 5 0.064759595 -0.0860226940 0.002026684 6 -0.089437226 -0.0002017451 0.036715505 top_kos &lt;- head(top_loadings)%&gt;%pull(KEGG) ko_pathways &lt;- lapply(top_kos, function(k) { info &lt;- keggGet(paste0(&quot;ko:&quot;, k))[[1]] pathways &lt;- info$PATHWAY if(is.null(pathways)) pathways &lt;- NA return(pathways) }) names(ko_pathways) &lt;- top_kos ko_pathways $K00079 map00590 map00790 &quot;Arachidonic acid metabolism&quot; &quot;Folate biosynthesis&quot; map00980 map01100 &quot;Metabolism of xenobiotics by cytochrome P450&quot; &quot;Metabolic pathways&quot; map05204 map05208 &quot;Chemical carcinogenesis - DNA adducts&quot; &quot;Chemical carcinogenesis - reactive oxygen species&quot; $K00036 map00030 map00480 &quot;Pentose phosphate pathway&quot; &quot;Glutathione metabolism&quot; map01100 map01110 &quot;Metabolic pathways&quot; &quot;Biosynthesis of secondary metabolites&quot; map01120 map01200 &quot;Microbial metabolism in diverse environments&quot; &quot;Carbon metabolism&quot; map05230 map05415 &quot;Central carbon metabolism in cancer&quot; &quot;Diabetic cardiomyopathy&quot; $K00133 map00260 map00261 &quot;Glycine, serine and threonine metabolism&quot; &quot;Monobactam biosynthesis&quot; map00270 map00300 &quot;Cysteine and methionine metabolism&quot; &quot;Lysine biosynthesis&quot; map01100 map01110 &quot;Metabolic pathways&quot; &quot;Biosynthesis of secondary metabolites&quot; map01120 map01210 &quot;Microbial metabolism in diverse environments&quot; &quot;2-Oxocarboxylic acid metabolism&quot; map01230 &quot;Biosynthesis of amino acids&quot; $K00215 map00261 map00300 &quot;Monobactam biosynthesis&quot; &quot;Lysine biosynthesis&quot; map01100 map01110 &quot;Metabolic pathways&quot; &quot;Biosynthesis of secondary metabolites&quot; map01120 map01230 &quot;Microbial metabolism in diverse environments&quot; &quot;Biosynthesis of amino acids&quot; $K00243 [1] NA $K00567 [1] NA 7.2.3 Testing the differences in KEGG presence/absence with PERMANOVA kegg_counts_mat &lt;- kegg_counts %&gt;% column_to_rownames(&quot;genome&quot;) kegg_pa &lt;- (kegg_counts_mat &gt; 0) * 1 # remove zero-variance KOs kegg_pa_nz &lt;- kegg_pa[, colSums(kegg_pa) &gt; 0 &amp; colSums(kegg_pa) &lt; nrow(kegg_pa)] # Determine the common genomes common_ids &lt;- base::intersect(rownames(kegg_pa_nz), genome_metadata$ID) # Report what will be kept/dropped message(&quot;# common: &quot;, length(common_ids)) # common: 49 message(&quot;# in KEGG only: &quot;, length(setdiff(rownames(kegg_pa_nz), genome_metadata$ID))) # in KEGG only: 90 message(&quot;# in metadata only: &quot;, length(setdiff(genome_metadata$ID, rownames(kegg_pa_nz)))) # in metadata only: 78 # Subset to the intersection (and keep order identical) kegg_pa_nz &lt;- kegg_pa_nz[common_ids, , drop = FALSE] meta &lt;- genome_metadata %&gt;% dplyr::filter(ID %in% common_ids) %&gt;% dplyr::distinct(ID, .keep_all = TRUE) %&gt;% tibble::column_to_rownames(&quot;ID&quot;) %&gt;% .[common_ids, , drop = FALSE] stopifnot(identical(rownames(meta), rownames(kegg_pa_nz))) # Prepare variables for PERMANOVA required_vars &lt;- c(&quot;genome_size&quot;, &quot;completeness&quot;, &quot;host_type&quot;) # Coerce types as needed meta &lt;- meta %&gt;% dplyr::mutate( genome_size = as.numeric(genome_size), completeness = as.numeric(completeness), host_type = as.factor(host_type) ) # Align on complete cases (adonis2 drops NAs otherwise) ok &lt;- stats::complete.cases(meta[, required_vars, drop = FALSE]) kegg_pa_nz &lt;- kegg_pa_nz[ok, , drop = FALSE] meta &lt;- meta[ok, , drop = FALSE] stopifnot(identical(rownames(meta), rownames(kegg_pa_nz))) # Distance, dispersion, PERMANOVA kegg_dist_pa &lt;- vegan::vegdist(kegg_pa_nz, method = &quot;jaccard&quot;, binary = TRUE) disp_pa &lt;- vegan::betadisper(kegg_dist_pa, meta$host_type) anova(disp_pa) Analysis of Variance Table Response: Distances Df Sum Sq Mean Sq F value Pr(&gt;F) Groups 1 0.000448 0.00044791 0.3263 0.5706 Residuals 46 0.063141 0.00137264 vegan::adonis2( kegg_dist_pa ~ genome_size + completeness + host_type, data = meta, permutations = 999, by = &quot;margin&quot; ) Permutation test for adonis under reduced model Marginal effects of terms Permutation: free Number of permutations: 999 vegan::adonis2(formula = kegg_dist_pa ~ genome_size + completeness + host_type, data = meta, permutations = 999, by = &quot;margin&quot;) Df SumOfSqs R2 F Pr(&gt;F) genome_size 1 0.06534 0.05533 2.8009 0.001 *** completeness 1 0.02762 0.02339 1.1841 0.238 host_type 1 0.05889 0.04988 2.5247 0.005 ** Residual 44 1.02639 0.86923 Total 47 1.18081 1.00000 --- Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 pcoa_pa &lt;- cmdscale(kegg_dist_pa, eig = TRUE, k = 2) variance_explained &lt;- pcoa_pa$eig / sum(pcoa_pa$eig) pcoa_df &lt;- data.frame( ID = rownames(kegg_pa_nz), PC1 = pcoa_pa$points[,1], PC2 = pcoa_pa$points[,2], host_type = meta$host_type ) %&gt;% left_join(genome_metadata, by = &quot;ID&quot;) pcoa_kegg_pa &lt;- ggplot(pcoa_df, aes(PC1, PC2, color = host_type.x)) + geom_point(size = 2) + scale_color_manual(values = host_type_colors, name = &quot;Host type&quot;)+ theme_minimal() + labs( title = &quot;PCoA of KEGG presence/absence matrix across MAGs (colored by host type)&quot;, x = paste0(&quot;PC1 (&quot;,round(variance_explained[1] * 100, 1), &quot;%)&quot;), y = paste0(&quot;PC2 (&quot;, round(variance_explained[2] * 100, 1), &quot;%)&quot;) ) pcoa_kegg_pa pcoa_kegg_pa &lt;- ggplot(pcoa_df, aes(PC1, PC2, color = host_order)) + geom_point(size = 2) + scale_color_manual(values = host_order_colors, name = &quot;Host order&quot;)+ theme_minimal() + labs( title = &quot;PCoA of KEGG presence/absence matrix across MAGs (colored by host order)&quot;, x = paste0(&quot;PC1 (&quot;,round(variance_explained[1] * 100, 1), &quot;%)&quot;), y = paste0(&quot;PC2 (&quot;, round(variance_explained[2] * 100, 1), &quot;%)&quot;) ) pcoa_kegg_pa ggplot(pcoa_df, aes(PC1, PC2, color = completeness)) + geom_point(size = 2) + theme_minimal() + labs( title = &quot;PCoA of KEGG presence/absence matrix across MAGs (colored by completeness)&quot;, x = paste0(&quot;PC1 (&quot;,round(variance_explained[1] * 100, 1), &quot;%)&quot;), y = paste0(&quot;PC2 (&quot;, round(variance_explained[2] * 100, 1), &quot;%)&quot;) ) ggplot(pcoa_df, aes(PC1, PC2, color = continent)) + geom_point(size = 2) + theme_minimal() + labs( title = &quot;PCoA of KEGG presence/absence matrix across MAGs (colored by continent)&quot;, x = paste0(&quot;PC1 (&quot;,round(variance_explained[1] * 100, 1), &quot;%)&quot;), y = paste0(&quot;PC2 (&quot;, round(variance_explained[2] * 100, 1), &quot;%)&quot;) ) library(patchwork) p_main &lt;- ggplot(pcoa_df, aes(PC1, PC2, color = host_type.x)) + scale_color_manual(values = host_type_colors) + geom_point(size = 2) + theme_minimal() + labs( title = &quot;PCoA of KEGG annotations across MAGs&quot;, x = paste0(&quot;PC1 (&quot;, round(variance_explained[1] * 100, 1), &quot;%)&quot;), y = paste0(&quot;PC2 (&quot;, round(variance_explained[2] * 100, 1), &quot;%)&quot;) ) + theme( legend.position = &quot;right&quot;, axis.title.x = element_blank(), axis.text.x = element_blank(), axis.ticks.x = element_blank(), plot.margin = margin(5, 5, 0, 5) ) cor_value &lt;- cor(pcoa_df$PC1, pcoa_df$completeness, method = &quot;spearman&quot;) cor_pvalue &lt;- cor.test(pcoa_df$PC1, pcoa_df$completeness, method = &quot;spearman&quot;)$p.value Warning in cor.test.default(pcoa_df$PC1, pcoa_df$completeness, method = &quot;spearman&quot;): Cannot compute exact p-value with ties cor_text &lt;- paste0(&quot;Spearman ρ = &quot;, round(cor_value, 3), &quot;\\np &lt; &quot;, format.pval(cor_pvalue, digits = 2)) p_completeness_annotated &lt;- ggplot(pcoa_df, aes(x = PC1, y = completeness, color = host_type.x)) + scale_color_manual(values = host_type_colors) + geom_point(alpha = 0.6, size = 2) + geom_smooth(method = &quot;lm&quot;, se = TRUE, color = &quot;black&quot;, linewidth = 1) + annotate(&quot;text&quot;, x = min(pcoa_df$PC1) + 0.1 * diff(range(pcoa_df$PC1)), y = max(pcoa_df$completeness) - 5, label = cor_text, hjust = 0, size = 3, # Changed from 4 to 3 (smaller) fontface = &quot;plain&quot;) + # Changed from &quot;bold&quot; to &quot;plain&quot; theme_minimal() + labs( y = &quot;Completeness (%)&quot;, x = paste0(&quot;PC1 (&quot;, round(variance_explained[1] * 100, 1), &quot;%)&quot;) ) + theme( legend.position = &quot;none&quot;, plot.margin = margin(0, 5, 5, 5), panel.border = element_rect(color = &quot;black&quot;, fill = NA, linewidth = 0.5) # Add border ) p_main &lt;- p_main + theme(panel.border = element_rect(color = &quot;black&quot;, fill = NA, linewidth = 0.5)) combined_annotated &lt;- p_main / p_completeness_annotated + plot_layout(heights = c(3, 1), guides = &quot;collect&quot;) print(combined_annotated) `geom_smooth()` using formula = &#39;y ~ x&#39; 7.3 GIFTs 7.3.1 PCoA with Euclidean distances: # Convert the GIFTs into a matrix of functional elements per genome (row) gift_pcoa &lt;- genome_gifts %&gt;% to.elements(., GIFT_db) %&gt;% as.data.frame() %&gt;% vegdist(method=&quot;euclidean&quot;) %&gt;% pcoa() #principal component analysis #Extract eigenvalues (variance explained by first 10 axes) gift_pcoa_rel_eigen &lt;- gift_pcoa$values$Relative_eig[1:10] # Get genome positions gift_pcoa_vectors &lt;- gift_pcoa$vectors %&gt;% #extract vectors as.data.frame() %&gt;% dplyr::select(Axis.1,Axis.2) # keep the first 2 axes gift_pcoa_eigenvalues &lt;- gift_pcoa$values$Eigenvalues[c(1,2)] #For the black arrows: Functional group loadings # covariance between each functional trait and pcoa axis scores #scale with the eigenvectors gift_pcoa_gifts &lt;- cov(genome_gifts, scale(gift_pcoa_vectors)) %*% diag((gift_pcoa_eigenvalues/(nrow(genome_gifts)-1))^(-0.5)) %&gt;% as.data.frame() %&gt;% dplyr::rename(Axis.1=1,Axis.2=2) %&gt;% rownames_to_column(var=&quot;label&quot;) %&gt;% #get function summary vectors mutate(func=substr(label,1,3)) %&gt;% group_by(func) %&gt;% #grouping by function summarise(Axis.1=mean(Axis.1), Axis.2=mean(Axis.2)) %&gt;% dplyr::rename(label=func) %&gt;% filter(!label %in% c(&quot;S01&quot;,&quot;S02&quot;,&quot;S03&quot;)) set.seed(101) scale &lt;- 20 # scale for vector loadings (to make arrows visible) gift_pcoa_vectors %&gt;% rownames_to_column(var=&quot;ID&quot;) %&gt;% left_join(genome_metadata, by=&quot;ID&quot;) %&gt;% ggplot() + #genome positions scale_color_manual(values=host_type_colors)+ geom_point(aes(x=Axis.1,y=Axis.2, color = host_type), alpha=0.9, shape=16) + scale_size_continuous(range = c(0.1,5)) + #loading positions geom_segment(data=gift_pcoa_gifts, aes(x=0, y=0, xend=Axis.1 * scale, yend=Axis.2 * scale), arrow = arrow(length = unit(0.3, &quot;cm&quot;), type = &quot;open&quot;, angle = 25), linewidth = 0.5, color = &quot;black&quot;) + #Primary and secondary scale adjustments scale_x_continuous(name = paste0(&quot;PCoA1 (&quot;,round(gift_pcoa_rel_eigen[1]*100, digits = 2), &quot; %)&quot;), sec.axis = sec_axis(~ . / scale, name = &quot;Loadings on PCoA1&quot;) ) + scale_y_continuous(name = paste0(&quot;PCoA2 (&quot;,round(gift_pcoa_rel_eigen[2]*100, digits = 2), &quot; %)&quot;), sec.axis = sec_axis(~ . / scale, name = &quot;Loadings on PCoA2&quot;) ) + geom_label_repel(data = gift_pcoa_gifts, aes(label = label, x = Axis.1 * scale, y = Axis.2 * scale), segment.color = &#39;transparent&#39;) + xlim(-0.8,1) + ylim(-1,1.5) + theme_minimal() + labs( x = paste0(&quot;PCoA1 (&quot;, round(gift_pcoa_rel_eigen[1]*100, 2), &quot; %)&quot;), y = paste0(&quot;PCoA2 (&quot;, round(gift_pcoa_rel_eigen[2]*100, 2), &quot; %)&quot;) ) Warning: Removed 3 rows containing missing values or values outside the scale range (`geom_point()`). Warning: Removed 2 rows containing missing values or values outside the scale range (`geom_segment()`). Warning: Removed 2 rows containing missing values or values outside the scale range (`geom_label_repel()`). Warning: ggrepel: 14 unlabeled data points (too many overlaps). Consider increasing max.overlaps gift_pcoa_vectors %&gt;% rownames_to_column(var=&quot;ID&quot;) %&gt;% left_join(genome_metadata, by=&quot;ID&quot;) %&gt;% ggplot() + #genome positions geom_point(aes(x=Axis.1,y=Axis.2, color = completeness), alpha=0.9, shape=16) + scale_size_continuous(range = c(0.1,5)) + #loading positions geom_segment(data=gift_pcoa_gifts, aes(x=0, y=0, xend=Axis.1 * scale, yend=Axis.2 * scale), arrow = arrow(length = unit(0.3, &quot;cm&quot;), type = &quot;open&quot;, angle = 25), linewidth = 0.5, color = &quot;black&quot;) + #Primary and secondary scale adjustments scale_x_continuous(name = paste0(&quot;PCoA1 (&quot;,round(gift_pcoa_rel_eigen[1]*100, digits = 2), &quot; %)&quot;), sec.axis = sec_axis(~ . / scale, name = &quot;Loadings on PCoA1&quot;) ) + scale_y_continuous(name = paste0(&quot;PCoA2 (&quot;,round(gift_pcoa_rel_eigen[2]*100, digits = 2), &quot; %)&quot;), sec.axis = sec_axis(~ . / scale, name = &quot;Loadings on PCoA2&quot;) ) + geom_label_repel(data = gift_pcoa_gifts, aes(label = label, x = Axis.1 * scale, y = Axis.2 * scale), segment.color = &#39;transparent&#39;) + xlim(-0.8,1) + ylim(-1,1.5) + theme_minimal() + labs( x = paste0(&quot;PCoA1 (&quot;, round(gift_pcoa_rel_eigen[1]*100, 2), &quot; %)&quot;), y = paste0(&quot;PCoA2 (&quot;, round(gift_pcoa_rel_eigen[2]*100, 2), &quot; %)&quot;) ) Warning: Removed 3 rows containing missing values or values outside the scale range (`geom_point()`). Warning: Removed 2 rows containing missing values or values outside the scale range (`geom_segment()`). Warning: Removed 2 rows containing missing values or values outside the scale range (`geom_label_repel()`). Warning: ggrepel: 14 unlabeled data points (too many overlaps). Consider increasing max.overlaps gift_pcoa_vectors %&gt;% rownames_to_column(var=&quot;ID&quot;) %&gt;% left_join(genome_metadata, by=&quot;ID&quot;) %&gt;% ggplot() + #genome positions geom_point(aes(x=Axis.1,y=Axis.2, color = continent), alpha=0.9, shape=16) + scale_size_continuous(range = c(0.1,5)) + #loading positions geom_segment(data=gift_pcoa_gifts, aes(x=0, y=0, xend=Axis.1 * scale, yend=Axis.2 * scale), arrow = arrow(length = unit(0.3, &quot;cm&quot;), type = &quot;open&quot;, angle = 25), linewidth = 0.5, color = &quot;black&quot;) + #Primary and secondary scale adjustments scale_x_continuous(name = paste0(&quot;PCoA1 (&quot;,round(gift_pcoa_rel_eigen[1]*100, digits = 2), &quot; %)&quot;), sec.axis = sec_axis(~ . / scale, name = &quot;Loadings on PCoA1&quot;) ) + scale_y_continuous(name = paste0(&quot;PCoA2 (&quot;,round(gift_pcoa_rel_eigen[2]*100, digits = 2), &quot; %)&quot;), sec.axis = sec_axis(~ . / scale, name = &quot;Loadings on PCoA2&quot;) ) + geom_label_repel(data = gift_pcoa_gifts, aes(label = label, x = Axis.1 * scale, y = Axis.2 * scale), segment.color = &#39;transparent&#39;) + xlim(-0.8,1) + ylim(-1,1.5) + theme_minimal() + labs( x = paste0(&quot;PCoA1 (&quot;, round(gift_pcoa_rel_eigen[1]*100, 2), &quot; %)&quot;), y = paste0(&quot;PCoA2 (&quot;, round(gift_pcoa_rel_eigen[2]*100, 2), &quot; %)&quot;) ) Warning: Removed 3 rows containing missing values or values outside the scale range (`geom_point()`). Warning: Removed 2 rows containing missing values or values outside the scale range (`geom_segment()`). Warning: Removed 2 rows containing missing values or values outside the scale range (`geom_label_repel()`). Warning: ggrepel: 14 unlabeled data points (too many overlaps). Consider increasing max.overlaps gift_pcoa_vectors %&gt;% rownames_to_column(var=&quot;ID&quot;) %&gt;% left_join(genome_metadata, by=&quot;ID&quot;) %&gt;% ggplot() + #genome positions geom_point(aes(x=Axis.1,y=Axis.2, color = host_class), alpha=0.9, shape=16) + scale_size_continuous(range = c(0.1,5)) + #loading positions geom_segment(data=gift_pcoa_gifts, aes(x=0, y=0, xend=Axis.1 * scale, yend=Axis.2 * scale), arrow = arrow(length = unit(0.3, &quot;cm&quot;), type = &quot;open&quot;, angle = 25), linewidth = 0.5, color = &quot;black&quot;) + #Primary and secondary scale adjustments scale_x_continuous(name = paste0(&quot;PCoA1 (&quot;,round(gift_pcoa_rel_eigen[1]*100, digits = 2), &quot; %)&quot;), sec.axis = sec_axis(~ . / scale, name = &quot;Loadings on PCoA1&quot;) ) + scale_y_continuous(name = paste0(&quot;PCoA2 (&quot;,round(gift_pcoa_rel_eigen[2]*100, digits = 2), &quot; %)&quot;), sec.axis = sec_axis(~ . / scale, name = &quot;Loadings on PCoA2&quot;) ) + geom_label_repel(data = gift_pcoa_gifts, aes(label = label, x = Axis.1 * scale, y = Axis.2 * scale), segment.color = &#39;transparent&#39;) + xlim(-0.8,1) + ylim(-1,1.5) + theme_minimal() + labs( x = paste0(&quot;PCoA1 (&quot;, round(gift_pcoa_rel_eigen[1]*100, 2), &quot; %)&quot;), y = paste0(&quot;PCoA2 (&quot;, round(gift_pcoa_rel_eigen[2]*100, 2), &quot; %)&quot;) ) Warning: Removed 3 rows containing missing values or values outside the scale range (`geom_point()`). Warning: Removed 2 rows containing missing values or values outside the scale range (`geom_segment()`). Warning: Removed 2 rows containing missing values or values outside the scale range (`geom_label_repel()`). Warning: ggrepel: 14 unlabeled data points (too many overlaps). Consider increasing max.overlaps gift_pcoa_vectors %&gt;% rownames_to_column(var=&quot;ID&quot;) %&gt;% left_join(genome_metadata, by=&quot;ID&quot;) %&gt;% ggplot() + #genome positions geom_point(aes(x=Axis.1,y=Axis.2, color = host_order), alpha=0.9, shape=16) + scale_color_manual(values = host_order_colors)+ scale_size_continuous(range = c(0.1,5)) + #loading positions geom_segment(data=gift_pcoa_gifts, aes(x=0, y=0, xend=Axis.1 * scale, yend=Axis.2 * scale), arrow = arrow(length = unit(0.3, &quot;cm&quot;), type = &quot;open&quot;, angle = 25), linewidth = 0.5, color = &quot;black&quot;) + #Primary and secondary scale adjustments scale_x_continuous(name = paste0(&quot;PCoA1 (&quot;,round(gift_pcoa_rel_eigen[1]*100, digits = 2), &quot; %)&quot;), sec.axis = sec_axis(~ . / scale, name = &quot;Loadings on PCoA1&quot;) ) + scale_y_continuous(name = paste0(&quot;PCoA2 (&quot;,round(gift_pcoa_rel_eigen[2]*100, digits = 2), &quot; %)&quot;), sec.axis = sec_axis(~ . / scale, name = &quot;Loadings on PCoA2&quot;) ) + geom_label_repel(data = gift_pcoa_gifts, aes(label = label, x = Axis.1 * scale, y = Axis.2 * scale), segment.color = &#39;transparent&#39;) + xlim(-0.8,1) + ylim(-1,1.5) + theme_minimal() + labs( x = paste0(&quot;PCoA1 (&quot;, round(gift_pcoa_rel_eigen[1]*100, 2), &quot; %)&quot;), y = paste0(&quot;PCoA2 (&quot;, round(gift_pcoa_rel_eigen[2]*100, 2), &quot; %)&quot;) ) Warning: Removed 3 rows containing missing values or values outside the scale range (`geom_point()`). Warning: Removed 2 rows containing missing values or values outside the scale range (`geom_segment()`). Warning: Removed 2 rows containing missing values or values outside the scale range (`geom_label_repel()`). Warning: ggrepel: 14 unlabeled data points (too many overlaps). Consider increasing max.overlaps centroids &lt;- gift_pcoa_vectors %&gt;% rownames_to_column(var = &quot;ID&quot;) %&gt;% left_join(genome_metadata, by = &quot;ID&quot;) %&gt;% group_by(host_type) %&gt;% summarise( Axis.1 = mean(Axis.1, na.rm = TRUE), Axis.2 = mean(Axis.2, na.rm = TRUE), .groups = &quot;drop&quot; ) gift_pcoa_vectors %&gt;% rownames_to_column(var = &quot;ID&quot;) %&gt;% left_join(genome_metadata, by = &quot;ID&quot;) %&gt;% ggplot(aes(x = Axis.1, y = Axis.2, color = host_type)) + geom_point(size = 3, alpha = 0.9) + scale_color_manual(values = host_type_colors) + labs( x = paste0(&quot;PCoA1 (&quot;, round(gift_pcoa_rel_eigen[1] * 100, 2), &quot; %)&quot;), y = paste0(&quot;PCoA2 (&quot;, round(gift_pcoa_rel_eigen[2] * 100, 2), &quot; %)&quot;) ) + coord_cartesian(xlim = c(-0.6, 1), ylim = c(-1, 1)) + theme_minimal(base_size = 16) + theme( axis.title = element_text(size = 14, face = &quot;bold&quot;), axis.text = element_text(size = 14), legend.title = element_text(size = 14), legend.text = element_text(size = 14), panel.grid.minor = element_blank() ) Using k-means to cluster the groups and check which MAGs cluster together: coords &lt;- gift_pcoa_vectors %&gt;% rownames_to_column(&quot;MAG&quot;) %&gt;% as_tibble() set.seed(123) km &lt;- kmeans(coords[, c(&quot;Axis.1&quot;, &quot;Axis.2&quot;)], centers = 2, nstart = 25, iter.max = 100) coords &lt;- coords %&gt;% mutate(cluster = factor(km$cluster)) # centroids as a tibble for plotting centroids &lt;- as_tibble(km$centers) %&gt;% mutate(cluster = factor(1:nrow(km$centers))) ggplot(coords, aes(x = Axis.1, y = Axis.2, color = cluster)) + geom_point(size = 2, alpha = 0.8) + geom_point(data = centroids, aes(x = Axis.1, y = Axis.2, color = cluster), shape = 4, size = 5, stroke = 1.25) + # X marks centroids theme_minimal() + labs(title = paste0(&quot;PCoA colored by kmeans (k=2)&quot;), color = &quot;cluster&quot;) mags_by_cluster &lt;- split(coords$MAG, km$cluster) mags_by_cluster $`1` [1] &quot;EHM066683&quot; &quot;EHM045744&quot; &quot;GCF_027676165.1&quot; &quot;GCA_024461935.1&quot; &quot;GCA_948850205.1&quot; &quot;GCA_015667075.1&quot; [7] &quot;EHM057831&quot; &quot;GCA_015551225.1&quot; &quot;GCF_027676135.1&quot; &quot;GCA_039060945.1&quot; &quot;GCF_027672785.1&quot; &quot;GCF_050408585.1&quot; [13] &quot;GCF_039061015.1&quot; &quot;GCF_027673305.1&quot; &quot;GCF_015667075.1&quot; &quot;GCF_027673155.1&quot; &quot;GCA_949462505.1&quot; &quot;GCF_027673085.1&quot; [19] &quot;GCA_949470665.1&quot; &quot;GCF_027672695.1&quot; &quot;EHM066565&quot; &quot;GCA_948496745.1&quot; &quot;EHM079037&quot; &quot;GCF_027679985.1&quot; [25] &quot;EHM019886&quot; &quot;GCA_949840595.1&quot; &quot;GCF_015551225.1&quot; &quot;GCF_039060945.1&quot; &quot;GCA_948619675.1&quot; &quot;GCA_050408585.1&quot; [31] &quot;GCA_948514765.1&quot; &quot;GCF_027672665.1&quot; &quot;GCF_027672965.1&quot; &quot;GCF_024461915.1&quot; &quot;GCF_902364565.1&quot; &quot;GCF_003472365.1&quot; [37] &quot;GCA_039061015.1&quot; &quot;GCA_024461915.1&quot; &quot;GCA_003472365.1&quot; &quot;GCA_902364565.1&quot; &quot;GCF_027672865.1&quot; &quot;EHM071389&quot; [43] &quot;GCF_027673485.1&quot; &quot;GCF_027673225.1&quot; &quot;GCF_024461935.1&quot; &quot;EHM028422&quot; $`2` [1] &quot;EHM042508&quot; &quot;GCF_030545485.1&quot; &quot;EHM013277&quot; &quot;GCA_948644855.1&quot; &quot;GCF_014830215.1&quot; &quot;GCA_949460315.1&quot; [7] &quot;GCA_948622745.1&quot; &quot;EHM045766&quot; &quot;GCA_958421465.1&quot; &quot;GCA_947347755.1&quot; &quot;GCF_027674325.1&quot; &quot;GCA_015667015.1&quot; [13] &quot;EHM027656&quot; &quot;EHM041731&quot; &quot;GCA_018916825.1&quot; &quot;GCA_025128595.1&quot; &quot;GCA_948896515.1&quot; &quot;EHM056720&quot; [19] &quot;GCF_025128595.1&quot; &quot;GCF_027674685.1&quot; &quot;EHM043079&quot; &quot;GCF_027672725.1&quot; &quot;EHM031001&quot; &quot;GCA_015666905.1&quot; [25] &quot;GCF_027676035.1&quot; &quot;EHM046444&quot; &quot;EHM045845&quot; &quot;EHM056528&quot; &quot;EHM031663&quot; &quot;GCA_937924215.1&quot; [31] &quot;EHM028346&quot; &quot;GCA_948672875.1&quot; &quot;EHM025679&quot; &quot;GCF_014334715.1&quot; &quot;GCF_009497135.1&quot; &quot;GCA_001672265.1&quot; [37] &quot;GCF_021961665.1&quot; &quot;EHM041306&quot; &quot;GCA_020782925.1&quot; &quot;GCF_020782925.1&quot; &quot;GCA_018381915.1&quot; &quot;GCF_027674405.1&quot; [43] &quot;GCA_020553675.1&quot; &quot;GCF_030480465.1&quot; &quot;GCA_030545485.1&quot; &quot;GCA_949028585.1&quot; &quot;GCF_001672265.1&quot; &quot;GCA_040516025.1&quot; [49] &quot;GCF_015666905.1&quot; &quot;EHM031160&quot; &quot;GCF_027673065.1&quot; &quot;GCA_014334715.1&quot; &quot;EHM031128&quot; &quot;GCA_014830215.1&quot; [55] &quot;GCA_948654415.1&quot; &quot;EHM034137&quot; &quot;GCA_030480465.1&quot; &quot;EHM040253&quot; &quot;GCF_015552555.1&quot; &quot;GCA_948544615.1&quot; [61] &quot;GCA_948700895.1&quot; &quot;GCA_949428005.1&quot; &quot;EHM046343&quot; &quot;EHM057270&quot; &quot;GCA_949439745.1&quot; &quot;GCF_018916825.1&quot; [67] &quot;GCA_948674145.1&quot; &quot;GCA_949006045.1&quot; &quot;GCF_027672645.1&quot; &quot;GCF_932750895.1&quot; &quot;GCA_009497135.1&quot; &quot;GCA_949444485.1&quot; [73] &quot;GCF_040516025.1&quot; &quot;GCA_905210045.1&quot; &quot;EHM044953&quot; &quot;GCF_020553675.1&quot; &quot;GCF_027688475.1&quot; &quot;GCF_027661125.1&quot; [79] &quot;GCF_015667015.1&quot; &quot;EHM056391&quot; &quot;GCA_948748415.1&quot; &quot;GCA_015552555.1&quot; &quot;EHM025059&quot; &quot;GCA_022794425.1&quot; [85] &quot;GCA_948995465.1&quot; &quot;EHM016594&quot; &quot;EHM020035&quot; &quot;GCA_948741555.1&quot; &quot;GCF_027674205.1&quot; &quot;EHM015868&quot; [91] &quot;EHM017294&quot; &quot;GCA_948777995.1&quot; &quot;EHM028354&quot; &quot;EHM028200&quot; 7.3.2 Checking each cluster at once cluster1_MAGs &lt;- mags_by_cluster[[1]] genome_metadata %&gt;% filter(ID %in% cluster1_MAGs) # A tibble: 13 × 45 ID source species gtdb_taxonomy host_species host_order host_class isolation_source host host_summary &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; 1 EHM019886 EHI s__Lac… &lt;NA&gt; Plecotus Au… Chiroptera Mammalia host-associated &lt;NA&gt; NA 2 EHM028422 EHI s__Lac… &lt;NA&gt; Plecotus Au… Chiroptera Mammalia host-associated &lt;NA&gt; NA 3 EHM045744 EHI s__Lac… &lt;NA&gt; Plecotus Au… Chiroptera Mammalia host-associated &lt;NA&gt; NA 4 EHM057831 EHI s__Lac… &lt;NA&gt; Myotis Bech… Chiroptera Mammalia host-associated &lt;NA&gt; NA 5 EHM066565 EHI s__Lac… &lt;NA&gt; Plecotus Au… Chiroptera Mammalia host-associated &lt;NA&gt; NA 6 EHM066683 EHI s__Lac… &lt;NA&gt; Plecotus Au… Chiroptera Mammalia host-associated &lt;NA&gt; NA 7 EHM071389 EHI s__Lac… &lt;NA&gt; Podarcis Fi… Squamata Reptilia host-associated &lt;NA&gt; NA 8 EHM079037 EHI s__Lac… &lt;NA&gt; Myotis Bech… Chiroptera Mammalia host-associated &lt;NA&gt; NA 9 GCF_0155… NCBI &lt;NA&gt; &lt;NA&gt; Homo sapiens Primates Mammalia stool Homo… NA 10 GCF_0156… NCBI &lt;NA&gt; &lt;NA&gt; Homo sapiens Primates Mammalia stool Homo… NA 11 GCF_0390… NCBI &lt;NA&gt; &lt;NA&gt; Homo sapiens Primates Mammalia feces Homo… NA 12 GCF_0390… NCBI &lt;NA&gt; &lt;NA&gt; Homo sapiens Primates Mammalia feces Homo… NA 13 GCF_0504… NCBI &lt;NA&gt; &lt;NA&gt; Actinoptery… &lt;NA&gt; Actinopte… intestine fish NA # ℹ 35 more variables: country &lt;chr&gt;, locality &lt;chr&gt;, completeness &lt;dbl&gt;, contamination &lt;dbl&gt;, # genome_size &lt;dbl&gt;, GC &lt;dbl&gt;, N50 &lt;dbl&gt;, contigs &lt;dbl&gt;, collection_date &lt;chr&gt;, ncbi_biosample &lt;chr&gt;, # mag_name &lt;chr&gt;, eha_number &lt;chr&gt;, gtdb_representative &lt;lgl&gt;, mimag_high_quality &lt;lgl&gt;, # mimag_medium_quality &lt;lgl&gt;, common_name &lt;chr&gt;, sample_name &lt;chr&gt;, external_id &lt;chr&gt;, submitter_id &lt;chr&gt;, # env_broad &lt;chr&gt;, env_medium &lt;chr&gt;, env_local &lt;chr&gt;, env_local_context &lt;chr&gt;, host_status &lt;lgl&gt;, # disease &lt;lgl&gt;, diagnosis &lt;lgl&gt;, latitude &lt;dbl&gt;, longitude &lt;dbl&gt;, accession &lt;chr&gt;, host_disease &lt;lgl&gt;, # host_age &lt;lgl&gt;, host_type &lt;fct&gt;, country_simple &lt;chr&gt;, country_normalized &lt;chr&gt;, continent &lt;chr&gt; cluster2_MAGs &lt;- mags_by_cluster[[2]] genome_metadata %&gt;% filter(ID %in% cluster2_MAGs) # A tibble: 37 × 45 ID source species gtdb_taxonomy host_species host_order host_class isolation_source host host_summary &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; 1 EHM013277 EHI s__Lac… &lt;NA&gt; Podarcis Mu… Squamata Reptilia host-associated &lt;NA&gt; NA 2 EHM015868 EHI s__Lac… &lt;NA&gt; Podarcis Mu… Squamata Reptilia host-associated &lt;NA&gt; NA 3 EHM016594 EHI s__Lac… &lt;NA&gt; Hipposidero… Chiroptera Mammalia host-associated &lt;NA&gt; NA 4 EHM017294 EHI s__Lac… &lt;NA&gt; Rhinolophus… Chiroptera Mammalia host-associated &lt;NA&gt; NA 5 EHM020035 EHI s__Lac… &lt;NA&gt; Plecotus Au… Chiroptera Mammalia host-associated &lt;NA&gt; NA 6 EHM025059 EHI s__Lac… &lt;NA&gt; Podarcis Mu… Squamata Reptilia host-associated &lt;NA&gt; NA 7 EHM025679 EHI s__Lac… &lt;NA&gt; Podarcis Mu… Squamata Reptilia host-associated &lt;NA&gt; NA 8 EHM027656 EHI s__Lac… &lt;NA&gt; Cathartes A… Accipitri… Aves host-associated &lt;NA&gt; NA 9 EHM028200 EHI s__Lac… &lt;NA&gt; Cathartes A… Accipitri… Aves host-associated &lt;NA&gt; NA 10 EHM028346 EHI s__Lac… &lt;NA&gt; Plecotus Au… Chiroptera Mammalia host-associated &lt;NA&gt; NA # ℹ 27 more rows # ℹ 35 more variables: country &lt;chr&gt;, locality &lt;chr&gt;, completeness &lt;dbl&gt;, contamination &lt;dbl&gt;, # genome_size &lt;dbl&gt;, GC &lt;dbl&gt;, N50 &lt;dbl&gt;, contigs &lt;dbl&gt;, collection_date &lt;chr&gt;, ncbi_biosample &lt;chr&gt;, # mag_name &lt;chr&gt;, eha_number &lt;chr&gt;, gtdb_representative &lt;lgl&gt;, mimag_high_quality &lt;lgl&gt;, # mimag_medium_quality &lt;lgl&gt;, common_name &lt;chr&gt;, sample_name &lt;chr&gt;, external_id &lt;chr&gt;, submitter_id &lt;chr&gt;, # env_broad &lt;chr&gt;, env_medium &lt;chr&gt;, env_local &lt;chr&gt;, env_local_context &lt;chr&gt;, host_status &lt;lgl&gt;, # disease &lt;lgl&gt;, diagnosis &lt;lgl&gt;, latitude &lt;dbl&gt;, longitude &lt;dbl&gt;, accession &lt;chr&gt;, host_disease &lt;lgl&gt;, … genome_metadata &lt;- genome_metadata %&gt;% dplyr::mutate( ID_clean = ID %&gt;% basename() %&gt;% # remove file extensions sub(&quot;\\\\.(fna|fa|fasta)(\\\\.gz)?$&quot;, &quot;&quot;, ., ignore.case = TRUE) %&gt;% # remove GB_ or RS_ at the beginning sub(&quot;^(GB_|RS_)&quot;, &quot;&quot;, ., ignore.case = TRUE) %&gt;% # extract the real GCA/GCF accession (robust) sub(&quot;.*\\\\b(GC[AF]_[0-9]+\\\\.[0-9]+).*&quot;, &quot;\\\\1&quot;, ., perl = TRUE) ) metadata_with_cluster &lt;- genome_metadata %&gt;% left_join(coords %&gt;% dplyr::select(MAG, cluster), by = c(&quot;ID_clean&quot; = &quot;MAG&quot;)) metadata_with_cluster %&gt;% group_by(cluster, host_type) %&gt;% summarise(n = n(), .groups = &quot;drop&quot;) %&gt;% arrange(cluster, desc(n)) # A tibble: 7 × 3 cluster host_type n &lt;fct&gt; &lt;fct&gt; &lt;int&gt; 1 1 human 21 2 1 animal 16 3 2 animal 58 4 2 human 20 5 2 &lt;NA&gt; 1 6 &lt;NA&gt; animal 10 7 &lt;NA&gt; human 1 # Group summaries metadata_with_cluster %&gt;% group_by(cluster) %&gt;% summarise(mean_genome_size = mean(genome_size, na.rm = TRUE), median_contamination = median(contamination, na.rm = TRUE), .groups = &quot;drop&quot;) # A tibble: 3 × 3 cluster mean_genome_size median_contamination &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; 1 1 2392085. 0.52 2 2 2415231. 0.35 3 &lt;NA&gt; 2367492. 0.52 # save(ehi_mags, # phylum_colors, # genome_annotations, # genome_gifts, # contig_to_genome, # gtdb_metadata, # ehi_metadata, # master_index, # genome_metadata, # host_type_colors, # getphylo_tree, # metadata_with_cluster, # file = &quot;data/data.Rdata&quot;) Is the genome size different between clusters? kruskal.test(genome_size ~ cluster, data = metadata_with_cluster) Kruskal-Wallis rank sum test data: genome_size by cluster Kruskal-Wallis chi-squared = 0.079169, df = 1, p-value = 0.7784 pairwise.wilcox.test( x = metadata_with_cluster$genome_size, g = metadata_with_cluster$cluster, p.adjust.method = &quot;BH&quot; # FDR correction ) Pairwise comparisons using Wilcoxon rank sum test with continuity correction data: metadata_with_cluster$genome_size and metadata_with_cluster$cluster 1 2 0.78 P value adjustment method: BH Plots ggplot(metadata_with_cluster, aes(x = genome_size, y = GC, col = cluster))+ geom_point()+ theme_bw() ggplot(metadata_with_cluster, aes(x = cluster, y = genome_size, col = cluster))+ geom_point()+ theme_bw() count_table &lt;- metadata_with_cluster %&gt;% filter(!is.na(cluster))%&gt;% dplyr::count(cluster, host_type) %&gt;% pivot_wider( names_from = host_type, values_from = n, values_fill = 0 ) count_table # A tibble: 2 × 4 cluster animal human `NA` &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 1 16 21 0 2 2 58 20 1 mat &lt;- metadata_with_cluster %&gt;% filter(!is.na(cluster))%&gt;% dplyr::count(cluster, host_type) %&gt;% pivot_wider(names_from = host_type, values_from = n, values_fill = 0) %&gt;% column_to_rownames(&quot;cluster&quot;) %&gt;% as.matrix() chisq.test(mat)$expected Warning in stats::chisq.test(x, y, ...): Chi-squared approximation may be incorrect animal human NA 1 23.60345 13.07759 0.3189655 2 50.39655 27.92241 0.6810345 fisher.test(mat) Fisher&#39;s Exact Test for Count Data data: mat p-value = 0.002253 alternative hypothesis: two.sided #Aggregate bundle-level GIFTs into the compound level GIFTs_elements &lt;- to.elements(genome_gifts,GIFT_db) #Aggregate element-level GIFTs into the function level GIFTs_functions &lt;- to.functions(GIFTs_elements,GIFT_db) #Aggregate function-level GIFTs into overall Biosynthesis, Degradation and Structural GIFTs GIFTs_domains &lt;- to.domains(GIFTs_functions,GIFT_db) 7.3.3 GIFT community plots GIFTs_elements %&gt;% as.data.frame() %&gt;% rownames_to_column(var=&quot;MAG&quot;)%&gt;% pivot_longer(!MAG,names_to=&quot;trait&quot;,values_to=&quot;gift&quot;) %&gt;% left_join(metadata_with_cluster, by = join_by(MAG == ID)) %&gt;% mutate(functionid = substr(trait, 1, 3)) %&gt;% mutate(trait = case_when( trait %in% GIFT_db$Code_element ~ GIFT_db$Element[match(trait, GIFT_db$Code_element)], TRUE ~ trait )) %&gt;% mutate(functionid = case_when( functionid %in% GIFT_db$Code_function ~ GIFT_db$Function[match(functionid, GIFT_db$Code_function)], TRUE ~ functionid )) %&gt;% mutate(trait=factor(trait,levels=unique(GIFT_db$Element))) %&gt;% mutate(functionid=factor(functionid,levels=unique(GIFT_db$Function))) %&gt;% ggplot(aes(x=MAG,y=trait,fill=gift)) + geom_tile(colour=&quot;white&quot;, linewidth=0.2)+ scale_fill_gradientn(colours=rev(c(&quot;#d53e4f&quot;, &quot;#f46d43&quot;, &quot;#fdae61&quot;, &quot;#fee08b&quot;, &quot;#e6f598&quot;, &quot;#abdda4&quot;, &quot;#ddf1da&quot;)))+ facet_grid(functionid ~ cluster, scales=&quot;free&quot;,space=&quot;free&quot;) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), axis.text.y = element_text(size=6), strip.text.y = element_text(angle = 0) ) + labs(y=&quot;Traits&quot;,x=&quot;Samples&quot;,fill=&quot;GIFT&quot;) p &lt;- GIFTs_elements %&gt;% as.data.frame() %&gt;% rownames_to_column(var=&quot;MAG&quot;)%&gt;% pivot_longer(!MAG,names_to=&quot;trait&quot;,values_to=&quot;gift&quot;) %&gt;% left_join(metadata_with_cluster, by = join_by(MAG == ID)) %&gt;% mutate(functionid = substr(trait, 1, 3)) %&gt;% mutate(trait = case_when( trait %in% GIFT_db$Code_element ~ GIFT_db$Element[match(trait, GIFT_db$Code_element)], TRUE ~ trait )) %&gt;% mutate(functionid = case_when( functionid %in% GIFT_db$Code_function ~ GIFT_db$Function[match(functionid, GIFT_db$Code_function)], TRUE ~ functionid )) %&gt;% mutate(trait=factor(trait,levels=unique(GIFT_db$Element))) %&gt;% mutate(functionid=factor(functionid,levels=unique(GIFT_db$Function))) %&gt;% ggplot(aes(x=MAG,y=trait,fill=gift)) + geom_tile(colour=&quot;white&quot;, linewidth=0.2)+ scale_fill_gradientn(colours=rev(c(&quot;#d53e4f&quot;, &quot;#f46d43&quot;, &quot;#fdae61&quot;, &quot;#fee08b&quot;, &quot;#e6f598&quot;, &quot;#abdda4&quot;, &quot;#ddf1da&quot;)))+ facet_grid(functionid ~ host_type, scales=&quot;free&quot;,space=&quot;free&quot;) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), axis.text.y = element_text(size=6), strip.text.y = element_text(angle = 0) ) + labs(y=&quot;Traits&quot;,x=&quot;Samples&quot;,fill=&quot;GIFT&quot;) p ggplot2::ggsave( filename = &quot;plots/GIFT_heatmap_final.png&quot;, plot = p, width = 14, height = 16, units = &quot;in&quot;, dpi = 600, bg = &quot;white&quot; ) library(RColorBrewer) library(reshape2) Warning: package &#39;reshape2&#39; was built under R version 4.4.3 Adjuntando el paquete: &#39;reshape2&#39; The following object is masked from &#39;package:tidyr&#39;: smiths GIFTs_elements %&gt;% melt() %&gt;% dplyr::rename(Genome = Var1, Code_element = Var2, GIFT = value) %&gt;% inner_join(GIFT_db, by = &quot;Code_element&quot;) %&gt;% filter(str_starts(Code_element, &quot;D09&quot;)) %&gt;% left_join(metadata_with_cluster, by = join_by(Genome == ID)) %&gt;% mutate(cluster = factor(cluster)) %&gt;% droplevels() %&gt;% arrange(cluster, Genome) %&gt;% mutate(trait = Element) %&gt;% # Ensure trait is a factor to maintain order mutate(trait = factor(trait, levels = rev(unique(GIFT_db$Element)))) %&gt;% ggplot( aes(x = Genome, y = trait)) + # Heatmap geom_tile(aes(fill = GIFT), color = &quot;white&quot;) + scale_fill_gradientn(colours = brewer.pal(7, &quot;YlGnBu&quot;), name = &quot;GIFT Score&quot;) + # Start a new fill scale for the host_type bar new_scale_fill() + # Add the host_type bar at the very top or bottom geom_tile(aes(y = -0.5, fill = host_type), height = 0.5) + scale_fill_manual(values = host_type_colors) + facet_grid(~ cluster, scales = &quot;free_x&quot;, space = &quot;free_x&quot;) + theme_minimal(base_size = 8) + theme(axis.text.x = element_text(angle = 90, hjust = 1)) Warning in inner_join(., GIFT_db, by = &quot;Code_element&quot;): Detected an unexpected many-to-many relationship between `x` and `y`. ℹ Row 1121 of `x` matches multiple rows in `y`. ℹ Row 1 of `y` matches multiple rows in `x`. ℹ If a many-to-many relationship is expected, set `relationship = &quot;many-to-many&quot;` to silence this warning. 7.3.4 Checking difference in GIFTs 7.3.4.1 Cluster-wise Element GIFTs different between clusters of pcoa # Get only the GIFT columns gift_cols &lt;- colnames(GIFTs_elements)[!(colnames(GIFTs_elements) %in% c(&quot;genome&quot;,&quot;cluster&quot;,&quot;host_type&quot;))] gift_dataframe &lt;- GIFTs_elements %&gt;% as.data.frame() %&gt;% rownames_to_column(var = &quot;ID&quot;) gift_df_meta &lt;- gift_dataframe %&gt;% left_join(metadata_with_cluster, by = &quot;ID&quot;) # Kruskal-Wallis for 4 groups kruskal_results &lt;- sapply(gift_cols, function(g) { kruskal.test(as.formula(paste(g, &quot;~ cluster&quot;)), data = gift_df_meta)$p.value }) # Adjust for multiple testing kruskal_results_adj &lt;- p.adjust(kruskal_results, method = &quot;BH&quot;) # Combine into a table kruskal_table &lt;- data.frame( GIFT = gift_cols, p_value = kruskal_results, p_adj = kruskal_results_adj ) kruskal_table %&gt;% filter(p_adj&lt;0.05) GIFT p_value p_adj B0601 B0601 5.011737e-04 9.021127e-03 D0908 D0908 2.559625e-12 9.214650e-11 pairwise_results &lt;- lapply(gift_cols, function(g) { pairwise.wilcox.test( x = gift_df_meta[[g]], g = gift_df_meta$cluster, p.adjust.method = &quot;BH&quot; ) }) names(pairwise_results) &lt;- gift_cols pairwise_sig_table &lt;- lapply(names(pairwise_results), function(g) { # Extract p-value matrix pmat &lt;- pairwise_results[[g]]$p.value # Convert to long format pmat_long &lt;- as.data.frame(as.table(pmat)) %&gt;% filter(!is.na(Freq)) %&gt;% # remove NA (diagonal / upper triangle) dplyr::rename(group1 = Var1, group2 = Var2, p_adj = Freq) %&gt;% filter(p_adj &lt; 0.05) %&gt;% mutate(GIFT = g) return(pmat_long) }) # Combine all GIFTs into one table pairwise_sig_table &lt;- bind_rows(pairwise_sig_table) %&gt;% dplyr::select(GIFT, group1, group2, p_adj) pairwise_sig_table GIFT group1 group2 p_adj 1 B0601 2 1 5.470079e-04 2 B0704 2 1 2.246680e-02 3 D0507 2 1 1.442942e-02 4 D0908 2 1 2.839505e-12 GIFTs_elements %&gt;% melt() %&gt;% dplyr::rename(Genome = Var1, Code_element = Var2, GIFT = value) %&gt;% inner_join(GIFT_db, by = &quot;Code_element&quot;) %&gt;% filter(Code_element %in% pairwise_sig_table$GIFT) %&gt;% left_join(metadata_with_cluster, by = join_by(Genome == ID)) %&gt;% distinct(Genome, Code_element, .keep_all = TRUE) %&gt;% mutate(cluster = factor(cluster)) %&gt;% droplevels() %&gt;% arrange(cluster, Genome) %&gt;% mutate(trait = Element) %&gt;% ggplot(aes(x = Genome, y = trait, fill = GIFT)) + geom_tile(colour = &quot;white&quot;, linewidth = 0.2) + scale_y_discrete(guide = guide_axis(check.overlap = TRUE)) + scale_x_discrete(guide = guide_axis(check.overlap = TRUE)) + scale_fill_gradientn(limits = c(0,1), colours = RColorBrewer::brewer.pal(7, &quot;YlGnBu&quot;)) + new_scale_fill() + # Add the host_type bar at the very top or bottom geom_tile(aes(y = -0.5, fill = host_type), height = 0.3) + scale_fill_manual(values = host_type_colors, name = &quot;host_type&quot;) + facet_grid(~ cluster, scales = &quot;free_x&quot;, space = &quot;free_x&quot;) + theme( axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, size = 4), strip.text.x = element_text(face = &quot;bold&quot;) ) + labs(y = &quot;Trait&quot;, x = &quot;Genome&quot;, fill = &quot;GIFT&quot;) Warning in inner_join(., GIFT_db, by = &quot;Code_element&quot;): Detected an unexpected many-to-many relationship between `x` and `y`. ℹ Row 1121 of `x` matches multiple rows in `y`. ℹ Row 1 of `y` matches multiple rows in `x`. ℹ If a many-to-many relationship is expected, set `relationship = &quot;many-to-many&quot;` to silence this warning. GIFT_db%&gt;% filter(Code_element %in% pairwise_sig_table$GIFT) Code_bundle Code_element Code_function Domain Function Element 1 B060101 B0601 B06 Biosynthesis Organic anion biosynthesis Succinate 2 B060102 B0601 B06 Biosynthesis Organic anion biosynthesis Succinate 3 B060103 B0601 B06 Biosynthesis Organic anion biosynthesis Succinate 4 B060104 B0601 B06 Biosynthesis Organic anion biosynthesis Succinate 5 B060105 B0601 B06 Biosynthesis Organic anion biosynthesis Succinate 6 B060106 B0601 B06 Biosynthesis Organic anion biosynthesis Succinate 7 B070401 B0704 B07 Biosynthesis Vitamin biosynthesis Pantothenate (B5) 8 B070402 B0704 B07 Biosynthesis Vitamin biosynthesis Pantothenate (B5) 9 D050701 D0507 D05 Degradation Amino acid degradation Leucine 10 D090801 D0908 D09 Degradation Antibiotic degradation Macrolide Definition 1 (K01647,K05942) (K01681,K01682) (K00031,K00030) ((((K00164+K00658),K01616)+K00382),(K00174+K00175)) ((K01902+K01903),(K01899+K01900),K18118) ((K00234+K00235+K00236+(K00237,K25801)),(K00239+K00240+K00241),(K00244+K00245+K00246)) (K01676,K01679,(K01677+K01678)) (K00026,K00025,K00024,K00116) 2 ((((K00164+K00658),K01616)+K00382),K00174) ((K01902+K01903),(K01899+K01900),K18118) ((K00234+K00235+K00236+(K00237,K25801)),(K00239+K00240+K00241),(K00244+K00245+K00246)) (K01676,K01679,(K01677+K01678)) (K00026,K00025,K00024,K00116) 3 K01580 (K13524,K07250,K00823,K16871) (K00135,K00139,K17761) 4 (K00169+K00170+K00171+K00172) K01007 K01595 K00024 (K01677+K01678) (K00239+K00240) (K01902+K01903) (K15038,K15017) K14465 (K14467,K18861) K14534 K15016 K00626 5 (K02160+K01961+K01962+K01963) K14468 K14469 K15052 K05606 (K01847,(K01848+K01849)) (K14471+K14472) (K00239+K00240+K00241) K01679 K08691 K14449 K14470 K09709 6 (K00169+K00170+K00171+K00172) (K01959+K01960) K00024 (K01677+K01678) (K18209+K18210) (K01902+K01903) (K00174+K00175+K00176+K00177) 7 ((K00826 K00606 K00077),K01579) (K01918,K13799) 8 ((K00606 K00077),(K13367 K00128)) K01918 9 K00826 (((K00166+K00167),K11381)+K09699+K00382) (K00253,K00249) (K01968+K01969) (K05607,K13766) K01640 10 K06979,K08217,K18230,K18231,K21251 library(rstatix) library(dplyr) library(purrr) pairwise_sig_table &lt;- map_df(gift_cols, function(g) { # Check if there is variation in the GIFT values # If all values are the same, skip this GIFT if(length(unique(gift_df_meta[[g]])) &lt; 2) return(NULL) # Run the test safely tryCatch({ results &lt;- gift_df_meta %&gt;% wilcox_test(as.formula(paste0(&quot;`&quot;, g, &quot;` ~ cluster&quot;)), p.adjust.method = &quot;BH&quot;) eff &lt;- gift_df_meta %&gt;% wilcox_effsize(as.formula(paste0(&quot;`&quot;, g, &quot;` ~ cluster&quot;))) results %&gt;% left_join(eff, by = c(&quot;group1&quot;, &quot;group2&quot;, &quot;.y.&quot; = &quot;.y.&quot;, &quot;n1&quot;, &quot;n2&quot;)) %&gt;% filter(p.adj &lt; 0.05) %&gt;% mutate(GIFT = g) }, error = function(e) return(NULL)) # If it still fails, just skip it }) top_gifts &lt;- pairwise_sig_table %&gt;% arrange(desc(effsize)) top_gifts # A tibble: 3 × 12 .y. group1 group2 n1 n2 statistic p p.adj p.adj.signif effsize magnitude GIFT &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;ord&gt; &lt;chr&gt; 1 B0601 1 2 13 37 166. 0.000547 0.000547 *** 0.492 moderate B0601 2 D0507 1 2 13 37 166 0.014 0.014 * 0.348 moderate D0507 3 B0704 1 2 13 37 192. 0.022 0.022 * 0.326 moderate B0704 GIFTs_elements %&gt;% melt() %&gt;% dplyr::rename(Genome = Var1, Code_element = Var2, GIFT = value) %&gt;% inner_join(GIFT_db, by = &quot;Code_element&quot;) %&gt;% filter(Code_element %in% pairwise_sig_table$GIFT) %&gt;% left_join(metadata_with_cluster, by = join_by(Genome == ID)) %&gt;% distinct(Genome, Code_element, .keep_all = TRUE) %&gt;% mutate(cluster = factor(cluster)) %&gt;% droplevels() %&gt;% arrange(cluster, Genome) %&gt;% mutate(trait = Element) %&gt;% ggplot(aes(x = Genome, y = trait, fill = GIFT)) + geom_tile(colour = &quot;white&quot;, linewidth = 0.2) + scale_y_discrete(guide = guide_axis(check.overlap = TRUE)) + scale_x_discrete(guide = guide_axis(check.overlap = TRUE)) + scale_fill_gradientn(limits = c(0,1), colours = RColorBrewer::brewer.pal(7, &quot;YlGnBu&quot;)) + facet_grid(~ cluster, scales = &quot;free_x&quot;, space = &quot;free_x&quot;) + theme_grey(base_size = 8) + theme( axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1), strip.text.x = element_text(face = &quot;bold&quot;) ) + labs(y = &quot;Trait&quot;, x = &quot;Genome&quot;, fill = &quot;GIFT&quot;) Warning in inner_join(., GIFT_db, by = &quot;Code_element&quot;): Detected an unexpected many-to-many relationship between `x` and `y`. ℹ Row 1121 of `x` matches multiple rows in `y`. ℹ Row 1 of `y` matches multiple rows in `x`. ℹ If a many-to-many relationship is expected, set `relationship = &quot;many-to-many&quot;` to silence this warning. 7.3.4.2 host_type-wise GIFTs that are different between EHI and GTDB wilcox_results &lt;- sapply(gift_cols, function(g) { wilcox.test(as.formula(paste(g, &quot;~ host_type&quot;)), data = gift_df_meta)$p.value }) wilcox_results_adj &lt;- p.adjust(wilcox_results, method = &quot;BH&quot;) data.frame( GIFT = gift_cols, p_value = wilcox_results, p_adj = wilcox_results_adj ) GIFT p_value p_adj B0101 B0101 0.553951606 0.7865086 B0102 B0102 0.454067596 0.7865086 B0103 B0103 NaN NaN B0104 B0104 0.699118745 0.7865086 B0105 B0105 0.819762622 0.8679840 B0106 B0106 0.699118745 0.7865086 B0204 B0204 NaN NaN B0205 B0205 0.699118745 0.7865086 B0206 B0206 NaN NaN B0207 B0207 0.699118745 0.7865086 B0208 B0208 0.699118745 0.7865086 B0209 B0209 0.699118745 0.7865086 B0210 B0210 0.699118745 0.7865086 B0211 B0211 0.669187269 0.7865086 B0212 B0212 NaN NaN B0213 B0213 NaN NaN B0214 B0214 NaN NaN B0215 B0215 0.315200758 0.7865086 B0216 B0216 NaN NaN B0217 B0217 NaN NaN B0218 B0218 NaN NaN B0219 B0219 0.699118745 0.7865086 B0220 B0220 NaN NaN B0221 B0221 NaN NaN B0302 B0302 NaN NaN B0303 B0303 NaN NaN B0307 B0307 0.699118745 0.7865086 B0309 B0309 NaN NaN B0310 B0310 NaN NaN B0401 B0401 NaN NaN B0402 B0402 NaN NaN B0403 B0403 NaN NaN B0601 B0601 0.377067975 0.7865086 B0602 B0602 NaN NaN B0603 B0603 0.699118745 0.7865086 B0604 B0604 NaN NaN B0605 B0605 NaN NaN B0701 B0701 0.553951606 0.7865086 B0702 B0702 NaN NaN B0703 B0703 NaN NaN B0704 B0704 0.376743600 0.7865086 B0705 B0705 NaN NaN B0706 B0706 NaN NaN B0707 B0707 0.699118745 0.7865086 B0708 B0708 NaN NaN B0709 B0709 NaN NaN B0710 B0710 NaN NaN B0711 B0711 NaN NaN B0712 B0712 NaN NaN B0801 B0801 NaN NaN B0802 B0802 NaN NaN B0803 B0803 NaN NaN B0804 B0804 NaN NaN B0805 B0805 NaN NaN B0901 B0901 NaN NaN B0902 B0902 NaN NaN B0903 B0903 NaN NaN B1004 B1004 NaN NaN B1006 B1006 NaN NaN B1008 B1008 NaN NaN B1011 B1011 NaN NaN B1012 B1012 NaN NaN B1014 B1014 NaN NaN B1021 B1021 NaN NaN B1022 B1022 NaN NaN B1024 B1024 NaN NaN B1026 B1026 NaN NaN B1028 B1028 0.466154044 0.7865086 B1029 B1029 NaN NaN B1041 B1041 0.376743600 0.7865086 B1042 B1042 NaN NaN D0101 D0101 0.699118745 0.7865086 D0102 D0102 0.699118745 0.7865086 D0103 D0103 NaN NaN D0104 D0104 NaN NaN D0201 D0201 NaN NaN D0202 D0202 NaN NaN D0203 D0203 NaN NaN D0204 D0204 NaN NaN D0205 D0205 NaN NaN D0206 D0206 NaN NaN D0207 D0207 NaN NaN D0208 D0208 NaN NaN D0209 D0209 NaN NaN D0210 D0210 NaN NaN D0211 D0211 NaN NaN D0212 D0212 NaN NaN D0213 D0213 NaN NaN D0301 D0301 NaN NaN D0302 D0302 NaN NaN D0303 D0303 NaN NaN D0304 D0304 NaN NaN D0305 D0305 NaN NaN D0306 D0306 NaN NaN D0307 D0307 NaN NaN D0308 D0308 NaN NaN D0309 D0309 1.000000000 1.0000000 D0310 D0310 NaN NaN D0401 D0401 NaN NaN D0402 D0402 NaN NaN D0403 D0403 NaN NaN D0404 D0404 NaN NaN D0405 D0405 NaN NaN D0406 D0406 NaN NaN D0407 D0407 NaN NaN D0408 D0408 NaN NaN D0501 D0501 NaN NaN D0502 D0502 NaN NaN D0503 D0503 NaN NaN D0504 D0504 NaN NaN D0505 D0505 NaN NaN D0506 D0506 NaN NaN D0507 D0507 0.733176720 0.7998291 D0508 D0508 0.006259432 0.2253395 D0509 D0509 0.699118745 0.7865086 D0510 D0510 NaN NaN D0511 D0511 NaN NaN D0512 D0512 NaN NaN D0513 D0513 NaN NaN D0516 D0516 NaN NaN D0517 D0517 NaN NaN D0518 D0518 NaN NaN D0601 D0601 NaN NaN D0602 D0602 NaN NaN D0603 D0603 NaN NaN D0604 D0604 NaN NaN D0606 D0606 NaN NaN D0607 D0607 NaN NaN D0608 D0608 NaN NaN D0609 D0609 NaN NaN D0610 D0610 NaN NaN D0611 D0611 NaN NaN D0612 D0612 NaN NaN D0613 D0613 NaN NaN D0701 D0701 NaN NaN D0702 D0702 NaN NaN D0704 D0704 NaN NaN D0705 D0705 NaN NaN D0706 D0706 NaN NaN D0708 D0708 NaN NaN D0709 D0709 NaN NaN D0801 D0801 NaN NaN D0802 D0802 NaN NaN D0804 D0804 0.027200351 0.4896063 D0805 D0805 NaN NaN D0806 D0806 NaN NaN D0807 D0807 0.393627743 0.7865086 D0808 D0808 NaN NaN D0809 D0809 NaN NaN D0810 D0810 NaN NaN D0811 D0811 NaN NaN D0812 D0812 NaN NaN D0813 D0813 NaN NaN D0814 D0814 NaN NaN D0815 D0815 NaN NaN D0816 D0816 0.061141985 0.5769099 D0817 D0817 NaN NaN D0818 D0818 NaN NaN D0819 D0819 NaN NaN D0901 D0901 NaN NaN D0902 D0902 NaN NaN D0903 D0903 NaN NaN D0904 D0904 NaN NaN D0905 D0905 NaN NaN D0906 D0906 0.553951606 0.7865086 D0907 D0907 NaN NaN D0908 D0908 0.107578984 0.7745687 D0910 D0910 NaN NaN D0911 D0911 NaN NaN D0912 D0912 NaN NaN S0101 S0101 NaN NaN S0103 S0103 NaN NaN S0104 S0104 NaN NaN S0105 S0105 0.064101099 0.5769099 S0201 S0201 0.699118745 0.7865086 S0202 S0202 1.000000000 1.0000000 S0301 S0301 0.699118745 0.7865086 effect_size &lt;- sapply(gift_cols, function(g) { median(gift_df_meta[[g]][gift_df_meta$host_type==&quot;human&quot;]) - median(gift_df_meta[[g]][gift_df_meta$host_type==&quot;animal&quot;]) }) wilcox_res_host_type &lt;- data.frame( GIFT = gift_cols, p_value = wilcox_results, p_adj = wilcox_results_adj, effect = effect_size ) wilcox_res_host_type %&gt;% dplyr::select(GIFT, p_adj, effect) %&gt;% filter(p_adj&lt;0.05) [1] GIFT p_adj effect &lt;0 rows&gt; (o 0- extensión row.names) GIFT_db%&gt;% filter(Code_element %in% c(&quot;B0215&quot;, &quot;B0701&quot;, &quot;D0508&quot;) ) Code_bundle Code_element Code_function Domain Function Element 1 B021501 B0215 B02 Biosynthesis Amino acid biosynthesis Histidine 2 B070101 B0701 B07 Biosynthesis Vitamin biosynthesis Thiamine (B1) 3 B070102 B0701 B07 Biosynthesis Vitamin biosynthesis Thiamine (B1) 4 B070103 B0701 B07 Biosynthesis Vitamin biosynthesis Thiamine (B1) 5 B070104 B0701 B07 Biosynthesis Vitamin biosynthesis Thiamine (B1) 6 D050801 D0508 D05 Degradation Amino acid degradation Lysine 7 D050802 D0508 D05 Degradation Amino acid degradation Lysine 8 D050803 D0508 D05 Degradation Amino acid degradation Lysine 9 D050804 D0508 D05 Degradation Amino acid degradation Lysine 10 D050805 D0508 D05 Degradation Amino acid degradation Lysine 11 D050806 D0508 D05 Degradation Amino acid degradation Lysine Definition 1 K00765 ((K01523 K01496),K11755,K14152) (K01814,K24017) ((K02501+K02500),K01663) ((K01693 K00817 (K04486,K05602,K18649)),(K01089 K00817)) (K00013,K14152) 2 (((K03148+K03154) K03151),(K03150 K03149)) K03147 ((K00941 K00788),K14153,K21219) K00946 3 (((K03148+K03154) K03151),(K03153 K03149 K10810)) K03147 K00941 K00788 K00946 4 (K22699,K03147) ((K00941 (K00788,K21220)),K21219) K00946 5 (K00941 K00788),K14153,K21219 6 4.1.1.18 2.6.1.82 1.2.1.19 2.6.1.48 1.2.1.20 1.14.11.64 1.1.5.13 7 1.13.12.2 3.5.1.30 1.6.1.48 1.2.1.20 2.8.3.13 8 2.6.1.36 1.2.1.31 9 4.1.1.18 2.6.1.82 1.2.1.19 2.6.1.48 1.2.1.20 2.8.3.13 10 K01582 K09251 K00137 K07250 K00135 K15737 K15736 11 K00468 K01506 (K14268,K07250) K00135 ((K15737 K15736),(K01041 K00252 (K01692,K01825,K01782) (K01825,K01782) K00626)) wilcox_res_host_type &lt;- map_df(gift_cols, function(g) { if(length(unique(gift_df_meta[[g]])) &lt; 2) return(NULL) tryCatch({ # Calculate p-value res &lt;- gift_df_meta %&gt;% wilcox_test(as.formula(paste0(&quot;`&quot;, g, &quot;` ~ host_type&quot;))) # Calculate effect size (Rank-Biserial Correlation) eff &lt;- gift_df_meta %&gt;% wilcox_effsize(as.formula(paste0(&quot;`&quot;, g, &quot;` ~ host_type&quot;))) # Combine results res %&gt;% left_join(eff, by = c(&quot;group1&quot;, &quot;group2&quot;, &quot;.y.&quot; = &quot;.y.&quot;, &quot;n1&quot;, &quot;n2&quot;)) %&gt;% mutate(GIFT = g) }, error = function(e) return(NULL)) }) # Adjust P-values and filter wilcox_res_host_type &lt;- wilcox_res_host_type %&gt;% mutate(p_adj = p.adjust(p, method = &quot;BH&quot;)) %&gt;% dplyr::select(GIFT, group1, group2, p_adj, effsize, magnitude) %&gt;% filter(p_adj &lt; 0.05) %&gt;% arrange(desc(abs(effsize))) # Sort by strongest effect # View the top results print(wilcox_res_host_type) # A tibble: 0 × 6 # ℹ 6 variables: GIFT &lt;chr&gt;, group1 &lt;chr&gt;, group2 &lt;chr&gt;, p_adj &lt;dbl&gt;, effsize &lt;dbl&gt;, magnitude &lt;ord&gt; host_class_colors &lt;- c( &quot;Mammalia&quot; = &quot;#8B1E3F&quot;, &quot;Reptilia&quot; = &quot;#3A7D44&quot;, &quot;Aves&quot; = &quot;#E1B12C&quot; ) GIFTs_elements %&gt;% melt() %&gt;% dplyr::rename(Genome = Var1, Code_element = Var2, GIFT = value) %&gt;% inner_join(GIFT_db, by = &quot;Code_element&quot;) %&gt;% filter(Code_element %in% wilcox_res_host_type$GIFT) %&gt;% left_join(metadata_with_cluster, by = join_by(Genome == ID)) %&gt;% distinct(Genome, Code_element, .keep_all = TRUE) %&gt;% mutate(cluster = factor(cluster)) %&gt;% droplevels() %&gt;% arrange(cluster, Genome) %&gt;% mutate(trait = Element) %&gt;% ggplot(aes(x = Genome, y = trait, fill = GIFT)) + geom_tile(colour = &quot;white&quot;, linewidth = 0.2) + scale_y_discrete(guide = guide_axis(check.overlap = TRUE)) + scale_x_discrete(guide = guide_axis(check.overlap = TRUE)) + scale_fill_gradientn(limits = c(0,1), colours = RColorBrewer::brewer.pal(7, &quot;YlGnBu&quot;)) + new_scale_fill() + # Add the host_type bar at the very top or bottom geom_tile(aes(y = -0.5, fill = host_class), height = 0.5) + facet_grid(~ host_type, scales = &quot;free_x&quot;, space = &quot;free_x&quot;) + scale_fill_manual(values = host_class_colors, name = &quot;Host class&quot;) theme( axis.text.x = element_blank() ) + labs(y = &quot;Trait&quot;, x = &quot;Genome&quot;, fill = &quot;GIFT&quot;) "],["antibiotic-resistance-analysis.html", "Chapter 8 Antibiotic resistance analysis 8.1 Building an AMR abundance table 8.2 PERMANOVA presence/absence 8.3 PCoA presence/absence 8.4 Testing proportions (Fisher)", " Chapter 8 Antibiotic resistance analysis 8.0.1 Nº of MAGs with AMRs # AMR presence/absence amr_presence &lt;- genome_annotations %&gt;% filter(resistance_type == &quot;AMR&quot;) %&gt;% dplyr::select(genome, resistance_target) %&gt;% distinct() #Add the host_type info amr_with_host_type &lt;- amr_presence %&gt;% left_join( genome_metadata %&gt;% dplyr::select(ID, host_type), by = c(&quot;genome&quot; = &quot;ID&quot;) ) # Count how many MAGs in each AMR amr_mag_counts &lt;- amr_with_host_type %&gt;% group_by(host_type, resistance_target) %&gt;% summarise( n_mags = n(), .groups = &quot;drop&quot; ) #Count total MAGs per host_type total_mags_per_host_type &lt;- genome_metadata %&gt;% group_by(host_type) %&gt;% summarise( total_mags = n_distinct(ID), .groups = &quot;drop&quot; ) #Calculate proportions of MAGs from each host_type in each AMR amr_mag_proportions &lt;- amr_mag_counts %&gt;% left_join(total_mags_per_host_type, by = &quot;host_type&quot;) %&gt;% mutate( proportion = n_mags / total_mags, absent = total_mags - n_mags ) 8.0.1.1 Statistical testing of MAG proportions fisher_results &lt;- amr_mag_proportions %&gt;% dplyr::select(resistance_target, host_type, n_mags, absent) %&gt;% pivot_wider( names_from = host_type, values_from = c(n_mags, absent), values_fill = 0 ) %&gt;% rowwise() %&gt;% mutate( p_value = fisher.test( matrix( c(n_mags_animal, absent_animal, n_mags_human, absent_human), nrow = 2, byrow = TRUE ) )$p.value ) %&gt;% ungroup() %&gt;% mutate(p_adj = p.adjust(p_value, method = &quot;BH&quot;)) fisher_results &lt;- fisher_results %&gt;% mutate( prop_animal = n_mags_animal / (n_mags_animal + absent_animal), prop_human = n_mags_human / (n_mags_human + absent_human), diff_prop = prop_human - prop_animal ) fisher_results%&gt;% filter(p_adj &lt; 0.05) # A tibble: 32 × 12 resistance_target n_mags_animal n_mags_human n_mags_NA absent_animal absent_human absent_NA p_value p_adj &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; 1 AMIKACIN/KANAMYCIN… 41 8 91 43 34 -90 0.00173 0.00266 2 AMINOGLYCOSIDE 41 8 91 43 34 -90 0.00173 0.00266 3 AVILAMYCIN 41 8 91 43 34 -90 0.00173 0.00266 4 AZITHROMYCIN/ERYTH… 17 1 43 67 41 -42 0.00610 0.00820 5 BETA-LACTAM 41 8 91 43 34 -90 0.00173 0.00266 6 BLEOMYCIN 39 8 90 45 34 -89 0.00324 0.00449 7 CHLORAMPHENICOL 41 8 91 43 34 -90 0.00173 0.00266 8 CHLORAMPHENICOL/FL… 41 8 91 43 34 -90 0.00173 0.00266 9 CLINDAMYCIN/LINCOM… 41 8 91 43 34 -90 0.00173 0.00266 10 FLORFENICOL/OXAZOL… 41 8 91 43 34 -90 0.00173 0.00266 # ℹ 22 more rows # ℹ 3 more variables: prop_animal &lt;dbl&gt;, prop_human &lt;dbl&gt;, diff_prop &lt;dbl&gt; 8.1 Building an AMR abundance table # select the AMR annotations amr_abundance &lt;- genome_annotations %&gt;% filter(resistance_type == &quot;AMR&quot;) %&gt;% group_by(genome, resistance_target) %&gt;% summarise(count = n(), .groups=&quot;drop&quot;) %&gt;% tidyr::pivot_wider( names_from = resistance_target, values_from = count, values_fill = 0 ) amr_cluster &lt;- amr_abundance %&gt;% dplyr::full_join(metadata_with_cluster, by= join_by(genome == ID)) amr_cluster %&gt;% dplyr::select(&quot;BETA-LACTAM&quot;, &quot;MACROLIDE&quot;, genome, cluster) %&gt;% group_by( cluster) %&gt;% summarise(mean_beta_lactam = mean(`BETA-LACTAM`, na.rm = TRUE), mean_macrolide = mean(MACROLIDE, na.rm = TRUE)) # A tibble: 3 × 3 cluster mean_beta_lactam mean_macrolide &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; 1 1 6.08 11.4 2 2 6.08 10.9 3 &lt;NA&gt; 6.13 10.3 amr_matrix &lt;- amr_abundance %&gt;% column_to_rownames(&quot;genome&quot;) %&gt;% as.matrix() # Abundance heatmap min_val &lt;- min(amr_matrix, na.rm = TRUE) max_val &lt;- max(amr_matrix, na.rm = TRUE) colors &lt;- viridis(100, option = &quot;viridis&quot;) breaks &lt;- seq(min_val, max_val, length.out = 101) pheatmap( amr_matrix, color = colors, cluster_rows = FALSE, cluster_cols = TRUE, fontsize = 9, border_color = NA ) amr_presence &lt;- amr_abundance %&gt;% column_to_rownames(&quot;genome&quot;) %&gt;% mutate(across(everything(), ~ ifelse(. &gt; 0, 1, 0)))%&gt;% as.matrix() pheatmap( amr_presence, cluster_rows = TRUE, cluster_cols = TRUE, color = c(&quot;white&quot;, &quot;darkblue&quot;), # white = absent, black = present legend_breaks = c(0,1), legend_labels = c(&quot;Absent&quot;, &quot;Present&quot;), border_color = NA ) pheatmap( amr_presence, cluster_rows = FALSE, cluster_cols = TRUE, color = c(&quot;white&quot;, &quot;darkblue&quot;), # white = absent, black = present legend_breaks = c(0,1), legend_labels = c(&quot;Absent&quot;, &quot;Present&quot;), border_color = NA ) 8.2 PERMANOVA presence/absence # Remove zero-variance AMR features amr_pa_nz &lt;- amr_presence[, colSums(amr_presence) &gt; 0 &amp; colSums(amr_presence) &lt; nrow(amr_presence), drop = FALSE] # Determine the common genomes/IDs between AMR matrix and metadata common_ids &lt;- base::intersect(rownames(amr_pa_nz), genome_metadata$ID) # Report what will be kept/dropped message(&quot;# common: &quot;, length(common_ids)) # common: 50 message(&quot;# in AMR only: &quot;, length(setdiff(rownames(amr_pa_nz), genome_metadata$ID))) # in AMR only: 90 message(&quot;# in metadata only: &quot;, length(setdiff(genome_metadata$ID, rownames(amr_pa_nz)))) # in metadata only: 77 # Subset AMR to the intersection (and keep the identical order) amr_pa_nz &lt;- amr_pa_nz[common_ids, , drop = FALSE] # Build aligned metadata (unique IDs, same order as amr_pa_nz) meta &lt;- genome_metadata %&gt;% dplyr::filter(ID %in% common_ids) %&gt;% dplyr::distinct(ID, .keep_all = TRUE) %&gt;% tibble::column_to_rownames(&quot;ID&quot;) %&gt;% .[common_ids, , drop = FALSE] stopifnot(identical(rownames(meta), rownames(amr_pa_nz))) # Prepare variables for PERMANOVA required_vars &lt;- c(&quot;genome_size&quot;, &quot;completeness&quot;, &quot;host_type&quot;) # Coerce types as needed meta &lt;- meta %&gt;% dplyr::mutate( genome_size = as.numeric(genome_size), completeness = as.numeric(completeness), host_type = as.factor(host_type) ) # Align on complete cases for the required variables ok &lt;- stats::complete.cases(meta[, required_vars, drop = FALSE]) amr_pa_nz &lt;- amr_pa_nz[ok, , drop = FALSE] meta &lt;- meta[ok, , drop = FALSE] stopifnot(identical(rownames(meta), rownames(amr_pa_nz))) # Distance, dispersion, PERMANOVA amr_dist_pa &lt;- vegan::vegdist(amr_pa_nz, method = &quot;jaccard&quot;, binary = TRUE) disp_pa &lt;- vegan::betadisper(amr_dist_pa, meta$host_type) Warning in vegan::betadisper(amr_dist_pa, meta$host_type): some squared distances are negative and changed to zero anova(disp_pa) Analysis of Variance Table Response: Distances Df Sum Sq Mean Sq F value Pr(&gt;F) Groups 1 0.000057 0.0000566 0.0091 0.9242 Residuals 47 0.290868 0.0061887 vegan::adonis2( amr_dist_pa ~ genome_size + completeness + host_type, data = meta, permutations = 999, by = &quot;margin&quot; ) Permutation test for adonis under reduced model Marginal effects of terms Permutation: free Number of permutations: 999 vegan::adonis2(formula = amr_dist_pa ~ genome_size + completeness + host_type, data = meta, permutations = 999, by = &quot;margin&quot;) Df SumOfSqs R2 F Pr(&gt;F) genome_size 1 0.01571 0.01467 0.7202 0.533 completeness 1 0.01155 0.01079 0.5296 0.644 host_type 1 0.06544 0.06113 3.0001 0.035 * Residual 45 0.98148 0.91690 Total 48 1.07044 1.00000 --- Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 8.3 PCoA presence/absence pcoa_pa &lt;- cmdscale(amr_dist_pa, eig = TRUE, k = 2) variance_explained &lt;- pcoa_pa$eig / sum(pcoa_pa$eig) pcoa_df &lt;- data.frame( ID = rownames(amr_pa_nz), PC1 = pcoa_pa$points[,1], PC2 = pcoa_pa$points[,2], host_type = meta$host_type ) %&gt;% left_join(metadata_with_cluster, by = &quot;ID&quot;) pcoa_amr_pa &lt;- ggplot(pcoa_df, aes(PC1, PC2, color = host_type.x)) + geom_point(size = 2) + scale_color_manual(values = host_type_colors, name = &quot;host_type&quot;) + theme_minimal() + labs( title = &quot;PCoA of AMR annotations across MAGs&quot;, x = paste0(&quot;PCoA1 (&quot;, round(variance_explained[1] * 100, 1), &quot;%)&quot;), y = paste0(&quot;PCoA2 (&quot;, round(variance_explained[2] * 100, 1), &quot;%)&quot;) ) pcoa_amr_pa ggplot(pcoa_df, aes(PC1, PC2, color = host_order)) + geom_point(size = 2) + scale_color_manual(values = host_order_colors, name = &quot;Host Order&quot;)+ theme_minimal() + labs( title = &quot;PCoA of AMR annotations across MAGs (colored by host order)&quot;, x = paste0(&quot;PCoA1 (&quot;, round(variance_explained[1] * 100, 1), &quot;%)&quot;), y = paste0(&quot;PCoA2 (&quot;, round(variance_explained[2] * 100, 1), &quot;%)&quot;) ) ggplot(pcoa_df, aes(PC1, PC2, color = completeness)) + geom_point(size = 2) + theme_minimal() + labs( title = &quot;PCoA of AMR annotations across MAGs (colored by completeness)&quot;, x = paste0(&quot;PCoA1 (&quot;, round(variance_explained[1] * 100, 1), &quot;%)&quot;), y = paste0(&quot;PCoA2 (&quot;, round(variance_explained[2] * 100, 1), &quot;%)&quot;) ) ggplot(pcoa_df, aes(PC1, PC2, color = genome_size)) + geom_point(size = 2) + theme_minimal() + labs( title = &quot;PCoA of AMR annotations across MAGs (colored by genome_size)&quot;, x = paste0(&quot;PCoA1 (&quot;, round(variance_explained[1] * 100, 1), &quot;%)&quot;), y = paste0(&quot;PCoA2 (&quot;, round(variance_explained[2] * 100, 1), &quot;%)&quot;) ) ggplot(pcoa_df, aes(PC1, PC2, color = country)) + geom_point(size = 2) + scale_color_manual(values = country_palette, na.value = &quot;grey70&quot;)+ theme_minimal() + labs( title = &quot;PCoA of AMR annotations across MAGs (colored by country)&quot;, x = paste0(&quot;PCoA1 (&quot;, round(variance_explained[1] * 100, 1), &quot;%)&quot;), y = paste0(&quot;PCoA2 (&quot;, round(variance_explained[2] * 100, 1), &quot;%)&quot;) ) ggplot(pcoa_df, aes(PC1, PC2, color = continent)) + geom_point(size = 2) + theme_minimal() + labs( title = &quot;PCoA of AMR annotations across MAGs (colored by continent)&quot;, x = paste0(&quot;PCoA1 (&quot;, round(variance_explained[1] * 100, 1), &quot;%)&quot;), y = paste0(&quot;PCoA2 (&quot;, round(variance_explained[2] * 100, 1), &quot;%)&quot;) ) ggplot(pcoa_df, aes(PC1, PC2, color = cluster)) + geom_point(size = 2) + theme_minimal() + labs( title = &quot;PCoA of AMR annotations across MAGs (colored by functional cluster)&quot;, x = paste0(&quot;PCoA1 (&quot;, round(variance_explained[1] * 100, 1), &quot;%)&quot;), y = paste0(&quot;PCoA2 (&quot;, round(variance_explained[2] * 100, 1), &quot;%)&quot;) ) 8.4 Testing proportions (Fisher) amr_counts &lt;- genome_annotations %&gt;% filter(resistance_type == &quot;AMR&quot;) %&gt;% dplyr::count(genome, resistance_target) %&gt;% pivot_wider(names_from = resistance_target, values_from = n, values_fill = 0) %&gt;% filter(rowSums(dplyr::select(., -genome)) &gt; 0) # Removes MAGs with no AMR genes found amr_binary &lt;- amr_counts %&gt;% left_join(genome_metadata %&gt;% dplyr::select(ID, host_type), by = c(&quot;genome&quot; = &quot;ID&quot;)) %&gt;% # Convert all numeric columns to 0 or 1 mutate(across(where(is.numeric), ~ ifelse(.x &gt; 0, 1, 0))) #Function to run Fischer test for each gene run_fisher &lt;- function(gene_name, df) { tab &lt;- table(df$host_type, df[[gene_name]]) # Only run if the table is actually 2x2 if(ncol(tab) == 2) { test &lt;- fisher.test(tab) return(tidy(test) %&gt;% mutate(AMR_Target = gene_name)) } else { return(NULL) } } # Apply the function to all AMR columns amr_names &lt;- colnames(amr_counts)[-1] # everything except mag_id fisher_results &lt;- map_df(amr_names, ~ run_fisher(.x, amr_binary)) # Adjust for multiple testing (FDR) fisher_results &lt;- fisher_results %&gt;% mutate(p.adj = p.adjust(p.value, method = &quot;fdr&quot;)) %&gt;% filter(p.adj &lt; 0.05) %&gt;% arrange(p.adj) print(fisher_results) # A tibble: 0 × 8 # ℹ 8 variables: estimate &lt;dbl&gt;, p.value &lt;dbl&gt;, conf.low &lt;dbl&gt;, conf.high &lt;dbl&gt;, method &lt;chr&gt;, # alternative &lt;chr&gt;, AMR_Target &lt;chr&gt;, p.adj &lt;dbl&gt; "],["virulence-factors-analysis.html", "Chapter 9 Virulence factors analysis 9.1 Building a virulence factor abundance table 9.2 Virulence presence/absence heatmap 9.3 Virulence presence/absence PERMANOVA 9.4 Virulence presence/absence PCoA", " Chapter 9 Virulence factors analysis 9.0.1 Nº of MAGs with VFs # AMR presence/absence vf_presence &lt;- genome_annotations %&gt;% filter(!is.na(vf)) %&gt;% dplyr::select(genome, vf) %&gt;% distinct() #Add the host_type info vf_with_host_type &lt;- vf_presence %&gt;% left_join( genome_metadata %&gt;% dplyr::select(ID, host_type), by = c(&quot;genome&quot; = &quot;ID&quot;) ) # Count how many MAGs in each vf vf_mag_counts &lt;- vf_with_host_type %&gt;% group_by(host_type, vf) %&gt;% summarise( n_mags = n(), .groups = &quot;drop&quot; ) #Count total MAGs per host_type (except the outlier) total_mags_per_host_type &lt;- genome_metadata %&gt;% group_by(host_type) %&gt;% summarise( total_mags = n_distinct(ID), .groups = &quot;drop&quot; ) #Calculate proportions of MAGs from each host_type in each vf vf_mag_proportions &lt;- vf_mag_counts %&gt;% left_join(total_mags_per_host_type, by = &quot;host_type&quot;) %&gt;% mutate( proportion = n_mags / total_mags, absent = total_mags - n_mags ) 9.0.1.1 Statistical testing of MAG proportions (Fisher) fisher_results &lt;- vf_mag_proportions %&gt;% dplyr::select(vf, host_type, n_mags, absent) %&gt;% pivot_wider( names_from = host_type, values_from = c(n_mags, absent), values_fill = 0 ) %&gt;% rowwise() %&gt;% mutate( p_value = fisher.test( matrix( c(n_mags_animal, absent_animal, n_mags_human, absent_human), nrow = 2, byrow = TRUE ) )$p.value ) %&gt;% ungroup() %&gt;% mutate(p_adj = p.adjust(p_value, method = &quot;BH&quot;)) fisher_results &lt;- fisher_results %&gt;% mutate( prop_animal = n_mags_animal / (n_mags_animal + absent_animal), prop_human = n_mags_human / (n_mags_human + absent_human), diff_prop = prop_human - prop_animal ) fisher_results%&gt;% filter(p_adj &lt; 0.05) # A tibble: 200 × 12 vf n_mags_animal n_mags_human n_mags_NA absent_animal absent_human absent_NA p_value p_adj prop_animal &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 VF0003 41 8 91 43 34 -90 0.00173 0.00397 0.488 2 VF0014 40 8 89 44 34 -88 0.00189 0.00397 0.476 3 VF0028 38 6 57 46 36 -56 0.000651 0.00397 0.452 4 VF0033 41 8 91 43 34 -90 0.00173 0.00397 0.488 5 VF0043 14 1 38 70 41 -37 0.0197 0.0354 0.167 6 VF0044 41 8 91 43 34 -90 0.00173 0.00397 0.488 7 VF0052 41 8 91 43 34 -90 0.00173 0.00397 0.488 8 VF0056 40 8 91 44 34 -90 0.00189 0.00397 0.476 9 VF0062 40 8 91 44 34 -90 0.00189 0.00397 0.476 10 VF0072 41 8 91 43 34 -90 0.00173 0.00397 0.488 # ℹ 190 more rows # ℹ 2 more variables: prop_human &lt;dbl&gt;, diff_prop &lt;dbl&gt; 9.1 Building a virulence factor abundance table vf_data &lt;- genome_annotations %&gt;% dplyr::select(genome, vf, vf_type) vf_abundance &lt;- genome_annotations %&gt;% dplyr::select(genome, vf) %&gt;% group_by(genome, vf) %&gt;% summarise(count = n(), .groups=&quot;drop&quot;) %&gt;% tidyr::pivot_wider( names_from = vf, values_from = count, values_fill = 0 ) dim(vf_abundance) [1] 140 361 vf_cluster &lt;- vf_abundance %&gt;% dplyr::full_join(genome_metadata, by= join_by(genome == ID)) # make into a matrix vf_matrix &lt;- vf_abundance %&gt;% column_to_rownames(&quot;genome&quot;) %&gt;% as.matrix() # Unscaled abundance heatmap pheatmap(vf_matrix, color = viridis(100, option = &quot;viridis&quot;), cluster_rows = FALSE, cluster_cols = TRUE, fontsize = 9, border_color = NA ) # For scaled heatmap -&gt; remove zero variance columns col_vars &lt;- apply(vf_matrix, 2, var, na.rm = TRUE) vf_matrix_filtered &lt;- vf_matrix[, col_vars &gt; 0 &amp; !is.na(col_vars)] # Scale the filtered matrix vf_scaled &lt;- scale(vf_matrix_filtered, center = TRUE, scale = TRUE) # Check for any remaining Inf/NaN values if(any(!is.finite(vf_scaled))) { vf_scaled[!is.finite(vf_scaled)] &lt;- 0 # Replace Inf/NaN with 0 } # Scaled heatmap pheatmap(vf_scaled, color = viridis(100, option = &quot;viridis&quot;), cluster_rows = FALSE, cluster_cols = TRUE, fontsize = 5, border_color = NA ) 9.2 Virulence presence/absence heatmap vf_presence &lt;- vf_abundance %&gt;% column_to_rownames(&quot;genome&quot;) %&gt;% mutate(across(everything(), ~ ifelse(. &gt; 0, 1, 0)))%&gt;% as.matrix() pheatmap( vf_presence, cluster_rows = FALSE, cluster_cols = TRUE, color = c(&quot;white&quot;, &quot;darkblue&quot;), legend_breaks = c(0,1), legend_labels = c(&quot;Absent&quot;, &quot;Present&quot;), border_color = NA ) 9.3 Virulence presence/absence PERMANOVA # remove zero-variance KOs vf_pa_nz &lt;- vf_presence[, colSums(vf_presence) &gt; 0 &amp; colSums(vf_presence) &lt; nrow(vf_presence)] # Determine the common genomes common_ids &lt;- base::intersect(rownames(vf_pa_nz), genome_metadata$ID) # Report what will be kept/dropped message(&quot;# common: &quot;, length(common_ids)) # common: 50 message(&quot;# in KEGG only: &quot;, length(setdiff(rownames(amr_pa_nz), genome_metadata$ID))) # in KEGG only: 0 message(&quot;# in metadata only: &quot;, length(setdiff(genome_metadata$ID, rownames(vf_pa_nz)))) # in metadata only: 77 # Subset to the intersection (and keep order identical) vf_pa_nz &lt;- vf_pa_nz[common_ids, , drop = FALSE] meta &lt;- genome_metadata %&gt;% dplyr::filter(ID %in% common_ids) %&gt;% dplyr::distinct(ID, .keep_all = TRUE) %&gt;% tibble::column_to_rownames(&quot;ID&quot;) %&gt;% .[common_ids, , drop = FALSE] stopifnot(identical(rownames(meta), rownames(vf_pa_nz))) # VERY IMPORTANT: enforce same order meta &lt;- meta[rownames(vf_pa_nz), ] stopifnot(identical(rownames(meta), rownames(vf_pa_nz))) # Prepare variables for PERMANOVA required_vars &lt;- c(&quot;genome_size&quot;, &quot;completeness&quot;, &quot;host_type&quot;) # Coerce types as needed meta &lt;- meta %&gt;% dplyr::mutate( genome_size = as.numeric(genome_size), completeness = as.numeric(completeness), host_type = as.factor(host_type) ) # Align on complete cases (adonis2 drops NAs otherwise) ok &lt;- stats::complete.cases(meta[, required_vars, drop = FALSE]) vf_pa_nz &lt;- vf_pa_nz[ok, , drop = FALSE] meta &lt;- meta[ok, , drop = FALSE] stopifnot(identical(rownames(meta), rownames(vf_pa_nz))) # Distance, dispersion, PERMANOVA vf_dist_pa &lt;- vegan::vegdist(vf_pa_nz, method = &quot;jaccard&quot;, binary = TRUE) disp_pa &lt;- vegan::betadisper(vf_dist_pa, meta$host_type) anova(disp_pa) Analysis of Variance Table Response: Distances Df Sum Sq Mean Sq F value Pr(&gt;F) Groups 1 0.006957 0.0069572 1.8452 0.1808 Residuals 47 0.177212 0.0037705 vegan::adonis2( vf_dist_pa ~ genome_size + completeness + host_type, data = meta, permutations = 999, by = &quot;margin&quot; ) Permutation test for adonis under reduced model Marginal effects of terms Permutation: free Number of permutations: 999 vegan::adonis2(formula = vf_dist_pa ~ genome_size + completeness + host_type, data = meta, permutations = 999, by = &quot;margin&quot;) Df SumOfSqs R2 F Pr(&gt;F) genome_size 1 0.06177 0.03364 1.7091 0.072 . completeness 1 0.08513 0.04637 2.3557 0.015 * host_type 1 0.06348 0.03458 1.7566 0.047 * Residual 45 1.62621 0.88580 Total 48 1.83586 1.00000 --- Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 9.4 Virulence presence/absence PCoA pcoa_pa &lt;- cmdscale(vf_dist_pa, eig = TRUE, k = 2) variance_explained &lt;- pcoa_pa$eig / sum(pcoa_pa$eig) pcoa_df &lt;- data.frame( ID = rownames(vf_pa_nz), PC1 = pcoa_pa$points[,1], PC2 = pcoa_pa$points[,2], host_type = meta$host_type ) %&gt;% left_join(metadata_with_cluster, by = &quot;ID&quot;) pcoa_vf_pa &lt;- ggplot(pcoa_df, aes(PC1, PC2, color = host_type.x)) + geom_point(size = 2) + scale_color_manual(values = host_type_colors, name = &quot;host_type&quot;) + theme_minimal() + labs( title = &quot;PCoA of VF annotations across MAGs&quot;, x = paste0(&quot;PCoA1 (&quot;, round(variance_explained[1] * 100, 1), &quot;%)&quot;), y = paste0(&quot;PCoA2 (&quot;, round(variance_explained[2] * 100, 1), &quot;%)&quot;) ) pcoa_vf_pa ggplot(pcoa_df, aes(PC1, PC2, color = host_order)) + geom_point(size = 2) + scale_color_manual(values = host_order_colors, na.value = &quot;grey70&quot;)+ theme_minimal() + labs( title = &quot;PCoA of VF annotations across MAGs (colored by host order)&quot;, x = paste0(&quot;PCoA1 (&quot;, round(variance_explained[1] * 100, 1), &quot;%)&quot;), y = paste0(&quot;PCoA2 (&quot;, round(variance_explained[2] * 100, 1), &quot;%)&quot;) ) ggplot(pcoa_df, aes(PC1, PC2, color = completeness)) + geom_point(size = 2) + theme_minimal() + labs( title = &quot;PCoA of VF annotations across MAGs (colored by completeness)&quot;, x = paste0(&quot;PCoA1 (&quot;, round(variance_explained[1] * 100, 1), &quot;%)&quot;), y = paste0(&quot;PCoA2 (&quot;, round(variance_explained[2] * 100, 1), &quot;%)&quot;) ) ggplot(pcoa_df, aes(PC1, PC2, color = genome_size)) + geom_point(size = 2) + theme_minimal() + labs( title = &quot;PCoA of VF annotations across MAGs (colored by genome_size)&quot;, x = paste0(&quot;PCoA1 (&quot;, round(variance_explained[1] * 100, 1), &quot;%)&quot;), y = paste0(&quot;PCoA2 (&quot;, round(variance_explained[2] * 100, 1), &quot;%)&quot;) ) ggplot(pcoa_df, aes(PC1, PC2, color = country)) + geom_point(size = 2) + scale_color_manual(values = country_palette, na.value = &quot;grey70&quot;)+ theme_minimal() + labs( title = &quot;PCoA of VF annotations across MAGs (colored by country)&quot;, x = paste0(&quot;PCoA1 (&quot;, round(variance_explained[1] * 100, 1), &quot;%)&quot;), y = paste0(&quot;PCoA2 (&quot;, round(variance_explained[2] * 100, 1), &quot;%)&quot;) ) ggplot(pcoa_df, aes(PC1, PC2, color = continent)) + geom_point(size = 2) + theme_minimal() + labs( title = &quot;PCoA of VF annotations across MAGs (colored by continent)&quot;, x = paste0(&quot;PCoA1 (&quot;, round(variance_explained[1] * 100, 1), &quot;%)&quot;), y = paste0(&quot;PCoA2 (&quot;, round(variance_explained[2] * 100, 1), &quot;%)&quot;) ) pcoa_vf_pa_cluster &lt;- ggplot(pcoa_df, aes(PC1, PC2, color = cluster)) + geom_point(size = 2) + theme_minimal() + labs( title = &quot;PCoA of VF annotations across MAGs (colored by functional cluster)&quot;, x = paste0(&quot;PCoA1 (&quot;, round(variance_explained[1] * 100, 1), &quot;%)&quot;), y = paste0(&quot;PCoA2 (&quot;, round(variance_explained[2] * 100, 1), &quot;%)&quot;) ) pcoa_vf_pa_cluster "],["cazy.html", "Chapter 10 CAZY 10.1 Defense 10.2 PCoAs KEGG, AMR and VF", " Chapter 10 CAZY cazy_genes &lt;- genome_annotations %&gt;% filter(!is.na(cazy)) %&gt;% nrow() cazy_genes [1] 15569 cazy_abundance &lt;- genome_annotations %&gt;% filter(!is.na(cazy)) %&gt;% group_by(genome, cazy) %&gt;% summarise(count = n(), .groups=&quot;drop&quot;) %&gt;% tidyr::pivot_wider( names_from = cazy, values_from = count, values_fill = 0 ) cazy_matrix &lt;- cazy_abundance %&gt;% column_to_rownames(&quot;genome&quot;) %&gt;% as.matrix() # Abundance heatmap min_val &lt;- min(cazy_matrix, na.rm = TRUE) max_val &lt;- max(cazy_matrix, na.rm = TRUE) colors &lt;- viridis(100, option = &quot;viridis&quot;) breaks &lt;- seq(min_val, max_val, length.out = 101) pheatmap( cazy_matrix, color = colors, cluster_rows = FALSE, cluster_cols = TRUE, fontsize = 9, border_color = NA ) #Scaled abundance heatmap cazy_scaled &lt;- scale(cazy_matrix, center = TRUE, scale = TRUE) min_val &lt;- min(cazy_scaled, na.rm = TRUE) max_val &lt;- max(cazy_scaled, na.rm = TRUE) colors &lt;- viridis(100, option = &quot;viridis&quot;) breaks &lt;- seq(min_val, max_val, length.out = 101) 10.1 Defense genome_annotations %&gt;% dplyr::select(genome, defense, defense_type, antidefense, antidefense_type) %&gt;% filter(!is.na(defense)) # A tibble: 1,071 × 5 genome defense defense_type antidefense antidefense_type &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; &lt;lgl&gt; 1 EHM042508 AbiG__AbiGii AbiG NA NA 2 EHM042508 AbiG__AbiGi AbiG NA NA 3 EHM042508 AbiD__AbiD AbiD NA NA 4 EHM042508 Dodola__DolA Dodola NA NA 5 EHM042508 Dodola__DolB Dodola NA NA 6 GCF_030545485.1 Abi2__Abi_2 Abi2 NA NA 7 GCF_030545485.1 AbiH__AbiH AbiH NA NA 8 EHM013277 VP1851__VP1851 VP1851 NA NA 9 EHM013277 RM__Type_I_MTases_FAM_0 RM NA NA 10 EHM013277 RM__Type_I_S_01 RM NA NA # ℹ 1,061 more rows 10.2 PCoAs KEGG, AMR and VF library(patchwork) combined_plot &lt;- (pcoa_kegg_pa + ggtitle(&quot;PCoA: KEGG&quot;)) + (pcoa_amr_pa + ggtitle(&quot;PCoA: AMR&quot;)) + (pcoa_vf_pa + ggtitle(&quot;PCoA: VF&quot;)) + plot_layout(ncol = 2, guides = &quot;collect&quot;) &amp; theme(legend.position = &quot;bottom&quot;) combined_plot "],["functions-and-helpers.html", "Chapter 11 Functions and helpers 11.1 DATA PREPARATION 11.2 DREP ANALYSIS 11.3 FUNCTIONAL ANALYSIS: KEGG, AMR, VF, CAZY, DEFENSE, GIFTS 11.4 Define species list 11.5 Testing functions with one species", " Chapter 11 Functions and helpers source_colors &lt;- c(EHI = &quot;#8BC63F&quot;, GTDB = &quot;#2D522D&quot;, NCBI= &quot;#20558A&quot;) host_type_colors &lt;- c(human = &quot;#A90D00&quot; , animal = &quot;darkgreen&quot;) host_order_colors &lt;- c( &quot;Accipitriformes&quot; = &quot;#143AC2&quot;, # Aves &quot;Carnivora&quot; = &quot;#633C2C&quot;, # Mammalia &quot;Chiroptera&quot; = &quot;#1B2021&quot;, # Mammalia &quot;Primates&quot; = &quot;#CC0000&quot;, # Mammalia &quot;Rodentia&quot; = &quot;#FDA991&quot;, # Mammalia &quot;Diptera&quot; = &quot;#FFAE2B&quot;, # Insecta &quot;Isoptera&quot; = &quot;#E27500&quot;, # Insecta &quot;Lepidoptera&quot; = &quot;#C8591D&quot;, # Insecta &quot;Squamata&quot; = &quot;#1D921B&quot; # Reptilia ) country_palette &lt;- c( # Southern Europe &quot;Spain&quot; = &quot;#1B9E77&quot;, &quot;Italy&quot; = &quot;#33A02C&quot;, &quot;Greece&quot; = &quot;#66C2A5&quot;, &quot;Portugal&quot; = &quot;#2CA25F&quot;, &quot;Malta&quot; = &quot;#99D8C9&quot;, # Northern/Central Europe &quot;Germany&quot; = &quot;#1F78B4&quot;, &quot;United Kingdom&quot; = &quot;#4A90E2&quot;, &quot;Ireland&quot; = &quot;#6BAED6&quot;, # East Asia &quot;Japan&quot; = &quot;#E31A1C&quot;, &quot;South Korea&quot; = &quot;#FB6A4A&quot;, &quot;China&quot; = &quot;#CB181D&quot;, # North America &quot;USA&quot; = &quot;#756BB1&quot;, &quot;Canada&quot; = &quot;#9E9AC8&quot;, # Distinct &quot;Australia&quot; = &quot;#FFD92F&quot;, &quot;Greenland&quot; = &quot;#A6CEE3&quot;, &quot;none&quot; = &quot;grey70&quot; ) 11.1 DATA PREPARATION 11.1.1 Load all the data ## Load all the data load_species_files &lt;- function(species, base_dir = &quot;data/mags_metadata&quot;) { paths &lt;- list( ehi_metadata = file.path(base_dir, paste0(species, &quot;_metadata.tsv&quot;)), #EH metadata gtdb_final = file.path(base_dir, paste0(species, &quot;_gtdb_final_metadata.tsv&quot;)), #GTDB metadata contig_map = file.path(base_dir, paste0(species, &quot;_contig_to_mag.tsv&quot;)), #contig map to genome gene_annotations = file.path(base_dir, paste0(species, &quot;_gene_annotations.tsv.xz&quot;)), #functional annotations ncbi_metadata_rds = file.path(base_dir, paste0(species, &quot;_ncbi_metadata.rds&quot;)), #NCBI metadata ndb = file.path(base_dir, paste0(species, &quot;_Ndb.csv&quot;)) # FASTANI ) load_if_exists &lt;- function(path, loader) { if (file.exists(path)) loader(path) else NULL } result &lt;- list( ehi_metadata = load_if_exists(paths$ehi_metadata, function(p) readr::read_tsv(p, show_col_types = FALSE)), gtdb_final = load_if_exists(paths$gtdb_final, function(p) readr::read_tsv(p, show_col_types = FALSE)), contig_map = load_if_exists(paths$contig_map, function(p) readr::read_tsv(p, show_col_types = FALSE)), gene_annotations = load_if_exists(paths$gene_annotations, function(p) readr::read_tsv(p, show_col_types = FALSE)), ndb = load_if_exists(paths$ndb, function(p) readr::read_csv(p, show_col_types = FALSE)), ncbi_metadata = load_if_exists(paths$ncbi_metadata_rds, readRDS)) return(result) } # Find the most plausible genome size column and rename to genome_size detect_and_rename_genome_size &lt;- function(df) { if (is.null(df)) return(df) # If exact already present, nothing to do if (&quot;genome_size&quot; %in% names(df)) return(df) # Common explicit variants (ordered by preference) candidates &lt;- c( # EHI &quot;size&quot;, &quot;Size&quot;, &quot;SIZE&quot;, # NCBI &quot;genome_size...4&quot;, &quot;genome_size...43&quot;, # other common labels &quot;size_bp&quot;, &quot;Size_bp&quot;, &quot;genome_size_bp&quot;, &quot;total_length&quot;, &quot;assembly_length&quot;, &quot;estimated_size&quot; ) hit &lt;- intersect(candidates, names(df)) if (length(hit) &gt;= 1) { # If multiple hits appear, prefer the first listed above df &lt;- dplyr::rename(df, genome_size = !!hit[1]) return(df) } # Fallback: first column containing &quot;genome_size&quot; or &quot;size&quot; or &quot;length&quot; fuzzy &lt;- grep(&quot;(genome_)?size|length&quot;, names(df), ignore.case = TRUE, value = TRUE) if (length(fuzzy) &gt;= 1) { df &lt;- dplyr::rename(df, genome_size = !!fuzzy[1]) return(df) } df } # Normalize &#39;n50&#39; (lowercase in some NCBI exports) to &#39;N50&#39; detect_and_rename_n50 &lt;- function(df) { if (is.null(df)) return(df) if (!(&quot;N50&quot; %in% names(df)) &amp;&amp; (&quot;n50&quot; %in% names(df))) { df &lt;- dplyr::rename(df, N50 = n50) } df } # Enforce consistent types across sources before bind_rows() harmonize_schema &lt;- function(df) { if (is.null(df)) return(NULL) # Column name standardization rename_map &lt;- c( &quot;isolation_source.x&quot; = &quot;isolation_source&quot;, &quot;isolation_source.y&quot; = &quot;isolation_source&quot;, &quot;isolation_source_x&quot; = &quot;isolation_source&quot;, &quot;isolation_source_y&quot; = &quot;isolation_source&quot;, &quot;geo_loc_name&quot; = &quot;country&quot;, &quot;geographic location (latitude)&quot; = &quot;latitude&quot;, &quot;geographic location (longitude)&quot; = &quot;longitude&quot; ) # Rename if present for (old in names(rename_map)) { if (old %in% names(df)) { names(df)[names(df) == old] &lt;- rename_map[[old]] } } # Define expected schema char_cols &lt;- c( &quot;ID&quot;,&quot;source&quot;,&quot;species&quot;,&quot;gtdb_taxonomy&quot;,&quot;gtdb_representative&quot;, &quot;isolation_source&quot;,&quot;host&quot;,&quot;host_status&quot;,&quot;disease&quot;,&quot;diagnosis&quot;, &quot;host_species&quot;,&quot;host_order&quot;,&quot;host_class&quot;,&quot;host_summary&quot;, &quot;country&quot;,&quot;locality&quot;,&quot;collection_date&quot;,&quot;ncbi_biosample&quot;, &quot;mag_name&quot;,&quot;eha_number&quot;,&quot;common_name&quot;,&quot;sample_name&quot;,&quot;external_id&quot;,&quot;submitter_id&quot;, &quot;env_broad&quot;,&quot;env_medium&quot;,&quot;env_local&quot;,&quot;env_local_context&quot; ) num_cols &lt;- c( &quot;completeness&quot;,&quot;contamination&quot;,&quot;genome_size&quot;,&quot;GC&quot;,&quot;N50&quot;,&quot;contigs&quot;, &quot;latitude&quot;,&quot;longitude&quot; ) logi_cols &lt;- c(&quot;mimag_high_quality&quot;,&quot;mimag_medium_quality&quot;) # Add missing columns for (cc in char_cols) if (!cc %in% names(df)) df[[cc]] &lt;- NA_character_ for (nc in num_cols) if (!nc %in% names(df)) df[[nc]] &lt;- NA_real_ for (lc in logi_cols) if (!lc %in% names(df)) df[[lc]] &lt;- NA # Type-coerce consistently df &lt;- df %&gt;% dplyr::mutate( dplyr::across( dplyr::all_of(char_cols), ~ as.character(.x) ), dplyr::across( dplyr::all_of(num_cols), ~ suppressWarnings(as.numeric(.x)) ), dplyr::across( dplyr::all_of(logi_cols), ~ as.logical(.x) ) ) # Return cleaned df df } # ---- Prepare gene annotations: add the genome with contig_map ---- prep_gene_annotations_with_genome &lt;- function(ann_raw, contig_map_raw) { if (is.null(ann_raw)) return(NULL) if (is.null(contig_map_raw)) { stop(&quot;contig_map is required to attach &#39;genome&#39; to gene_annotations.&quot;) } # --- Standardize contig_map to columns: contig, genome --- cm &lt;- contig_map_raw contig_col_candidates &lt;- intersect(names(cm), c(&quot;contig&quot;, &quot;contig_id&quot;, &quot;contig_name&quot;, &quot;scaffold&quot;)) if (length(contig_col_candidates) == 0) { stop(&quot;contig_map must have a contig column (one of: contig, contig_id, contig_name, scaffold).&quot;) } genome_col_candidates &lt;- intersect( names(cm), c(&quot;genome&quot;, &quot;genome_filename&quot;, &quot;mag&quot;, &quot;bin&quot;, &quot;genome_id&quot;, &quot;assembly&quot;) ) if (length(genome_col_candidates) == 0) { stop(&quot;contig_map must have a genome column (e.g., genome, genome_filename, mag, bin, genome_id, assembly).&quot;) } cm &lt;- cm %&gt;% dplyr::rename( contig = !!rlang::sym(contig_col_candidates[1]), genome = !!rlang::sym(genome_col_candidates[1]) ) %&gt;% dplyr::mutate( contig = as.character(contig), genome = as.character(genome) ) # --- Ensure annotations have a contig column --- an &lt;- ann_raw if (!(&quot;contig&quot; %in% names(an))) { # Try to derive from a gene-like column by stripping the last _segment gene_col_candidates &lt;- intersect(names(an), c(&quot;gene&quot;, &quot;gene_id&quot;, &quot;locus_tag&quot;, &quot;feature_id&quot;)) if (length(gene_col_candidates) == 0) { stop(&quot;gene_annotations must have `contig` or a gene-like column (gene/gene_id/locus_tag/feature_id).&quot;) } an &lt;- an %&gt;% dplyr::rename(.gene_tmp = !!rlang::sym(gene_col_candidates[1])) %&gt;% dplyr::mutate(contig = sub(&quot;_[^_]*$&quot;, &quot;&quot;, .data$.gene_tmp)) %&gt;% dplyr::select(-dplyr::any_of(&quot;.gene_tmp&quot;)) } # --- Join to add genome and filter out missing --- an &lt;- an %&gt;% dplyr::mutate(contig = as.character(contig)) %&gt;% dplyr::left_join(cm, by = &quot;contig&quot;) %&gt;% dplyr::filter(!is.na(.data$genome)) return(an) } clean_biosample_value &lt;- function(v) { if (is.na(v)) return(NA_character_) v &lt;- str_trim(v) m &lt;- str_match(v, &#39;^Attribute\\\\s+&quot;(.*)&quot;$&#39;) if (!is.na(m[1,2])) v &lt;- str_trim(m[1,2]) v_low &lt;- tolower(v) if (v_low %in% c(&quot;missing&quot;,&quot;not provided&quot;,&quot;not applicable&quot;,&quot;na&quot;,&quot;n/a&quot;,&quot;none&quot;,&quot;unknown&quot;, &quot;unspecified&quot;,&quot;not collected&quot;,&quot;not determined&quot;,&quot;not available&quot;)) return(NA_character_) if (v == &quot;&quot;) return(NA_character_) v } 11.1.2 Prepare EHI metadata # Prepare EHI metadata into a standardized schema prep_ehi_metadata &lt;- function(ehi_raw) { if (is.null(ehi_raw)) return(NULL) ehi_raw &lt;- detect_and_rename_genome_size(ehi_raw) ehi_raw &lt;- detect_and_rename_n50(ehi_raw) ehi_clean &lt;- ehi_raw %&gt;% mutate( GC = suppressWarnings(as.numeric(str_remove(GC, &quot;%&quot;))) ) %&gt;% dplyr::select( any_of(c( &quot;ID&quot;,&quot;species&quot;,&quot;completeness&quot;,&quot;contamination&quot;, &quot;genome_size&quot;,&quot;GC&quot;,&quot;N50&quot;,&quot;contigs&quot;, &quot;host_species&quot;,&quot;host_order&quot;,&quot;host_class&quot;, &quot;sample_type&quot;,&quot;isolation_source&quot;,&quot;country&quot;,&quot;locality&quot;, &quot;mag_name&quot;,&quot;eha_number&quot; )) ) %&gt;% mutate( isolation_source = coalesce(isolation_source, sample_type), source = &quot;EHI&quot; ) %&gt;% dplyr::select(-sample_type) harmonize_schema(ehi_clean) } 11.1.3 Prepare GTDB metadata prep_gtdb_final &lt;- function(gtdb_raw) { if (is.null(gtdb_raw)) return(NULL) # Standardize size &amp; N50 labels gtdb_raw &lt;- detect_and_rename_genome_size(gtdb_raw) gtdb_raw &lt;- detect_and_rename_n50(gtdb_raw) gtdb_clean &lt;- gtdb_raw %&gt;% # Pick only columns we may need (robust to presence/absence) dplyr::select(dplyr::any_of(c( &quot;ID&quot;,&quot;accession&quot;,&quot;gtdb_taxonomy&quot;,&quot;gtdb_representative&quot;, &quot;checkm2_completeness&quot;,&quot;checkm2_contamination&quot;, &quot;genome_size&quot;,&quot;gc_percentage&quot;,&quot;N50&quot;,&quot;n50_contigs&quot;, &quot;contigs&quot;,&quot;contig_count&quot;, &quot;ncbi_biosample&quot;,&quot;country&quot;,&quot;geo_loc_name&quot;, &quot;isolation_source&quot;,&quot;isolation_source.x&quot;,&quot;isolation_source_x&quot;, &quot;isolation_source.y&quot;,&quot;isolation_source_y&quot;, &quot;host&quot;,&quot;host_status&quot;,&quot;disease&quot;,&quot;diagnosis&quot;,&quot;host_summary&quot;, # latitude/longitude may appear with ENA-style names; keep both &quot;latitude&quot;,&quot;longitude&quot;,&quot;geographic location (latitude)&quot;,&quot;geographic location (longitude)&quot;, # environment / context variants &quot;env_broad&quot;,&quot;env_broad_scale&quot;,&quot;env_medium&quot;,&quot;env_local&quot;,&quot;env_local_scale&quot;, &quot;env_local_context&quot;,&quot;local environmental context&quot;, # names with spaces/case variants from ENA &quot;common_name&quot;,&quot;common name&quot;,&quot;sample_name&quot;,&quot;external_id&quot;,&quot;External Id&quot;,&quot;submitter_id&quot;,&quot;Submitter Id&quot;, &quot;collection_date&quot; ))) %&gt;% # Normalize N50/contigs if only alt names exist { if (!&quot;N50&quot; %in% names(.) &amp;&amp; &quot;n50_contigs&quot; %in% names(.)) dplyr::rename(., N50 = n50_contigs) else . } %&gt;% { if (!&quot;contigs&quot; %in% names(.) &amp;&amp; &quot;contig_count&quot; %in% names(.)) dplyr::rename(., contigs = contig_count) else . } %&gt;% # Conditional renames for ENA/GTDB variants (no-op if missing) { if (&quot;env_broad_scale&quot; %in% names(.)) dplyr::rename(., env_broad = `env_broad_scale`) else . } %&gt;% { if (&quot;env_local_scale&quot; %in% names(.)) dplyr::rename(., env_local = `env_local_scale`) else . } %&gt;% { if (&quot;local environmental context&quot; %in% names(.)) dplyr::rename(., env_local_context = `local environmental context`) else . } %&gt;% { if (&quot;common name&quot; %in% names(.)) dplyr::rename(., common_name = `common name`) else . } %&gt;% { if (&quot;External Id&quot; %in% names(.)) dplyr::rename(., external_id = `External Id`) else . } %&gt;% { if (&quot;Submitter Id&quot; %in% names(.)) dplyr::rename(., submitter_id = `Submitter Id`) else . } %&gt;% # Add core source + numeric fields dplyr::mutate( source = &quot;GTDB&quot;, completeness = .data$checkm2_completeness, contamination = .data$checkm2_contamination, GC = .data$gc_percentage ) # Coalesce isolation_source variants safely (handle dot/underscore suffixes) iso_candidates &lt;- c(&quot;isolation_source&quot;,&quot;isolation_source.x&quot;,&quot;isolation_source_x&quot;, &quot;isolation_source.y&quot;,&quot;isolation_source_y&quot;) present_iso &lt;- intersect(iso_candidates, names(gtdb_clean)) if (length(present_iso) &gt; 0) { # progressive coalesce across present variants iso &lt;- gtdb_clean[[present_iso[1]]] if (length(present_iso) &gt; 1) { for (nm in present_iso[-1]) iso &lt;- dplyr::coalesce(iso, gtdb_clean[[nm]]) } gtdb_clean[[&quot;isolation_source&quot;]] &lt;- iso } # Prefer GTDB &#39;country&#39;, else ENA &#39;geo_loc_name&#39; if (&quot;geo_loc_name&quot; %in% names(gtdb_clean)) { gtdb_clean[[&quot;country&quot;]] &lt;- dplyr::coalesce(gtdb_clean[[&quot;country&quot;]], gtdb_clean[[&quot;geo_loc_name&quot;]]) } # Drop helper/duplicate columns we normalized away gtdb_clean &lt;- gtdb_clean %&gt;% dplyr::select(-dplyr::any_of(c( &quot;checkm2_completeness&quot;,&quot;checkm2_contamination&quot;,&quot;gc_percentage&quot;, &quot;n50_contigs&quot;,&quot;contig_count&quot;,&quot;geo_loc_name&quot;, &quot;isolation_source.x&quot;,&quot;isolation_source_x&quot;,&quot;isolation_source.y&quot;,&quot;isolation_source_y&quot; ))) # Final schema/type harmonization (handles lat/long ENA names, adds missing cols) gtdb_clean &lt;- harmonize_schema(gtdb_clean) return(gtdb_clean) } 11.1.4 Prepare NCBI metadata # Prepare NCBI metadata into standardized schema prep_ncbi_metadata &lt;- function(ncbi_raw) { if (is.null(ncbi_raw)) return(NULL) ncbi_raw &lt;- detect_and_rename_genome_size(ncbi_raw) ncbi_raw &lt;- detect_and_rename_n50(ncbi_raw) ncbi_clean &lt;- ncbi_raw %&gt;% dplyr::select( dplyr::any_of(c( &quot;accession&quot;,&quot;completeness&quot;,&quot;contamination&quot;, &quot;genome_size&quot;,&quot;gc_percent&quot;,&quot;isolation_source&quot;,&quot;host&quot;, &quot;collection_date&quot;,&quot;geo_loc_name&quot;,&quot;N50&quot;,&quot;contigs&quot;,&quot;host_disease&quot;,&quot;host_age&quot; )) ) %&gt;% dplyr::rename( ID = accession, country = geo_loc_name, GC = gc_percent ) %&gt;% dplyr::mutate( source = &quot;NCBI&quot; ) harmonize_schema(ncbi_clean) } 11.1.5 Combine metadata sources into genome_metadata # Combine EHI + GTDB(final) + NCBI into one unified table combine_metadata_sources &lt;- function(ehi_clean, gtdb_final_clean, ncbi_clean) { tables &lt;- list(ehi_clean, gtdb_final_clean, ncbi_clean) tables &lt;- tables[!vapply(tables, is.null, logical(1))] if (length(tables) == 0) { # No sources available: return an empty tibble genome_metadata &lt;- harmonize_schema(tibble::tibble()) } else { # Ensure schema per table, then bind tables &lt;- lapply(tables, harmonize_schema) genome_metadata &lt;- dplyr::bind_rows(tables) # One more pass to guarantee presence of all expected columns genome_metadata &lt;- harmonize_schema(genome_metadata) } # Safe numeric coercions in columns that exist genome_metadata &lt;- genome_metadata %&gt;% dplyr::mutate( completeness = if (&quot;completeness&quot; %in% names(.)) suppressWarnings(as.numeric(completeness)) else NA_real_, contamination = if (&quot;contamination&quot; %in% names(.)) suppressWarnings(as.numeric(contamination)) else NA_real_, GC = if (&quot;GC&quot; %in% names(.)) suppressWarnings(as.numeric(GC)) else NA_real_, genome_size = if (&quot;genome_size&quot; %in% names(.)) suppressWarnings(as.numeric(genome_size)) else NA_real_, N50 = if (&quot;N50&quot; %in% names(.)) suppressWarnings(as.numeric(N50)) else NA_real_, contigs = if (&quot;contigs&quot; %in% names(.)) suppressWarnings(as.numeric(contigs)) else NA_real_ ) # Reorder columns if present front_cols &lt;- c( &quot;ID&quot;,&quot;source&quot;,&quot;species&quot;,&quot;gtdb_taxonomy&quot;, &quot;host_species&quot;,&quot;host_order&quot;,&quot;host_class&quot;, &quot;isolation_source&quot;,&quot;host&quot;,&quot;host_summary&quot;, &quot;country&quot;,&quot;locality&quot;, &quot;completeness&quot;,&quot;contamination&quot;,&quot;genome_size&quot;,&quot;GC&quot;,&quot;N50&quot;,&quot;contigs&quot;, &quot;collection_date&quot;,&quot;ncbi_biosample&quot;,&quot;mag_name&quot;,&quot;eha_number&quot;, &quot;gtdb_representative&quot;,&quot;mimag_high_quality&quot;,&quot;mimag_medium_quality&quot;, &quot;common_name&quot;,&quot;sample_name&quot;,&quot;external_id&quot;,&quot;submitter_id&quot;, &quot;env_broad&quot;,&quot;env_medium&quot;,&quot;env_local&quot;,&quot;env_local_context&quot; ) front_cols &lt;- intersect(front_cols, colnames(genome_metadata)) genome_metadata &lt;- genome_metadata %&gt;% dplyr::relocate(dplyr::all_of(front_cols), .before = 1) if (nrow(genome_metadata) &gt; 0 &amp;&amp; all(is.na(genome_metadata$genome_size))) { warning(&quot;All genome_size values are NA after merging. Check size mapping.&quot;) } genome_metadata } 11.1.6 Infer host metadata normalize_species &lt;- function(s) { # Vectorized normalization of binomials s &lt;- as.character(s) s[is.na(s) | s == &quot;&quot;] &lt;- NA_character_ s_low &lt;- stringr::str_to_lower(s) # Canonicalize known synonyms/typos out &lt;- dplyr::case_when( # Dog stringr::str_detect(s_low, &quot;^canis\\\\s+familiaris$&quot;) ~ &quot;Canis lupus familiaris&quot;, stringr::str_detect(s_low, &quot;^canis\\\\s+lupus\\\\s+familiaris$&quot;) ~ &quot;Canis lupus familiaris&quot;, stringr::str_detect(s_low, &quot;^mammuthus\\\\s+primi&quot;) ~ &quot;Mammuthus primigenius&quot;, TRUE ~ s ) # Title-case genus, lower species where we have at least two tokens reformat &lt;- function(x) { if (is.na(x) || x == &quot;&quot;) return(NA_character_) parts &lt;- strsplit(x, &quot;\\\\s+&quot;)[[1]] if (length(parts) &lt; 2) return(x) paste0(stringr::str_to_title(parts[1]), &quot; &quot;, stringr::str_to_lower(parts[2])) } # Vectorize reformat over &#39;out&#39; out[] &lt;- vapply(out, reformat, character(1)) out } #---------------------------------------------------------------------------------- # Accept only true-looking Latin binomials and reject common non-species nouns is_latin_binomial_strict &lt;- function(x) { x &lt;- as.character(x) ok_shape &lt;- grepl(&quot;^[A-Z][a-z]+\\\\s+[a-z]{3,}$&quot;, x) # Genus species if (!any(ok_shape, na.rm = TRUE)) return(rep(FALSE, length(x))) bad_terms &lt;- c( &quot;human&quot;,&quot;patient&quot;,&quot;infant&quot;,&quot;child&quot;,&quot;adult&quot;, &quot;feces&quot;,&quot;faeces&quot;,&quot;stool&quot;,&quot;urine&quot;,&quot;blood&quot;,&quot;saliva&quot;,&quot;swab&quot;,&quot;swabs&quot;, &quot;skin&quot;,&quot;gut&quot;,&quot;intestinal&quot;,&quot;rumen&quot;,&quot;content&quot;,&quot;contents&quot;, &quot;sample&quot;,&quot;metagenome&quot;,&quot;environment&quot;,&quot;environmental&quot;,&quot;tissue&quot;, &quot;rectal&quot;,&quot;oral&quot;,&quot;nasal&quot;,&quot;throat&quot;,&quot;vaginal&quot;,&quot;anal&quot; ) reject &lt;- rep(FALSE, length(x)) ix &lt;- which(ok_shape &amp; !is.na(x)) if (length(ix) &gt; 0) { parts &lt;- strsplit(x[ix], &quot;\\\\s+&quot;) for (i in seq_along(ix)) { w &lt;- tolower(parts[[i]]) reject[ix[i]] &lt;- any(w %in% bad_terms) } } ok_shape &amp; !reject } #---------------------------------------------------------------- infer_host_metadata &lt;- function(genome_metadata) { if (is.null(genome_metadata)) return(NULL) # Utility is_blank &lt;- function(x) is.na(x) | x == &quot;&quot; tax_map &lt;- tibble::tibble( host_species = c( # Humans / lab / livestock / pets &quot;Homo sapiens&quot;, &quot;Mus musculus&quot;, &quot;Rattus norvegicus&quot;, &quot;Sus scrofa&quot;, &quot;Bos taurus&quot;, &quot;Canis lupus familiaris&quot;, &quot;Equus caballus&quot;, &quot;Oryctolagus cuniculus&quot;, &quot;Capra hircus&quot;, # Birds &quot;Gallus gallus&quot;, &quot;Cathartes aura&quot;, &quot;Columba livia&quot;, &quot;Spheniscus magellanicus&quot;, # Insects &quot;Drosophila melanogaster&quot;, &quot;Bombyx mori&quot;, # Fish &quot;Danio rerio&quot;, &quot;Oncorhynchus mykiss&quot;, &quot;Oreochromis niloticus&quot;, # Marine mammals / pinnipeds &quot;Balaenoptera acutorostrata&quot;, &quot;Arctocephalus australis&quot;, # Extinct &quot;Mammuthus primigenius&quot;, #More &quot;Loxodonta africana&quot;, &quot;Elephas maximus&quot;, &quot;Felis catus&quot;, &quot;Canis lupus&quot;, &quot;Phascolarctos cinereus&quot;, &quot;Grasshopper&quot;, &quot;Termite&quot;, &quot;Macaca fascicularis&quot;, &quot;Rhinolophus capensis&quot;, &quot;Fish&quot; ), tax_host_order = c( # Humans / lab / livestock / pets &quot;Primates&quot;, &quot;Rodentia&quot;, &quot;Rodentia&quot;, &quot;Artiodactyla&quot;, &quot;Artiodactyla&quot;, &quot;Carnivora&quot;, &quot;Perissodactyla&quot;, &quot;Lagomorpha&quot;, &quot;Artiodactyla&quot;, # Birds &quot;Galliformes&quot;, &quot;Accipitriformes&quot;, &quot;Columbiformes&quot;, &quot;Sphenisciformes&quot;, # Insects &quot;Diptera&quot;, &quot;Lepidoptera&quot;, # Fish &quot;Cypriniformes&quot;, &quot;Salmoniformes&quot;, &quot;Cichliformes&quot;, # Marine mammals / pinnipeds &quot;Artiodactyla&quot;, # (Cetartiodactyla) &quot;Carnivora&quot;, # Extinct &quot;Proboscidea&quot;, #More &quot;Proboscidea&quot;, &quot;Proboscidea&quot;, &quot;Carnivora&quot;, &quot;Carnivora&quot;, &quot;Diprotodontia&quot;, &quot;Orthoptera&quot;, # Grasshopper &quot;Blattodea&quot;, # Termite (termites now placed within Blattodea; Isoptera as infraorder) &quot;Primates&quot;, # Macaca fascicularis &quot;Chiroptera&quot;, # Rhinolophus capensis (horseshoe bat) NA_character_ # Fish (no single order fits all fish) ), tax_host_class = c( # Humans / lab / livestock / pets &quot;Mammalia&quot;, &quot;Mammalia&quot;, &quot;Mammalia&quot;, &quot;Mammalia&quot;, &quot;Mammalia&quot;, &quot;Mammalia&quot;, &quot;Mammalia&quot;, &quot;Mammalia&quot;, &quot;Mammalia&quot;, # Birds &quot;Aves&quot;, &quot;Aves&quot;, &quot;Aves&quot;, &quot;Aves&quot;, # Insects &quot;Insecta&quot;, &quot;Insecta&quot;, # Fish &quot;Actinopterygii&quot;, &quot;Actinopterygii&quot;, &quot;Actinopterygii&quot;, # Marine mammals / pinnipeds &quot;Mammalia&quot;, &quot;Mammalia&quot;, # Extinct and more &quot;Mammalia&quot;, &quot;Mammalia&quot;, &quot;Mammalia&quot;, &quot;Mammalia&quot;, &quot;Mammalia&quot;, &quot;Mammalia&quot;, &quot;Insecta&quot;, # Grasshopper &quot;Insecta&quot;, # Termite &quot;Mammalia&quot;, # Macaca fascicularis &quot;Mammalia&quot;, # Rhinolophus capensis &quot;Actinopterygii&quot; # Fish (bony fishes; safe default for generic &quot;fish&quot;) ) ) # --- 1) Unified host text for pattern matching --- genome_metadata &lt;- genome_metadata %&gt;% dplyr::mutate( host_text = stringr::str_to_lower( stringr::str_squish( paste( dplyr::coalesce(.data$host_species, &quot;&quot;), dplyr::coalesce(.data$host, &quot;&quot;), dplyr::coalesce(.data$isolation_source, &quot;&quot;), dplyr::coalesce(.data$env_broad, &quot;&quot;), dplyr::coalesce(.data$env_local_context, &quot;&quot;), sep = &quot; ; &quot; ) ) ) ) # --- 2) Common-name / phrase heuristics (vectorized) --- guess_from_common &lt;- function(txt) { dplyr::case_when( # Exact species mentions / synonyms stringr::str_detect(txt, &quot;\\\\barctocephalus australis\\\\b|\\\\bfur seal\\\\b|south american fur seal&quot;) ~ &quot;Arctocephalus australis&quot;, stringr::str_detect(txt, &quot;\\\\bbalaenoptera acutorostrata\\\\b|\\\\bminke whale\\\\b&quot;) ~ &quot;Balaenoptera acutorostrata&quot;, stringr::str_detect(txt, &quot;\\\\bspheniscus magellanicus\\\\b|\\\\bmagellanic penguin\\\\b|\\\\bpenguin\\\\b&quot;) ~ &quot;Spheniscus magellanicus&quot;, #Elephants stringr::str_detect(txt, &quot;\\\\basian elephant\\\\b&quot;) ~ &quot;Elephas maximus&quot;, stringr::str_detect(txt, &quot;\\\\bafrican elephant\\\\b&quot;) ~ &quot;Loxodonta africana&quot;, stringr::str_detect(txt, &quot;\\\\belephants?\\\\b&quot;) ~ &quot;Loxodonta africana&quot;, # default choice #cats stringr::str_detect(txt, &quot;\\\\b(cat|cats|kitten|kittens|feline|house\\\\s*cat)\\\\b&quot;) ~ &quot;Felis catus&quot;, stringr::str_detect(txt, &quot;\\\\bfelis\\\\s+catus\\\\b&quot;) ~ &quot;Felis catus&quot;, # dogs stringr::str_detect(txt, &quot;\\\\b(dog|dogs|puppy|puppies|canine|pet\\\\s*dog)\\\\b&quot;) ~ &quot;Canis lupus familiaris&quot;, stringr::str_detect(txt, &quot;\\\\bcanis\\\\s+lupus\\\\s+familiaris\\\\b|\\\\bcanis\\\\s+familiaris\\\\b&quot;) ~ &quot;Canis lupus familiaris&quot;, # gray wolf (wild Canis lupus) --- stringr::str_detect(txt, &quot;\\\\bcanis\\\\s+lupus\\\\b|\\\\bgray\\\\s*wolf\\\\b|\\\\bgrey\\\\s*wolf\\\\b|\\\\bwolf\\\\b&quot;) ~ &quot;Canis lupus&quot;, #grasshopper stringr::str_detect(txt, &quot;\\\\bgrasshopper\\\\b|\\\\blocust\\\\b|\\\\blocusts\\\\b&quot;) ~ &quot;Grasshopper&quot;, stringr::str_detect(txt, &quot;\\\\brabbit\\\\b|\\\\bbunny\\\\b|\\\\bbunnies\\\\b|\\\\blagomorph\\\\b&quot;) ~ &quot;Oryctolagus cuniculus&quot;, stringr::str_detect(txt, &quot;\\\\bpigeon\\\\b|\\\\bdove\\\\b&quot;) ~ &quot;Columba livia&quot;, stringr::str_detect(txt, &quot;\\\\bequine\\\\b|\\\\bhorse\\\\b|\\\\bfoal\\\\b&quot;) ~ &quot;Equus caballus&quot;, stringr::str_detect(txt, &quot;\\\\bcattle\\\\b|\\\\bbovine\\\\b|\\\\bcow\\\\b|\\\\bcows\\\\b&quot;) ~ &quot;Bos taurus&quot;, stringr::str_detect(txt, &quot;\\\\bgoat\\\\b|\\\\bcaprine\\\\b|\\\\bkid\\\\b&quot;) ~ &quot;Capra hircus&quot;, stringr::str_detect(txt, &quot;\\\\bpiglet\\\\b|\\\\bpiglets\\\\b|\\\\bpig\\\\b|\\\\bswine\\\\b|\\\\bporcine\\\\b&quot;) ~ &quot;Sus scrofa&quot;, stringr::str_detect(txt, &quot;\\\\bmammoth\\\\b|malolyakovskiy\\\\s+mammoth&quot;) ~ &quot;Mammuthus primigenius&quot;, # Existing helpful ones stringr::str_detect(txt, &quot;homo sapiens|\\\\bhuman\\\\b|patient|adult|child|infant&quot;) ~ &quot;Homo sapiens&quot;, stringr::str_detect(txt, &quot;mus musculus|\\\\bmouse\\\\b|\\\\bmice\\\\b|murine&quot;) ~ &quot;Mus musculus&quot;, stringr::str_detect(txt, &quot;\\\\brattus|\\\\brat\\\\b&quot;) ~ &quot;Rattus norvegicus&quot;, stringr::str_detect(txt, &quot;sus scrofa|porcine|\\\\bpig\\\\b|swine&quot;) ~ &quot;Sus scrofa&quot;, stringr::str_detect(txt, &quot;bos taurus|bovine|\\\\bcow\\\\b|cattle&quot;) ~ &quot;Bos taurus&quot;, stringr::str_detect(txt, &quot;canis lupus familiaris|canis familiaris|\\\\bdog\\\\b|canine&quot;) ~ &quot;Canis lupus familiaris&quot;, stringr::str_detect(txt, &quot;gallus gallus|\\\\bchicken\\\\b|poultry&quot;) ~ &quot;Gallus gallus&quot;, stringr::str_detect(txt, &quot;bombyx mori|silkworm&quot;) ~ &quot;Bombyx mori&quot;, stringr::str_detect(txt, &quot;drosophila|fruit fly&quot;) ~ &quot;Drosophila melanogaster&quot;, stringr::str_detect(txt, &quot;danio rerio|zebrafish&quot;) ~ &quot;Danio rerio&quot;, stringr::str_detect(txt, &quot;oncorhynchus mykiss&quot;) ~ &quot;Oncorhynchus mykiss&quot;, stringr::str_detect(txt, &quot;oreochromis niloticus&quot;) ~ &quot;Oreochromis niloticus&quot;, stringr::str_detect(txt, &quot;\\\\btermite(s)?\\\\b&quot;) ~ &quot;Termite&quot;, # Macaca fascicularis (Latin or common names) --- stringr::str_detect(txt, &quot;\\\\bmacaca\\\\s+fascicularis\\\\b|\\\\bcynomolgus\\\\b|\\\\bcrab[-]eating\\\\s+macaque\\\\b|\\\\bmacaque\\\\b&quot;) ~ &quot;Macaca fascicularis&quot;, # Rhinolophus capensis (Latin or common name) --- stringr::str_detect(txt, &quot;\\\\brhinolophus\\\\s+capensis\\\\b|\\\\brhinolopus\\\\s+capensis\\\\b|\\\\bcape\\\\s+horseshoe\\\\s+bat\\\\b|\\\\bhorseshoe\\\\s+bat\\\\b&quot;) ~ &quot;Rhinolophus capensis&quot;, # Generic fish catch-all --- stringr::str_detect(txt, &quot;\\\\bfish\\\\b|\\\\bfishes\\\\b&quot;) ~ &quot;Fish&quot;, TRUE ~ NA_character_ ) } genome_metadata &lt;- genome_metadata %&gt;% dplyr::mutate(.common_guess = guess_from_common(.data$host_text)) # --- 3) Extract explicit Latin binomial (strict) as a later fallback --- extract_latin_binomial_strict &lt;- function(x) { x &lt;- x[!is.na(x)] if (length(x) == 0) return(NA_character_) txt &lt;- paste(x, collapse = &quot; ; &quot;) txt &lt;- stringr::str_replace_all(txt, &quot;[^A-Za-z ]+&quot;, &quot; &quot;) txt &lt;- stringr::str_squish(txt) matches &lt;- unlist(stringr::str_extract_all( txt, &quot;\\\\b[A-Z][a-z]+\\\\s+[a-z]{3,}\\\\b&quot; )) if (length(matches) == 0) return(NA_character_) valid &lt;- matches[is_latin_binomial_strict(matches)] if (length(valid) == 0) return(NA_character_) valid[1] } genome_metadata &lt;- genome_metadata %&gt;% dplyr::rowwise() %&gt;% dplyr::mutate( .binom_guess = extract_latin_binomial_strict(c( as.character(.data$host_species), as.character(.data$host), as.character(.data$isolation_source), as.character(.data$env_broad), as.character(.data$env_local_context) )) ) %&gt;% dplyr::ungroup() # --- 4) Decide host_species (trust valid binomial, then common-name, then binomial guess) --- bad_terms &lt;- &quot;(feces|faeces|stool|urine|blood|saliva|swab|swabs|skin|gut|intestinal|rumen|content|contents|sample|metagenome|environment|environmental|patient|infant|adult|child|rectal|oral|nasal|throat|vaginal|anal)&quot; genome_metadata &lt;- genome_metadata %&gt;% dplyr::mutate( host_species = dplyr::if_else( is_latin_binomial_strict(.data$host_species) &amp; !stringr::str_detect(stringr::str_to_lower(.data$host_species), bad_terms), normalize_species(.data$host_species), NA_character_ ), host_species = dplyr::case_when( !is_blank(.data$host_species) ~ .data$host_species, !is_blank(.data$.common_guess) ~ normalize_species(.data$.common_guess), # PRIORITIZE common-name mapping !is_blank(.data$.binom_guess) ~ normalize_species(.data$.binom_guess), # then extracted binomial TRUE ~ .data$host_species ) ) # --- 5) Join to fill order/class from dictionary --- genome_metadata &lt;- genome_metadata %&gt;% dplyr::left_join(tax_map, by = &quot;host_species&quot;) %&gt;% dplyr::mutate( host_order = dplyr::coalesce(.data$host_order, .data$tax_host_order), host_class = dplyr::coalesce(.data$host_class, .data$tax_host_class) ) %&gt;% dplyr::select(-dplyr::any_of(c(&quot;tax_host_order&quot;,&quot;tax_host_class&quot;))) # --- 6) host_type --- genome_metadata &lt;- genome_metadata %&gt;% dplyr::mutate( host_type = dplyr::case_when( .data$host_species == &quot;Homo sapiens&quot; ~ &quot;human&quot;, !is_blank(.data$host_species) ~ &quot;animal&quot;, TRUE ~ NA_character_ ) ) # Cleanup helpers genome_metadata &lt;- genome_metadata %&gt;% dplyr::select(-dplyr::any_of(c(&quot;.common_guess&quot;,&quot;.binom_guess&quot;,&quot;host_text&quot;))) return(genome_metadata) } 11.1.7 Normalize country and infer continent # Normalize country names and assign continents normalize_country_fields &lt;- function(genome_metadata) { if (is.null(genome_metadata)) return(NULL) # Be explicit about packages used # library(dplyr); library(stringr); library(countrycode) # 1) Simplify country strings like &quot;Country: region&quot; genome_metadata &lt;- genome_metadata %&gt;% dplyr::mutate( country_simple = stringr::str_trim( stringr::str_split_fixed(dplyr::coalesce(.data$country, &quot;&quot;), &quot;:&quot;, 2)[, 1] ), country_simple = dplyr::na_if(.data$country_simple, &quot;&quot;) ) # 2) Normalization map for common ENA/NCBI variants (patterns in lower-case) country_map &lt;- c( &quot;usa&quot; = &quot;United States&quot;, &quot;u\\\\.s\\\\.&quot; = &quot;United States&quot;, &quot;u\\\\.s\\\\.a\\\\.&quot; = &quot;United States&quot;, &quot;united states of america&quot; = &quot;United States&quot;, &quot;uk&quot; = &quot;United Kingdom&quot;, &quot;u\\\\.k\\\\.&quot; = &quot;United Kingdom&quot;, &quot;great britain&quot; = &quot;United Kingdom&quot;, &quot;england&quot; = &quot;United Kingdom&quot;, &quot;scotland&quot; = &quot;United Kingdom&quot;, &quot;wales&quot; = &quot;United Kingdom&quot;, &quot;northern ireland&quot; = &quot;United Kingdom&quot;, &quot;korea,? republic of&quot; = &quot;South Korea&quot;, &quot;republic of korea&quot; = &quot;South Korea&quot;, &quot;south korea&quot; = &quot;South Korea&quot;, &quot;korea,? \\\\(south\\\\)&quot; = &quot;South Korea&quot;, &quot;pr china&quot; = &quot;China&quot;, &quot;p\\\\.r\\\\. china&quot; = &quot;China&quot;, &quot;russian federation&quot; = &quot;Russia&quot;, &quot;czech republic&quot; = &quot;Czechia&quot;, &quot;swaziland&quot; = &quot;Eswatini&quot;, &quot;cote d[&#39;’]ivoire&quot; = &quot;Côte d’Ivoire&quot;, &quot;democratic republic of the congo&quot; = &quot;DR Congo&quot;, &quot;viet nam&quot; = &quot;Vietnam&quot;, &quot;myanmar \\\\(burma\\\\)&quot; = &quot;Myanmar&quot;, &quot;bolivia \\\\(plurinational state of\\\\)&quot; = &quot;Bolivia&quot;, &quot;iran,? islamic republic of&quot; = &quot;Iran&quot;, &quot;syrian arab republic&quot; = &quot;Syria&quot;, &quot;moldova,? republic of&quot; = &quot;Moldova&quot;, &quot;lao people&#39;?s democratic republic&quot; = &quot;Laos&quot;, &quot;macedonia,? the former yugoslav republic of&quot; = &quot;North Macedonia&quot;, &quot;palestine,? state of&quot; = &quot;Palestine&quot;, &quot;hong kong&quot; = &quot;Hong Kong&quot;, &quot;macau|macao&quot; = &quot;Macau&quot; ) normalize_country &lt;- function(x) { # Always return character y &lt;- stringr::str_trim(tolower(dplyr::coalesce(as.character(x), &quot;&quot;))) y[y == &quot;&quot;] &lt;- NA_character_ if (length(y)) { for (pat in names(country_map)) { repl &lt;- country_map[[pat]] # Use ^...$ to only replace whole-string matches after lowercasing y &lt;- ifelse(!is.na(y), stringr::str_replace_all(y, paste0(&quot;^&quot;, pat, &quot;$&quot;), repl), y) } # Minor tidy-ups y &lt;- ifelse(!is.na(y), stringr::str_replace_all(y, &quot;\\\\s+&quot;, &quot; &quot;), y) y &lt;- ifelse(y == &quot;people&#39;s republic of china&quot;, &quot;China&quot;, y) # Title-case anything still not mapped y &lt;- ifelse(!is.na(y), stringr::str_to_title(y), y) } return(as.character(y)) } # 3) Produce normalized country + continent (force character vector into countrycode) genome_metadata &lt;- genome_metadata %&gt;% dplyr::mutate( country_normalized = normalize_country(.data$country_simple), continent = countrycode::countrycode( sourcevar = as.character(.data$country_normalized), origin = &quot;country.name&quot;, destination = &quot;continent&quot;, warn = FALSE ) ) return(genome_metadata) } 11.1.8 Filter species that don’t belong and remove duplicate MAGs # Remove non-species MAGs and deduplicate genomes by quality, # merge GCA/GCF duplicates (keep GCF; merge metadata). filter_species_MAGs &lt;- function(genome_metadata, genome_annotations, mags_to_remove, match_on_version = TRUE) { if (is.null(genome_metadata) || is.null(genome_annotations)) { stop(&quot;Both genome_metadata and genome_annotations must be provided.&quot;) } # --------------------------- # Helpers # --------------------------- # Remove extensions and directories clean_label &lt;- function(x) { x &lt;- basename(x) sub(&quot;\\\\.(fna|fa|fasta)(\\\\.gz)?$&quot;, &quot;&quot;, x, ignore.case = TRUE) } # Extract (GCA|GCF) and numeric core (e.g., 015667075.1) from an ID # Handles optional GB_/RS_ prefixes; returns NA when not matching. extract_accession_fields &lt;- function(id_vec, match_on_version = TRUE) { id_vec &lt;- clean_label(id_vec) core_re &lt;- if (match_on_version) &quot;(\\\\d+(?:\\\\.\\\\d+)?)&quot; else &quot;(\\\\d+)&quot; pat &lt;- paste0(&quot;^(?:GB_|RS_)?(GC[AF])_&quot;, core_re, &quot;$&quot;) matched &lt;- grepl(pat, id_vec, perl = TRUE) acc_type &lt;- ifelse(matched, sub(pat, &quot;\\\\1&quot;, id_vec, perl = TRUE), NA_character_) acc_core &lt;- ifelse(matched, sub(pat, &quot;\\\\2&quot;, id_vec, perl = TRUE), NA_character_) data.frame(acc_type = acc_type, acc_core = acc_core, stringsAsFactors = FALSE) } # First non-NA helper (after we normalize empty &quot;&quot; to NA for characters) first_non_na &lt;- function(x) { idx &lt;- which(!is.na(x)) if (length(idx)) x[idx[1]] else NA } # Normalize empty strings to NA for character columns na_if_empty_chars &lt;- function(df) { df %&gt;% mutate(across(where(is.character), ~ na_if(., &quot;&quot;))) } # --------------------------- # Standardize removal list # --------------------------- mags_to_remove_clean &lt;- clean_label(mags_to_remove) # --------------------------- # 1) Preprocess genome_metadata # --------------------------- has_comp &lt;- &quot;completeness&quot; %in% names(genome_metadata) has_cont &lt;- &quot;contamination&quot; %in% names(genome_metadata) has_contigs &lt;- &quot;contigs&quot; %in% names(genome_metadata) gm0 &lt;- genome_metadata %&gt;% mutate(ID_clean = clean_label(ID)) %&gt;% # Make factors safe to merge mutate(across(where(is.factor), as.character)) %&gt;% na_if_empty_chars() # Remove wrong-species MAGs gm0 &lt;- gm0 %&gt;% filter(!ID_clean %in% mags_to_remove_clean) # Add accession parse fields acc &lt;- extract_accession_fields(gm0$ID_clean, match_on_version = match_on_version) gm1 &lt;- gm0 %&gt;% mutate(acc_type = acc$acc_type, acc_core = acc$acc_core) # Split into accessioned (GCA/GCF) and other IDs gm_acc &lt;- gm1 %&gt;% filter(!is.na(acc_core)) gm_other &lt;- gm1 %&gt;% filter(is.na(acc_core)) # For ordering by quality gm_acc &lt;- gm_acc %&gt;% mutate( completeness = if (has_comp) suppressWarnings(as.numeric(completeness)) else NA_real_, contamination = if (has_cont) suppressWarnings(as.numeric(contamination)) else NA_real_, contigs = if (has_contigs) suppressWarnings(as.numeric(contigs)) else NA_real_ ) # Collapse GCA/GCF duplicates by acc_core: # - Prefer GCF over GCA if present # - Within type, prefer higher completeness, lower contamination, fewer contigs # - Per column, take first non-NA after ordering (merges metadata) gm_acc_collapsed &lt;- gm_acc %&gt;% group_by(acc_core) %&gt;% group_modify(function(df, key) { # Prefer GCF if present prefer_gcf &lt;- any(df$acc_type == &quot;GCF&quot;) pref_rank &lt;- if (prefer_gcf) ifelse(df$acc_type == &quot;GCF&quot;, 0L, 1L) else 0L # Order rows by (preference, quality) ord &lt;- order( pref_rank, -ifelse(is.na(df$completeness), -Inf, df$completeness), ifelse(is.na(df$contamination), Inf, df$contamination), ifelse(is.na(df$contigs), Inf, df$contigs), na.last = TRUE ) dfo &lt;- df[ord, , drop = FALSE] # Summarize to one row by taking first non-NA per column # (ID will become the preferred row&#39;s ID; metadata merged) out &lt;- dfo %&gt;% summarise(across(everything(), first_non_na), .groups = &quot;drop&quot;) out }) %&gt;% ungroup() # For non-accessioned rows: fall back to your quality-based dedup by ID_clean if (nrow(gm_other) &gt; 0) { gm_other &lt;- gm_other %&gt;% mutate( completeness = if (has_comp) suppressWarnings(as.numeric(completeness)) else NA_real_, contamination = if (has_cont) suppressWarnings(as.numeric(contamination)) else NA_real_, contigs = if (has_contigs) suppressWarnings(as.numeric(contigs)) else NA_real_ ) %&gt;% arrange( ID_clean, desc(if (has_comp) completeness else 0), (if (has_cont) contamination else 0), (if (has_contigs) contigs else Inf) ) %&gt;% distinct(ID_clean, .keep_all = TRUE) } # Combine collapsed accessioned rows and deduped others genome_metadata_dedup &lt;- bind_rows(gm_acc_collapsed, gm_other) %&gt;% # Drop temp fields dplyr::select(-ID_clean, -acc_type, -acc_core) # --------------------------- # 2) Filter genome_annotations to match remaining genomes # --------------------------- ga0 &lt;- genome_annotations %&gt;% mutate(genome_clean = clean_label(genome)) # Remove wrong-species MAGs genome_annotations_filtered &lt;- ga0 %&gt;% filter(!genome_clean %in% mags_to_remove_clean) # Keep only genomes still present in metadata (after GCF/GCA merge) valid_genomes &lt;- clean_label(genome_metadata_dedup$ID) genome_annotations_filtered &lt;- genome_annotations_filtered %&gt;% filter(genome_clean %in% valid_genomes) %&gt;% dplyr::select(-genome_clean) # --------------------------- # 3) Return cleaned objects # --------------------------- list( metadata = genome_metadata_dedup, annotations = genome_annotations_filtered ) } 11.1.9 Process one species process_one_species &lt;- function(species, mags_to_remove = character(0)) { files &lt;- load_species_files(species) ehi &lt;- prep_ehi_metadata(files$ehi_metadata) gtdb &lt;- prep_gtdb_final(files$gtdb_final) ncbi &lt;- prep_ncbi_metadata(files$ncbi_metadata) meta &lt;- combine_metadata_sources(ehi, gtdb, ncbi) %&gt;% infer_host_metadata() %&gt;% normalize_country_fields() if (is.null(files$contig_map) || is.null(files$gene_annotations)) { warning(sprintf( &quot;[%s] Missing %s; returning metadata only.&quot;, species, if (is.null(files$contig_map) &amp;&amp; is.null(files$gene_annotations)) &quot;contig_map and gene_annotations&quot; else if (is.null(files$contig_map)) &quot;contig_map&quot; else &quot;gene_annotations&quot; )) return(list(metadata = meta, annotations = NULL)) } ann &lt;- prep_gene_annotations_with_genome( ann_raw = files$gene_annotations, contig_map_raw = files$contig_map ) cleaned &lt;- filter_species_MAGs( genome_metadata = meta, genome_annotations = ann, mags_to_remove = mags_to_remove ) cleaned } # sp &lt;- &quot;lactococcus_lactis&quot; # res &lt;- process_one_species(sp) # # genome_metadata &lt;- res$metadata # # write_tsv(genome_metadata, &quot;data/mags_metadata/lactococcus_lactis_FINAL_metadata.tsv&quot;) 11.2 DREP ANALYSIS 11.2.1 Recreating the drep tree Checking for outliers ## Function to recreate the drep tree from the secondary alignment (FASTANI) recreate_drep_tree &lt;- function(ndb){ genomes &lt;- unique(c(ndb$reference, ndb$querry)) # Create empty matrix ani_matrix &lt;- matrix(0, nrow = length(genomes), ncol = length(genomes)) rownames(ani_matrix) &lt;- genomes colnames(ani_matrix) &lt;- genomes # Fill the matrix for(i in 1:nrow(ndb)) { ref &lt;- ndb$reference[i] qry &lt;- ndb$querry[i] ani_val &lt;- ndb$ani[i] ani_matrix[ref, qry] &lt;- ani_val ani_matrix[qry, ref] &lt;- ani_val # Make symmetric } # Set diagonal to 100 diag(ani_matrix) &lt;- 100 # Convert to distance matrix (for tree building) dist_matrix &lt;- as.dist(1 - ani_matrix) # Build tree hc &lt;- hclust(dist_matrix, method = &quot;average&quot;) #drep uses hierarchical clustering tree &lt;- as.phylo(hc) ggtree(tree) + geom_tiplab(size = 2) + theme_tree2() } ndb &lt;- read_csv(&quot;data/mags_metadata/phocaeicola_vulgatus_Ndb.csv&quot;) Rows: 651250 Columns: 5 ── Column specification ──────────────────────────────────────────────────────────────────────────────────────── Delimiter: &quot;,&quot; chr (2): reference, querry dbl (3): ani, alignment_coverage, primary_cluster ℹ Use `spec()` to retrieve the full column specification for this data. ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. recreate_drep_tree(ndb) Warning in fortify(data, ...): Arguments in `...` must be used. ✖ Problematic arguments: • as.Date = as.Date • yscale_mapping = yscale_mapping • hang = hang ℹ Did you misspell an argument name? Found more than one class &quot;phylo&quot; in cache; using the first, from namespace &#39;phyloseq&#39; Also defined by &#39;tidytree&#39; 11.2.2 Drep final tree, matrix and plots # helper: strip file extensions so IDs match metadata clean_label &lt;- function(x) { x &lt;- basename(x) sub(&quot;\\\\.(fna|fa|fasta)(\\\\.gz)?$&quot;, &quot;&quot;, x, ignore.case = TRUE) } ##### Drep tree metadata --------------------------------------------------------------------------------- drep_tree_metadata &lt;- function(genome_metadata = genome_metadata, ndb =ndb, drop_ids = character(0)){ metadata &lt;- genome_metadata id_col &lt;- &quot;ID&quot; fastani &lt;- ndb %&gt;% dplyr::select(reference, querry, ani) %&gt;% dplyr::filter(!is.na(reference), !is.na(querry), reference != querry) # Clean IDs to remove extensions fastani &lt;- fastani %&gt;% dplyr::mutate( reference = clean_label(reference), querry = clean_label(querry) ) %&gt;% dplyr::filter(reference != querry) # Remove duplicate pairs (keep the max ANI per pair) fastani &lt;- fastani %&gt;% dplyr::group_by(reference, querry) %&gt;% dplyr::summarise(ani = max(ani), .groups = &quot;drop&quot;) # Optionally drop genomes (IDs without suffix) if (length(drop_ids) &gt; 0) { fastani &lt;- fastani %&gt;% dplyr::filter(!reference %in% drop_ids, !querry %in% drop_ids) } # Build a symmetric ANI matrix with diag = 1 (dedup-safe) genomes &lt;- sort(unique(c(fastani$reference, fastani$querry))) both &lt;- dplyr::bind_rows( fastani %&gt;% dplyr::transmute(reference, querry, ani), fastani %&gt;% dplyr::transmute(reference = querry, querry = reference, ani) ) %&gt;% dplyr::distinct(reference, querry, .keep_all = TRUE) ani_mat &lt;- both %&gt;% tidyr::complete(reference = genomes, querry = genomes) %&gt;% tidyr::pivot_wider( names_from = querry, values_from = ani, values_fn = max # &lt;-- ensure no duplicate cells cause errors ) %&gt;% tibble::column_to_rownames(&quot;reference&quot;) %&gt;% as.matrix() diag(ani_mat) &lt;- 1 # Build the tree (UPGMA/average as in dRep) dist_mat &lt;- 1 - ani_mat hc &lt;- hclust(as.dist(dist_mat), method = &quot;average&quot;) tree &lt;- ape::as.phylo(hc) # De-duplicate metadata by ID and clean ID if needed metadata_dedup &lt;- metadata %&gt;% dplyr::mutate(!!id_col := clean_label(.data[[id_col]])) %&gt;% # safe if already clean dplyr::distinct(.data[[id_col]], .keep_all = TRUE) # Add metadata to tips (tree labels are already clean IDs) stopifnot(id_col %in% names(metadata_dedup)) tip_df &lt;- tibble::tibble(label = tree$tip.label) %&gt;% dplyr::left_join(metadata_dedup, by = setNames(id_col, &quot;label&quot;)) %&gt;% dplyr::mutate(label_clean = label) return(list( tree = tree, tip_df = tip_df, ani_matrix = ani_mat )) } ####----------------------------------------------------------------------------------------- # Helper for ANI axis labels (unchanged) ani_axis &lt;- function(p, tree, show_threshold = NULL) { df &lt;- ggtree::fortify(tree) max_x &lt;- max(df$x[df$isTip]) p &lt;- p + scale_x_continuous( labels = function(x) round(100 * (1 - (max_x - x)), 1) ) + coord_cartesian(xlim = c(0, max_x + 0.005)) + labs(x = &quot;Average Nucleotide Identity (ANI, %)&quot;) + theme_tree2() if (!is.null(show_threshold)) { thr_delta &lt;- 1 - (show_threshold / 100) p &lt;- p + geom_vline(xintercept = max_x - thr_delta, linetype = &quot;dashed&quot;, color = &quot;red&quot;, size = 0.8) } p } ### --------------PLOTS ---------------------------------------- # - BASIC PLOT -- plot_tree_basic &lt;- function(tree, tip_df, color_by = NULL, label_tips = TRUE, point_size = 2.5, show_threshold = NULL) { # ensure completeness numeric for continuous gradients if (&quot;completeness&quot; %in% names(tip_df)) { tip_df &lt;- tip_df %&gt;% dplyr::mutate(completeness = as.numeric(completeness)) } p &lt;- ggtree(tree, size = 0.8) p &lt;- p %&lt;+% tip_df if (!is.null(color_by) &amp;&amp; color_by %in% names(tip_df)) { p &lt;- p + geom_tippoint(aes(color = !!rlang::sym(color_by)), size = point_size) # Palette/scale logic if (identical(color_by, &quot;source&quot;) &amp;&amp; exists(&quot;source_colors&quot;)) { p &lt;- p + scale_color_manual(values = source_colors, name = &quot;Source&quot;, drop = FALSE) } else if (identical(color_by, &quot;host_order&quot;) &amp;&amp; exists(&quot;host_order_colors&quot;)) { p &lt;- p + scale_color_manual(values = host_order_colors, name = &quot;Host order&quot;, drop = FALSE) } else if (is.numeric(tip_df[[color_by]])) { p &lt;- p + scale_color_gradient(low = &quot;white&quot;, high = &quot;#08306B&quot;, name = paste0(color_by, &quot; (%)&quot;)) } } else { p &lt;- p + geom_tippoint(size = point_size) } if (label_tips) { lab_col &lt;- if (&quot;label_clean&quot; %in% names(tip_df)) &quot;label_clean&quot; else &quot;label&quot; p &lt;- p + geom_tiplab(size = 3, hjust = -0.1, aes(label = .data[[lab_col]])) } ani_axis(p, tree, show_threshold = show_threshold) } sp &lt;- &quot;phocaeicola_vulgatus&quot; res &lt;- process_one_species(sp) Warning in process_one_species(sp): [phocaeicola_vulgatus] Missing gene_annotations; returning metadata only. genome_metadata &lt;- res$metadata phocaeicola_results &lt;- drep_tree_metadata(genome_metadata, ndb, drop_ids = c(&quot;GCA_040912025.1&quot;, &quot;GCF_048453085.1&quot;, &quot;GCA_048453085.1&quot;)) tree &lt;- phocaeicola_results$tree tip_df &lt;- phocaeicola_results$tip_df ani_matrix &lt;- phocaeicola_results$ani_matrix p_host_order &lt;- plot_tree_basic(tree, tip_df, color_by = &quot;host_order&quot;, label_tips = TRUE, show_threshold = 99.5) Warning in fortify(data, ...): Arguments in `...` must be used. ✖ Problematic arguments: • as.Date = as.Date • yscale_mapping = yscale_mapping • hang = hang • size = 0.8 ℹ Did you misspell an argument name? Found more than one class &quot;phylo&quot; in cache; using the first, from namespace &#39;phyloseq&#39; Also defined by &#39;tidytree&#39; p_host_order 11.2.3 PERMANOVA, PcoA #-------------1) Filter out unkown host type ------------------ filter_metadata &lt;- function(tip_df) { tip_df %&gt;% dplyr::filter(!is.na(host_type) &amp; host_type != &quot;&quot;) } #-------------2) Subset and align (same order) ------------------ subset_and_align_ani &lt;- function(ani_matrix, meta_df) { keep_ids &lt;- intersect(rownames(ani_matrix), meta_df$label) ani_mat_f &lt;- ani_matrix[keep_ids, keep_ids, drop = FALSE] meta_f &lt;- meta_df %&gt;% dplyr::filter(label %in% keep_ids) %&gt;% dplyr::arrange(match(label, rownames(ani_mat_f))) stopifnot(identical(meta_f$label, rownames(ani_mat_f))) list(ani = ani_mat_f, meta = meta_f) } #-------------3) Run PERMANOVA ------------------ run_permanova &lt;- function(dist_mat, meta_f) { set.seed(1) ad &lt;- vegan::adonis2(dist_mat ~ host_type, data = meta_f, permutations = 999) bd &lt;- vegan::betadisper(dist_mat, meta_f$host_type) list(adonis = ad, dispersion = anova(bd)) } #-------------4) Run PCOA ------------------ run_pcoa &lt;- function(dist_mat, meta_f) { pcoa_res &lt;- ape::pcoa(dist_mat) data.frame( PC1 = pcoa_res$vectors[, 1], PC2 = pcoa_res$vectors[, 2], host_type = meta_f$host_type, host_order = meta_f$host_order ) } #-------------5) Plots PCOA ------------------ plot_pcoa_host_type &lt;- function(pcoa_df, host_type_colors) { ggplot2::ggplot(pcoa_df, ggplot2::aes(PC1, PC2, color = host_type)) + ggplot2::geom_point(size = 2, alpha = 0.9) + ggplot2::scale_color_manual(values = host_type_colors, name = &quot;Host type&quot;) + ggplot2::theme_minimal(base_size = 12) + ggplot2::labs(title = &quot;PCoA of ANI distances (filtered to known host_type)&quot;) } plot_pcoa_host_order &lt;- function(pcoa_df, host_order_colors) { ggplot2::ggplot(pcoa_df, ggplot2::aes(PC1, PC2, color = host_order)) + ggplot2::geom_point(size = 2, alpha = 0.9) + ggplot2::scale_color_manual(values = host_order_colors, name = &quot;Host order&quot;) + ggplot2::theme_minimal(base_size = 12) + ggplot2::labs(title = &quot;PCoA of ANI distances&quot;) } #-------------5) Pairwise ANI ------------------ pairwise_ani &lt;- function(ani_mat_f, meta_f) { ani_mat_f %&gt;% as.data.frame() %&gt;% tibble::rownames_to_column(&quot;ref&quot;) %&gt;% tidyr::pivot_longer(-ref, names_to = &quot;qry&quot;, values_to = &quot;ani&quot;) %&gt;% dplyr::filter(ref &lt; qry) %&gt;% # unique pairs dplyr::mutate( ref_host = meta_f$host_type[match(ref, meta_f$label)], qry_host = meta_f$host_type[match(qry, meta_f$label)], pair_type = dplyr::case_when( ref_host == &quot;human&quot; &amp; qry_host == &quot;human&quot; ~ &quot;human–human&quot;, ref_host == &quot;animal&quot; &amp; qry_host == &quot;animal&quot; ~ &quot;animal–animal&quot;, TRUE ~ &quot;animal–human&quot; ) ) } #-------------6) Plot pairwise ANI boxplot ------------------ plot_pairwise_boxplot &lt;- function(ani_long_f) { ggplot2::ggplot(ani_long_f, ggplot2::aes(pair_type, ani, fill = pair_type)) + ggplot2::geom_boxplot(outlier_size = 0.5, width = 0.7) + ggplot2::scale_fill_viridis_d(guide = &quot;none&quot;) + ggplot2::theme_minimal(base_size = 12) + ggplot2::labs(x = NULL, y = &quot;ANI&quot;, title = &quot;Within- and between-group ANI (known host_type only)&quot;) } #-------------7) Wilcoxon tests ------------------ wilcox_within &lt;- function(ani_long_f) { subset_within &lt;- ani_long_f %&gt;% dplyr::filter(pair_type %in% c(&quot;animal–animal&quot;, &quot;human–human&quot;)) wt &lt;- stats::wilcox.test(ani ~ pair_type, data = subset_within, exact = FALSE) summary_df &lt;- subset_within %&gt;% dplyr::group_by(pair_type) %&gt;% dplyr::summarise(n = dplyr::n(), median_ani = stats::median(ani), .groups = &quot;drop&quot;) list(test = wt, summary = summary_df) } wilcox_cross_vs_within &lt;- function(ani_long_f) { # Compare cross-host to pooled within (animal–animal + human–human) df &lt;- ani_long_f %&gt;% dplyr::mutate(is_cross = ifelse(pair_type == &quot;animal–human&quot;, &quot;cross&quot;, &quot;within&quot;)) wt &lt;- stats::wilcox.test(ani ~ is_cross, data = df, exact = FALSE, alternative = &quot;less&quot;) # &#39;less&#39; tests if cross &lt; within (lower ANI between hosts) summary_df &lt;- df %&gt;% dplyr::group_by(is_cross) %&gt;% dplyr::summarise(n = dplyr::n(), median_ani = stats::median(ani), .groups = &quot;drop&quot;) list(test = wt, summary = summary_df) } #----------------------------------------------------# #-------------- DREP STATS ANALYSIS ------------------ # combines the functions above into a big one drep_stat_analysis &lt;- function(tip_df, ani_matrix, host_type_colors, host_order_colors) { tip_df_f &lt;- tip_df %&gt;% dplyr::filter(!is.na(host_type) &amp; host_type != &quot;&quot;) aligned &lt;- subset_and_align_ani(ani_matrix, tip_df_f) ani_mat_f &lt;- aligned$ani meta_f &lt;- aligned$meta if (is.factor(meta_f$host_type)) meta_f$host_type &lt;- droplevels(meta_f$host_type) dist_mat_f &lt;- stats::as.dist(1 - ani_mat_f) permanova_results &lt;- run_permanova(dist_mat_f, meta_f) pcoa_df &lt;- run_pcoa(dist_mat_f, meta_f) pcoa_host_type_plot &lt;- plot_pcoa_host_type(pcoa_df, host_type_colors) pcoa_host_order_plot &lt;- plot_pcoa_host_order(pcoa_df, host_order_colors) ani_long_f &lt;- pairwise_ani(ani_mat_f, meta_f) boxplot_pairs &lt;- plot_pairwise_boxplot(ani_long_f) w_within &lt;- wilcox_within(ani_long_f) w_cross &lt;- wilcox_cross_vs_within(ani_long_f) list( filtered_metadata = meta_f, ani = ani_mat_f, dist = dist_mat_f, permanova = permanova_results, pcoa = list(data = pcoa_df, by_host_type = pcoa_host_type_plot, by_host_order = pcoa_host_order_plot), pairwise = list(data = ani_long_f, boxplot = boxplot_pairs, wilcox_within = w_within, wilcox_cross_vs_within = w_cross) ) } res &lt;- drep_stat_analysis( tip_df = tip_df, ani_matrix = ani_matrix, host_type_colors = host_type_colors, host_order_colors = host_order_colors ) Warning in ggplot2::geom_boxplot(outlier_size = 0.5, width = 0.7): Ignoring unknown parameters: `outlier_size` # Print stats res$permanova$adonis Permutation test for adonis under reduced model Permutation: free Number of permutations: 999 vegan::adonis2(formula = dist_mat ~ host_type, data = meta_f, permutations = 999) Df SumOfSqs R2 F Pr(&gt;F) Model 1 0.000562 0.00922 7.4576 0.001 *** Residual 801 0.060367 0.99078 Total 802 0.060929 1.00000 --- Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 res$permanova$dispersion Analysis of Variance Table Response: Distances Df Sum Sq Mean Sq F value Pr(&gt;F) Groups 1 0.00000405 4.0517e-06 1.1564 0.2825 Residuals 801 0.00280654 3.5038e-06 res$pairwise$wilcox_within$test Wilcoxon rank sum test with continuity correction data: ani by pair_type W = 298130877, p-value = 2.073e-05 alternative hypothesis: true location shift is not equal to 0 res$pairwise$wilcox_cross_vs_within$test Wilcoxon rank sum test with continuity correction data: ani by is_cross W = 6415885806, p-value &lt; 2.2e-16 alternative hypothesis: true location shift is less than 0 # Plot print(res$pcoa$by_host_type) print(res$pcoa$by_host_order) print(res$pairwise$boxplot) # Save plots: # ggplot2::ggsave(&quot;pcoa_host_type.png&quot;, res$pcoa$by_host_type, width = 6, height = 5, dpi = 300) 11.3 FUNCTIONAL ANALYSIS: KEGG, AMR, VF, CAZY, DEFENSE, GIFTS 11.3.1 Create annotation matrices #testing with hafnia sp &lt;- &quot;citrobacter_braakii&quot; res &lt;- process_one_species(sp) hp &lt;- res$metadata genome_annotations &lt;- res$annotations genome_metadata &lt;- hp make_annotation_matrix &lt;- function(genome_annotations, column) { genome_annotations %&gt;% filter(!is.na(.data[[column]])) %&gt;% count(genome, annotation = .data[[column]]) %&gt;% tidyr::pivot_wider( names_from = annotation, values_from = n, values_fill = 0 ) } #testing kegg_mat &lt;- make_annotation_matrix(genome_annotations, &quot;kegg&quot;) amr_mat &lt;- make_annotation_matrix(genome_annotations, &quot;resistance_target&quot;) vf_mat &lt;- make_annotation_matrix(genome_annotations, &quot;vf&quot;) 11.3.2 Run Fisher tests on proportions run_fisher_tests &lt;- function(mat, metadata, annotation_name = &quot;feature&quot;) { # mat: wide matrix with columns: genome, &lt;annotation columns...&gt; # metadata: data frame with columns ID, host_type # annotation_name: name for the long column (e.g., &quot;kegg&quot;, &quot;amr&quot;) # checks if (!&quot;genome&quot; %in% names(mat)) { stop(&quot;Input &#39;mat&#39; must contain a &#39;genome&#39; column.&quot;) } if (!all(c(&quot;ID&quot;, &quot;host_type&quot;) %in% names(metadata))) { stop(&quot;Input &#39;metadata&#39; must contain columns &#39;ID&#39; and &#39;host_type&#39;.&quot;) } # Presence/absence conversion (keep genome as-is; non-NA and non-zero -&gt; 1 else 0) pa &lt;- mat %&gt;% dplyr::mutate( dplyr::across( -genome, ~ as.integer(!is.na(.) &amp; . != 0) ) ) # Wide -&gt; long pa_long &lt;- pa %&gt;% tidyr::pivot_longer( cols = -genome, names_to = annotation_name, # creates a column with this exact name values_to = &quot;present&quot; ) %&gt;% dplyr::filter(present == 1L) %&gt;% dplyr::select(genome, dplyr::all_of(annotation_name)) %&gt;% # keep genome + annotation dplyr::distinct() # Attach host_type pa_with_host &lt;- pa_long %&gt;% dplyr::left_join( metadata %&gt;% dplyr::select(ID, host_type), by = c(&quot;genome&quot; = &quot;ID&quot;) ) # Count how many MAGs present in each annotation by host_type pa_mag_counts &lt;- pa_with_host %&gt;% dplyr::group_by(host_type, .data[[annotation_name]]) %&gt;% dplyr::summarise(n_mags = dplyr::n(), .groups = &quot;drop&quot;) # Totals per host_type (denominator) total_mags_per_host_type &lt;- metadata %&gt;% dplyr::group_by(host_type) %&gt;% dplyr::summarise(total_mags = dplyr::n_distinct(ID), .groups = &quot;drop&quot;) # Proportions + absences pa_mag_proportions &lt;- pa_mag_counts %&gt;% dplyr::left_join(total_mags_per_host_type, by = &quot;host_type&quot;) %&gt;% dplyr::mutate( proportion = n_mags / total_mags, absent = total_mags - n_mags ) # Build the wide counts matrix (animal vs human) pa_matrix &lt;- pa_mag_proportions %&gt;% dplyr::select(dplyr::all_of(annotation_name), host_type, n_mags, absent) %&gt;% tidyr::pivot_wider( names_from = host_type, values_from = c(n_mags, absent), values_fill = 0 ) # Sanity check for expected host groups (animal/human) required_cols &lt;- c( annotation_name, &quot;n_mags_animal&quot;, &quot;absent_animal&quot;, &quot;n_mags_human&quot;, &quot;absent_human&quot; ) if (!all(required_cols %in% names(pa_matrix))) { stop( &quot;Expected columns missing in pa_matrix: &quot;, paste(setdiff(required_cols, names(pa_matrix)), collapse = &quot;, &quot;), &quot;\\nCheck that metadata$host_type contains &#39;animal&#39; and &#39;human&#39; and that both have genomes.&quot; ) } # Fisher exact test per row (2x2) results &lt;- pa_matrix %&gt;% dplyr::rowwise() %&gt;% dplyr::mutate( ft = list(stats::fisher.test( matrix( c(n_mags_animal, absent_animal, n_mags_human, absent_human), nrow = 2, byrow = TRUE ) )), p_value = ft$p.value, odds_ratio = unname(ft$estimate), log2_or = log2(odds_ratio), conf_low = ft$conf.int[1], conf_high = ft$conf.int[2] ) %&gt;% dplyr::ungroup() %&gt;% dplyr::select(-ft) %&gt;% dplyr::mutate( p_adj = stats::p.adjust(p_value, method = &quot;BH&quot;), prop_animal = n_mags_animal / (n_mags_animal + absent_animal), prop_human = n_mags_human / (n_mags_human + absent_human), diff_prop = prop_human - prop_animal ) return(results) } kegg_fisher &lt;- run_fisher_tests(kegg_mat, genome_metadata, annotation_name=&quot;kegg&quot;) amr_fisher &lt;- run_fisher_tests(amr_mat, genome_metadata, annotation_name=&quot;amr&quot;) 11.3.3 Volcano plot plot_volcano &lt;- function(df, feature_col) { df %&gt;% mutate( p_adj_capped = pmax(p_adj, 1e-300), nl10 = -log10(p_adj_capped), sig = p_adj &lt; 0.05 ) %&gt;% ggplot(aes(x = log2_or, y = nl10)) + geom_point(aes(color = sig), size = 2) + scale_color_manual(values = c(&quot;grey70&quot;, &quot;blue&quot;)) + geom_hline(yintercept = -log10(0.05), linetype = &quot;dashed&quot;) + ggrepel::geom_text_repel( data = . %&gt;% filter(sig) %&gt;% slice_max(nl10, n = 10), aes(label = .data[[feature_col]]) ) + theme_minimal() } plot_volcano(kegg_fisher, &quot;kegg&quot;) plot_volcano(amr_fisher, &quot;amr&quot;) run_pca &lt;- function(mat) { m &lt;- mat %&gt;% column_to_rownames(&quot;genome&quot;) m &lt;- m / rowSums(m) m &lt;- m[, apply(m, 2, sd) &gt; 0] prcomp(m, scale. = TRUE) } pca_kegg &lt;- run_pca(kegg_mat) pca_amr &lt;- run_pca(amr_mat) 11.3.4 PERMANOVA on presence/absence matrix´ To check if the groups (animal vs human-sourced MAGs) have differences overall. pa_permanova &lt;- function(mat, metadata) { mat &lt;- mat %&gt;% column_to_rownames(&quot;genome&quot;) pa &lt;- (mat &gt; 0) * 1 # remove zero-variance KOs pa_nz &lt;- pa[, colSums(pa) &gt; 0 &amp; colSums(pa) &lt; nrow(pa)] # Determine the common genomes common_ids &lt;- base::intersect(rownames(pa_nz), metadata$ID) # Report what will be kept/dropped message(&quot;# common: &quot;, length(common_ids)) message(&quot;# in KEGG only: &quot;, length(setdiff(rownames(pa_nz), metadata$ID))) message(&quot;# in metadata only: &quot;, length(setdiff(metadata$ID, rownames(pa_nz)))) # Subset to the intersection (and keep order identical) pa_nz &lt;- pa_nz[common_ids, , drop = FALSE] meta &lt;- metadata %&gt;% dplyr::filter(ID %in% common_ids) %&gt;% dplyr::distinct(ID, .keep_all = TRUE) %&gt;% tibble::column_to_rownames(&quot;ID&quot;) %&gt;% .[common_ids, , drop = FALSE] stopifnot(identical(rownames(meta), rownames(pa_nz))) # Prepare variables for PERMANOVA required_vars &lt;- c(&quot;genome_size&quot;, &quot;completeness&quot;, &quot;host_type&quot;) # Coerce types as needed meta &lt;- meta %&gt;% dplyr::mutate( genome_size = as.numeric(genome_size), completeness = as.numeric(completeness), host_type = as.factor(host_type) ) # Align on complete cases (adonis2 drops NAs otherwise) ok &lt;- stats::complete.cases(meta[, required_vars, drop = FALSE]) pa_nz &lt;- pa_nz[ok, , drop = FALSE] meta &lt;- meta[ok, , drop = FALSE] stopifnot(identical(rownames(meta), rownames(pa_nz))) # Distance, dispersion, PERMANOVA dist_pa &lt;- vegan::vegdist(pa_nz, method = &quot;jaccard&quot;, binary = TRUE) betadisp_results &lt;- vegan::betadisper(dist_pa, meta$host_type) permanova_results &lt;- vegan::adonis2( dist_pa ~ genome_size + completeness + host_type, data = meta, permutations = 999, by = &quot;margin&quot; ) results &lt;- list( dist = dist_pa, betadisper = betadisp_results, permanova = permanova_results, pa_nz = pa_nz) return(results) } results &lt;-pa_permanova(kegg_mat, genome_metadata) # common: 30 # in KEGG only: 0 # in metadata only: 0 results$permanova Permutation test for adonis under reduced model Marginal effects of terms Permutation: free Number of permutations: 999 vegan::adonis2(formula = dist_pa ~ genome_size + completeness + host_type, data = meta, permutations = 999, by = &quot;margin&quot;) Df SumOfSqs R2 F Pr(&gt;F) genome_size 1 0.11642 0.05898 2.0238 0.039 * completeness 1 0.20836 0.10555 3.6221 0.021 * host_type 1 0.09819 0.04974 1.7070 0.063 . Residual 26 1.49567 0.75769 Total 29 1.97399 1.00000 --- Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 11.4 Define species list # ALL SPECIES species_list &lt;- c( &quot;lactococcus_lactis&quot;, &quot;parabacteroides_goldsteinii&quot;, &quot;enterococcus_faecalis&quot;, &quot;bacteroides_uniformis&quot;, &quot;phocaeicola_vulgatus&quot;, &quot;hafnia_paralvei&quot;, &quot;citrobacter_braakii&quot;, &quot;enterococcus_hirae&quot;, &quot;akkermansia_muciniphila&quot;, &quot;bacteroides_fragilis&quot; ) mags_to_remove_list &lt;- list( lactococcus_lactis = c( &quot;GCA_018369575.1.fna&quot;,&quot;GCA_947063445.1.fna&quot;,&quot;GCA_947101685.1.fna&quot;, &quot;GCA_948698275.1.fna&quot;,&quot;GCA_937910935.1.fna&quot;,&quot;GCA_947072755.1.fna&quot;, &quot;GCA_948655095.1.fna&quot;,&quot;GCA_948703095.1.fna&quot;,&quot;GCA_947041925.1.fna&quot;, &quot;GCA_947073355.1.fna&quot;,&quot;GCA_948675165.1.fna&quot;,&quot;GCA_948718815.1.fna&quot; ), parabacteroides_goldsteinii = character(0), # none to remove enterococcus_faecalis = character(0), hafnia_paralvei = character(0), bacteroides_uniformis = character(0), phocaeicola_vulgatus = c(&quot;GCA_040912025.1&quot;, &quot;GCF_048453085.1&quot;, &quot;GCA_048453085.1&quot;), citrobacter_braakii = character(0), enterococcus_hirae = character(0), akkermansia_muciniphila = character(0), bacteroides_fragilis = character(0) ) # pg &lt;- results[[&quot;parabacteroides_goldsteinii&quot;]]$metadata # eh &lt;- results[[&quot;enterococcus_hirae&quot;]]$metadata # pv &lt;- results[[&quot;phocaeicola_vulgatus&quot;]]$metadata # am &lt;- results[[&quot;akkermansia_muciniphila&quot;]]$metadata # bf &lt;- results[[&quot;bacteroides_fragilis&quot;]]$metadata # bu &lt;- results[[&quot;bacteroides_uniformis&quot;]]$metadata # ll &lt;- results[[&quot;lactococcus_lactis&quot;]]$metadata #hp &lt;- results[[&quot;hafnia_paralvei&quot;]]$metadata species_list &lt;- c( &quot;citronacter_braakii&quot;, &quot;hafnia_paralvei&quot; ) mags_to_remove_list &lt;- list( citronacter_braakii = character(0), hafnia_paralvei = character(0) ) # ---- Run for all species ---- results &lt;- setNames(vector(&quot;list&quot;, length(species_list)), species_list) for (sp in species_list) { results[[sp]] &lt;- process_one_species( species = sp, mags_to_remove = mags_to_remove_list[[sp]] ) } Warning in process_one_species(species = sp, mags_to_remove = mags_to_remove_list[[sp]]): [citronacter_braakii] Missing contig_map and gene_annotations; returning metadata only. # Examples: # results[[&quot;lactococcus_lactis&quot;]]$metadata # results[[&quot;lactococcus_lactis&quot;]]$annotations 11.5 Testing functions with one species sp &lt;- &quot;citrobacter_braakii&quot; res &lt;- process_one_species(sp) genome_metadata &lt;- res$metadata gene_annotations &lt;- res$annotations ndb &lt;- read_csv(&quot;data/mags_metadata/citrobacter_braakii_Ndb.csv&quot;) #include in process one species Rows: 1681 Columns: 5 ── Column specification ──────────────────────────────────────────────────────────────────────────────────────── Delimiter: &quot;,&quot; chr (2): reference, querry dbl (3): ani, alignment_coverage, primary_cluster ℹ Use `spec()` to retrieve the full column specification for this data. ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. recreate_drep_tree(ndb) Warning in fortify(data, ...): Arguments in `...` must be used. ✖ Problematic arguments: • as.Date = as.Date • yscale_mapping = yscale_mapping • hang = hang ℹ Did you misspell an argument name? Found more than one class &quot;phylo&quot; in cache; using the first, from namespace &#39;phyloseq&#39; Also defined by &#39;tidytree&#39; drep_results &lt;- drep_tree_metadata(genome_metadata, ndb) tree &lt;- drep_results$tree tip_df &lt;- drep_results$tip_df ani_matrix &lt;- drep_results$ani_matrix p_host_order &lt;- plot_tree_basic(tree, tip_df, color_by = &quot;host_order&quot;, label_tips = TRUE, show_threshold = 99.5) Warning in fortify(data, ...): Arguments in `...` must be used. ✖ Problematic arguments: • as.Date = as.Date • yscale_mapping = yscale_mapping • hang = hang • size = 0.8 ℹ Did you misspell an argument name? Found more than one class &quot;phylo&quot; in cache; using the first, from namespace &#39;phyloseq&#39; Also defined by &#39;tidytree&#39; p_host_order # Build matrices kegg_mat &lt;- make_annotation_matrix(genome_annotations, &quot;kegg&quot;) amr_mat &lt;- make_annotation_matrix(genome_annotations, &quot;resistance_type&quot;) # Fisher + volcano kegg_fisher &lt;- run_fisher_tests(kegg_mat, genome_metadata, &quot;kegg&quot;) amr_fisher &lt;- run_fisher_tests(amr_mat, genome_metadata, &quot;amr&quot;) plot_volcano(kegg_fisher, &quot;kegg&quot;) plot_volcano(amr_fisher, &quot;amr&quot;) # PCA pca_kegg &lt;- run_pca(kegg_mat) pca_amr &lt;- run_pca(amr_mat) # PERMANOVA results &lt;- pa_permanova(kegg_mat, genome_metadata) # common: 30 # in KEGG only: 0 # in metadata only: 0 results$dist EHM013856 EHM016687 EHM018416 EHM019588 EHM025899 EHM034508 EHM036539 EHM042977 EHM016687 0.322901849 EHM018416 0.307922272 0.167241379 EHM019588 0.257142857 0.250759878 0.247619048 EHM025899 0.398097826 0.343283582 0.328616352 0.343884892 EHM034508 0.573643411 0.527738265 0.561863173 0.528043776 0.574380165 EHM036539 0.491612903 0.441926346 0.473913043 0.441256831 0.491083676 0.132969035 EHM042977 0.347119645 0.226351351 0.089523810 0.300623053 0.361934477 0.595100865 0.507890961 EHM043923 0.293948127 0.210272873 0.202020202 0.070116861 0.318250377 0.524822695 0.437057992 0.259075908 EHM050060 0.320781032 0.221003135 0.242326333 0.239520958 0.343065693 0.525730181 0.441828255 0.274478331 EHM055692 0.286501377 0.131955485 0.253869969 0.277620397 0.388203018 0.556430446 0.475130890 0.300304878 EHM066268 0.314084507 0.212361331 0.227868852 0.257824143 0.318926975 0.529329609 0.442896936 0.277419355 EHM079210 0.617500000 0.635526316 0.649386085 0.605433376 0.668806162 0.660167131 0.571627260 0.663474692 EHM081080 0.256302521 0.255192878 0.257716049 0.225947522 0.359832636 0.539787798 0.457671958 0.288343558 EHM082134 0.415422886 0.441138422 0.441453567 0.386010363 0.466921120 0.426183844 0.337969402 0.475366178 EHM082624 0.283159463 0.244732577 0.232081911 0.241001565 0.368975904 0.574257426 0.486600846 0.254266212 GCF_014230105.1 0.323258870 0.263309353 0.291605302 0.311231394 0.366711773 0.546854942 0.467349552 0.337681159 GCF_018138525.1 0.277074543 0.272047833 0.288580247 0.255102041 0.336690647 0.545087483 0.459677419 0.321592649 GCF_030131705.1 0.259970458 0.187908497 0.143356643 0.165869219 0.312024353 0.507936508 0.420977011 0.212947189 GCF_030357945.1 0.335164835 0.268181818 0.276729560 0.266471449 0.341074020 0.552845528 0.470985155 0.318322981 GCF_036957665.1 0.380890052 0.380027739 0.377713459 0.364005413 0.450928382 0.623425693 0.545226131 0.401154401 GCF_046518655.1 0.379076087 0.296969697 0.279552716 0.326149425 0.195826645 0.555096419 0.469780220 0.311111111 GCF_046555535.1 0.295389049 0.237341772 0.236363636 0.250000000 0.301829268 0.540730337 0.455944056 0.269293924 GCF_046555695.1 0.296402878 0.238546603 0.237623762 0.251134644 0.302891933 0.541374474 0.456703911 0.270491803 GCF_046555735.1 0.333793103 0.250384025 0.258373206 0.297258297 0.382102273 0.532413793 0.444903581 0.311424100 GCF_046559175.1 0.325681492 0.231884058 0.221658206 0.276853253 0.338880484 0.575208914 0.493074792 0.240677966 GCF_047313245.1 0.347578348 0.257188498 0.254180602 0.277016743 0.311145511 0.536023055 0.449067432 0.318107667 GCF_050782755.1 0.329113924 0.220985692 0.179966044 0.276374443 0.366423358 0.563961486 0.478737997 0.192832765 GCF_054185985.1 0.394946809 0.355491329 0.356927711 0.348739496 0.423822715 0.619480519 0.542635659 0.378947368 GCF_054186025.1 0.364806867 0.313971743 0.305280528 0.325825826 0.382530120 0.584985836 0.503516174 0.340425532 EHM043923 EHM050060 EHM055692 EHM066268 EHM079210 EHM081080 EHM082134 EHM082624 EHM016687 EHM018416 EHM019588 EHM025899 EHM034508 EHM036539 EHM042977 EHM043923 EHM050060 0.218750000 EHM055692 0.284883721 0.278335725 EHM066268 0.229687500 0.250379363 0.280979827 EHM079210 0.639686684 0.613577023 0.639506173 0.649167734 EHM081080 0.226726727 0.261939219 0.261904762 0.259475219 0.616060226 EHM082134 0.424479167 0.414948454 0.434032059 0.455808081 0.498673740 0.426980198 EHM082624 0.216393443 0.276827372 0.314243759 0.249602544 0.658698539 0.152733119 0.468140442 GCF_014230105.1 0.307262570 0.279329609 0.271739130 0.250000000 0.641916168 0.284366577 0.455516014 0.328611898 GCF_018138525.1 0.254135338 0.273391813 0.297071130 0.247761194 0.644555695 0.278873239 0.440149626 0.268404908 GCF_030131705.1 0.127731092 0.191387560 0.268436578 0.188102894 0.616822430 0.211567732 0.398936170 0.190635452 GCF_030357945.1 0.244648318 0.292397661 0.322222222 0.261976048 0.654088050 0.311452514 0.464019851 0.303951368 GCF_036957665.1 0.390946502 0.394347241 0.360372340 0.381991814 0.643122677 0.376315789 0.487425150 0.424033149 GCF_046518655.1 0.304804805 0.315249267 0.348611111 0.272314675 0.636835279 0.326300985 0.431145431 0.335356601 GCF_046555535.1 0.223809524 0.244992296 0.303597122 0.185897436 0.624834875 0.241430700 0.431906615 0.232520325 GCF_046555695.1 0.225039620 0.246153846 0.304597701 0.187200000 0.625329815 0.242559524 0.432642487 0.233766234 GCF_046555735.1 0.284857571 0.254872564 0.313725490 0.225460123 0.635083227 0.288352273 0.437974684 0.294478528 GCF_046559175.1 0.257503949 0.280245023 0.284660767 0.264385692 0.656618611 0.267857143 0.460645161 0.264181524 GCF_047313245.1 0.243589744 0.296183206 0.322206096 0.277950311 0.651655629 0.296023564 0.433289300 0.305732484 GCF_050782755.1 0.249221184 0.242703533 0.291486291 0.220657277 0.645077720 0.270072993 0.451530612 0.261146497 GCF_054185985.1 0.357758621 0.400275103 0.385234899 0.367231638 0.665413534 0.394666667 0.490820073 0.406025825 GCF_054186025.1 0.311424100 0.362146051 0.363505747 0.327718224 0.670650730 0.354978355 0.479843953 0.369158879 GCF_014230105.1 GCF_018138525.1 GCF_030131705.1 GCF_030357945.1 GCF_036957665.1 GCF_046518655.1 EHM016687 EHM018416 EHM019588 EHM025899 EHM034508 EHM036539 EHM042977 EHM043923 EHM050060 EHM055692 EHM066268 EHM079210 EHM081080 EHM082134 EHM082624 GCF_014230105.1 GCF_018138525.1 0.276478680 GCF_030131705.1 0.279600571 0.223076923 GCF_030357945.1 0.303693570 0.246312684 0.232198142 GCF_036957665.1 0.333333333 0.402631579 0.379166667 0.421813403 GCF_046518655.1 0.331967213 0.309248555 0.261609907 0.323188406 0.394021739 GCF_046555535.1 0.252525253 0.231707317 0.190243902 0.243491577 0.392318244 0.267281106 GCF_046555695.1 0.253602305 0.232876712 0.191558442 0.244648318 0.393150685 0.268404908 GCF_046555735.1 0.259154930 0.272594752 0.241112828 0.279001468 0.358024691 0.316788321 GCF_046559175.1 0.319268636 0.223602484 0.224919094 0.235569423 0.407713499 0.270606532 GCF_047313245.1 0.290647482 0.279878971 0.204283361 0.232704403 0.397489540 0.281493002 GCF_050782755.1 0.265335235 0.314037627 0.211200000 0.308370044 0.369806094 0.311475410 GCF_054185985.1 0.381389253 0.353268428 0.342565598 0.366806137 0.336578581 0.365957447 GCF_054186025.1 0.380359613 0.325859492 0.277688604 0.327794562 0.368876081 0.307931571 GCF_046555535.1 GCF_046555695.1 GCF_046555735.1 GCF_046559175.1 GCF_047313245.1 GCF_050782755.1 EHM016687 EHM018416 EHM019588 EHM025899 EHM034508 EHM036539 EHM042977 EHM043923 EHM050060 EHM055692 EHM066268 EHM079210 EHM081080 EHM082134 EHM082624 GCF_014230105.1 GCF_018138525.1 GCF_030131705.1 GCF_030357945.1 GCF_036957665.1 GCF_046518655.1 GCF_046555535.1 GCF_046555695.1 0.001785714 GCF_046555735.1 0.222395023 0.223602484 GCF_046559175.1 0.222580645 0.223832528 0.252713178 GCF_047313245.1 0.239549839 0.240770465 0.252730109 0.270833333 GCF_050782755.1 0.220285261 0.221518987 0.241960184 0.278382582 0.291925466 GCF_054185985.1 0.366237482 0.367142857 0.351694915 0.336779911 0.322338831 0.377652051 GCF_054186025.1 0.312989045 0.314062500 0.316030534 0.298076923 0.273322422 0.344036697 GCF_054185985.1 EHM016687 EHM018416 EHM019588 EHM025899 EHM034508 EHM036539 EHM042977 EHM043923 EHM050060 EHM055692 EHM066268 EHM079210 EHM081080 EHM082134 EHM082624 GCF_014230105.1 GCF_018138525.1 GCF_030131705.1 GCF_030357945.1 GCF_036957665.1 GCF_046518655.1 GCF_046555535.1 GCF_046555695.1 GCF_046555735.1 GCF_046559175.1 GCF_047313245.1 GCF_050782755.1 GCF_054185985.1 GCF_054186025.1 0.256329114 results$permanova Permutation test for adonis under reduced model Marginal effects of terms Permutation: free Number of permutations: 999 vegan::adonis2(formula = dist_pa ~ genome_size + completeness + host_type, data = meta, permutations = 999, by = &quot;margin&quot;) Df SumOfSqs R2 F Pr(&gt;F) genome_size 1 0.11642 0.05898 2.0238 0.037 * completeness 1 0.20836 0.10555 3.6221 0.022 * host_type 1 0.09819 0.04974 1.7070 0.058 . Residual 26 1.49567 0.75769 Total 29 1.97399 1.00000 --- Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 pcoa_res &lt;- ape::pcoa(results$dist, correction = &quot;cailliez&quot;) pcoa_df &lt;- data.frame( ID = rownames(results$pa_nz), PC1 = pcoa_res$vectors[, 1], PC2 = pcoa_res$vectors[, 2], host_type = genome_metadata$host_type, host_order = genome_metadata$host_order ) var_exp &lt;- round(100 * pcoa_res$values$Rel_corr_eig[1:2], 1) pcoa_kegg_pa &lt;- ggplot(pcoa_df, aes(PC1, PC2, color = host_type)) + geom_point(size = 2) + scale_color_manual(values = host_type_colors, name = &quot;Host type&quot;)+ theme_minimal() + labs( title = &quot;PCoA of KEGG presence/absence matrix across MAGs (colored by host type)&quot;, x = paste0(&quot;PC1 (&quot;,round(var_exp[1], 1), &quot;%)&quot;), y = paste0(&quot;PC2 (&quot;, round(var_exp[2], 1), &quot;%)&quot;) ) ggplot(pcoa_df, aes(PC1, PC2, color = host_order)) + geom_point(size = 2) + scale_color_manual(values = host_order_colors, name = &quot;Host order&quot;)+ theme_minimal() + labs( title = &quot;PCoA of KEGG presence/absence matrix across MAGs (colored by host order)&quot;, x = paste0(&quot;PC1 (&quot;,round(var_exp[1], 1), &quot;%)&quot;), y = paste0(&quot;PC2 (&quot;, round(var_exp[2], 1), &quot;%)&quot;) ) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]

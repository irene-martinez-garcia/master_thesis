# Functional Analysis

```{r load_data_mag, message=FALSE, warning=FALSE, echo=FALSE}
load("data/data.Rdata")
```

## Functional overview

#### Predicted genes
```{r predicted_stats, message=FALSE, warning=FALSE}
pred_genes <- genome_annotations %>%
  nrow()

cat(pred_genes)
```

#### Number of annotated genes and percentages
```{r annotation_stats, message=FALSE, warning=FALSE, fig.height=10, fig.width=10, fig.fullwidth=TRUE}
#How many genes have at least 1 annotation
genome_annota <- genome_annotations %>%
  filter(if_any(c(kegg, pfam, cazy), ~ !is.na(.))) %>%
  nrow()

cat(genome_annota)

#Percentage of predicted genes with at least 1 annotation
genome_annota*100/pred_genes
```

#### Number of KEGG annotatated genes and percentages
```{r kegg_stats_gut, message=FALSE, warning=FALSE, fig.height=10, fig.width=10, fig.fullwidth=TRUE}
# KEGG annotation
kegg_annota <- genome_annotations %>%
  filter(!is.na(kegg)) %>%
  nrow()
cat(kegg_annota)

# KEGG annotation percentage
kegg_annota*100/genome_annota
```

## Functional ordination

PCoA with Euclidean distances:
```{r pcoa_ordination, message=FALSE, fig.height=8, fig.width=10, fig.fullwidth=TRUE}
gift_pcoa <- genome_gifts %>%
    to.elements(., GIFT_db) %>%
    as.data.frame() %>%
    vegdist(method="euclidean") %>%
    pcoa()

gift_pcoa_rel_eigen <- gift_pcoa$values$Relative_eig[1:10]


# Get genome positions
gift_pcoa_vectors <- gift_pcoa$vectors %>% #extract vectors
  as.data.frame() %>% 
 dplyr::select(Axis.1,Axis.2) # keep the first 2 axes

gift_pcoa_eigenvalues <- gift_pcoa$values$Eigenvalues[c(1,2)]


#For the black arrows: Functional group loadings
gift_pcoa_gifts <- cov(genome_gifts, scale(gift_pcoa_vectors)) %*%   diag((gift_pcoa_eigenvalues/(nrow(genome_gifts)-1))^(-0.5)) %>%
  as.data.frame() %>% 
  rename(Axis.1=1,Axis.2=2) %>% 
  rownames_to_column(var="label") %>% 
  #get function summary vectors
  mutate(func=substr(label,1,3)) %>% 
  group_by(func) %>% 
  summarise(Axis.1=mean(Axis.1),
            Axis.2=mean(Axis.2)) %>% 
  rename(label=func) %>% 
  filter(!label %in% c("S01","S02","S03"))


```


```{r pcoa_ordination_plot, message=FALSE, fig.height=8, fig.width=10, fig.fullwidth=TRUE}
set.seed(101)
scale <- 20 # scale for vector loadings (to make arrows visible)
gift_pcoa_vectors %>% 
  rownames_to_column(var="ID") %>% 
  left_join(combined_metadata, by="ID") %>%
  ggplot() +
      #genome positions
      scale_color_manual(values=source_colors)+
      geom_point(aes(x=Axis.1,y=Axis.2, color = source), 
                 alpha=0.9, shape=16) +
      scale_size_continuous(range = c(0.1,5)) +
      #loading positions
      geom_segment(data=gift_pcoa_gifts, 
                   aes(x=0, y=0, xend=Axis.1 * scale, yend=Axis.2 * scale),
                    arrow = arrow(length = unit(0.3, "cm"), 
                    type = "open", 
                    angle = 25),
                    linewidth = 0.5, 
                    color = "black") +
     #Primary and secondary scale adjustments
     scale_x_continuous(name = paste0("PCoA1 (",round(gift_pcoa_rel_eigen[1]*100, digits = 2), " %)"),
                      sec.axis = sec_axis(~ . / scale, name = "Loadings on PCoA1")
            ) +
     scale_y_continuous(name = paste0("PCoA2 (",round(gift_pcoa_rel_eigen[2]*100, digits = 2), " %)"),
                      sec.axis = sec_axis(~ . / scale, name = "Loadings on PCoA2")
            ) +
    geom_label_repel(data = gift_pcoa_gifts,
                     aes(label = label, x = Axis.1 * scale, y = Axis.2 * scale),
                     segment.color = 'transparent') +
    xlim(-1,1) + 
    ylim(-1.5,1.5) +
    theme_minimal() + 
  
  labs(
    x = paste0("PCoA1 (", round(gift_pcoa_rel_eigen[1]*100, 2), " %)"),
    y = paste0("PCoA2 (", round(gift_pcoa_rel_eigen[2]*100, 2), " %)")
  )

```

```{r arrow functions euclidean}
arrow_functions <- gift_pcoa_gifts %>%
  left_join(GIFT_db, by = c("label" = "Code_function")) %>%
  group_by(label) %>%
  summarise(
    Axis.1 = mean(Axis.1),
    Axis.2 = mean(Axis.2),
    Function = first(Function),
    Domain  = first(Domain),
    Length  = sqrt(Axis.1^2 + Axis.2^2), # vector length
    .groups = "drop"
  ) %>%
  arrange(desc(Length))  # sort so most important arrows are first

arrow_functions


```

Using k-means to cluster the groups and check which MAGs cluster together:
```{r checking the groups}
coords <- gift_pcoa_vectors %>%
  rownames_to_column("MAG") %>%
  as_tibble()

set.seed(123)
km <- kmeans(coords[, c("Axis.1", "Axis.2")], centers = 4)

coords <- coords %>% mutate(cluster = factor(km$cluster))

```


```{r kmeans plot}
# centroids as a tibble for plotting
centroids <- as_tibble(km$centers) %>% mutate(cluster = factor(1:nrow(km$centers)))

ggplot(coords, aes(x = Axis.1, y = Axis.2, color = cluster)) +
  geom_point(size = 2, alpha = 0.8) +
  geom_point(data = centroids, aes(x = Axis.1, y = Axis.2, color = cluster),
             shape = 4, size = 5, stroke = 1.25) +   # X marks centroids
  theme_minimal() +
  labs(title = paste0("PCoA colored by kmeans (k=4)"),
       color = "cluster")

```

```{r cluster mag lists}
mags_by_cluster <- split(coords$MAG, km$cluster)
mags_by_cluster
```
### Checking each cluster at once
```{r clusters}
cluster1_MAGs <- mags_by_cluster[[1]]
combined_metadata %>% filter(ID %in% cluster1_MAGs)

cluster2_MAGs <- mags_by_cluster[[2]]
combined_metadata %>% filter(ID %in% cluster2_MAGs)

cluster3_MAGs <- mags_by_cluster[[3]]
combined_metadata %>% filter(ID %in% cluster3_MAGs)

cluster4_MAGs <- mags_by_cluster[[4]]
combined_metadata %>% filter(ID %in% cluster4_MAGs)
```


```{r combined table}
metadata_with_cluster <- combined_metadata %>%
  left_join(coords %>% select(MAG, cluster), by = c("ID" = "MAG"))

metadata_with_cluster %>%
  group_by(cluster, source) %>%
  summarise(n = n(), .groups = "drop") %>%
  arrange(cluster, desc(n))

# Group summaries
metadata_with_cluster %>%
  group_by(cluster) %>%
  summarise(mean_genome_size = mean(length, na.rm = TRUE),
            median_contamination = median(contamination, na.rm = TRUE),
            .groups = "drop")

```


Plots
```{r summary plots}
ggplot(metadata_with_cluster, aes(x = size, y = GC, col = cluster))+
  geom_point()+
  theme_bw()

ggplot(metadata_with_cluster, aes(x = assembly_type, y = source, col = cluster))+
  geom_point()+
  theme_bw()

ggplot(metadata_with_cluster, aes(x = cluster, y = size, col = cluster))+
  geom_point()+
  theme_bw()
```
```{r GIFT aggregations}
#Aggregate bundle-level GIFTs into the compound level
GIFTs_elements <- to.elements(genome_gifts,GIFT_db)

#Aggregate element-level GIFTs into the function level
GIFTs_functions <- to.functions(GIFTs_elements,GIFT_db)

#Aggregate function-level GIFTs into overall Biosynthesis, Degradation and Structural GIFTs
GIFTs_domains <- to.domains(GIFTs_functions,GIFT_db)

```

```{r gift plots}
coords_for_join <- coords %>% distinct(MAG, .keep_all = TRUE)

genome_order <- coords_for_join %>%
  distinct(MAG, cluster) %>%
  arrange(cluster, MAG) %>%
  pull(MAG)

library(RColorBrewer)
library(reshape2)

GIFTs_elements %>%
  reshape2::melt() %>%
  rename(MAG = Var1, Code_element = Var2, GIFT = value) %>%
  left_join(coords_for_join, by = "MAG") %>%
  left_join(GIFT_db, by = "Code_element") %>%
  mutate(MAG = factor(MAG, levels = genome_order)) %>%
  ggplot(aes(x = Code_element, y = MAG, fill = GIFT, group = Code_function)) +
    geom_tile() +
    scale_y_discrete(guide = guide_axis(check.overlap = TRUE)) +
    scale_x_discrete(guide = guide_axis(check.overlap = TRUE)) +
    scale_fill_gradientn(limits = c(0,1), colours = brewer.pal(7, "YlGnBu")) +
    facet_grid(. ~ Code_function, scales = "free", space = "free") +
    theme_grey(base_size = 8) +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
          strip.text.x = element_text(angle = 90))


```
```{r functions plot}
coords_for_join_2 <- coords_for_join %>% rename(Sample = MAG)

# Create ordered sample list by cluster
sample_order <- coords_for_join_2 %>%
  distinct(Sample, cluster) %>%
  arrange(cluster, Sample) %>%
  pull(Sample)

GIFTs_functions %>%
  reshape2::melt() %>%
  rename(Sample = Var1, Code_function = Var2, GIFT = value) %>%
  left_join(coords_for_join_2, by = "Sample") %>%        # add cluster info
  left_join(GIFT_db, by = "Code_function") %>%
  mutate(Sample = factor(Sample, levels = sample_order)) %>%  # reorder!
  ggplot(aes(x = Code_function, y = Sample, fill = GIFT)) +
    geom_tile() +
    scale_y_discrete(guide = guide_axis(check.overlap = TRUE)) +
    scale_x_discrete(guide = guide_axis(check.overlap = TRUE)) +
    scale_fill_gradientn(limits = c(0, 1), colours = brewer.pal(7, "YlGnBu")) +
    theme_grey(base_size = 8) +
    theme(
      axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
      strip.text.x = element_text(angle = 90)
    )

```




